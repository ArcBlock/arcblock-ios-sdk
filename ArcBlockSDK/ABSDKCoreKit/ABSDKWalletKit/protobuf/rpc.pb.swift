// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request / Response message definition
public struct Ocap_RequestEmpty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RequestPaginated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RequestGetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// send_tx(tx, wallet, token, commit \\ false)
public struct Ocap_RequestSendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: String = String()

  public var wallet: Ocap_WalletInfo {
    get {return _wallet ?? Ocap_WalletInfo()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  public var token: String = String()

  public var commit: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wallet: Ocap_WalletInfo? = nil
}

public struct Ocap_ResponseSendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// get_tx(hash)
public struct Ocap_RequestGetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var info: Ocap_TransactionInfo {
    get {return _info ?? Ocap_TransactionInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Ocap_TransactionInfo? = nil
}

/// get_block(height)
public struct Ocap_RequestGetBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var block: Ocap_BlockInfo {
    get {return _block ?? Ocap_BlockInfo()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {self._block = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _block: Ocap_BlockInfo? = nil
}

public struct Ocap_RequestGetBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var heightFilter: Ocap_RangeFilter {
    get {return _heightFilter ?? Ocap_RangeFilter()}
    set {_heightFilter = newValue}
  }
  /// Returns true if `heightFilter` has been explicitly set.
  public var hasHeightFilter: Bool {return self._heightFilter != nil}
  /// Clears the value of `heightFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHeightFilter() {self._heightFilter = nil}

  public var emptyExcluded: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _heightFilter: Ocap_RangeFilter? = nil
}

public struct Ocap_ResponseGetBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var blocks: [Ocap_BlockInfoSimple] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestGetAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var traceMigration: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_AccountState {
    get {return _state ?? Ocap_AccountState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_AccountState? = nil
}

public struct Ocap_ResponseGetAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_AssetState {
    get {return _state ?? Ocap_AssetState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_AssetState? = nil
}

/// get_forge_state(key): retrieve Forge state by key. If key is omitted, return
/// entire Forge state
public struct Ocap_ResponseGetForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_ForgeState {
    get {return _state ?? Ocap_ForgeState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_ForgeState? = nil
}

public struct Ocap_ResponseGetDelegateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_DelegateState {
    get {return _state ?? Ocap_DelegateState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_DelegateState? = nil
}

/// get_chain_info(): retrieve the current chain information
public struct Ocap_ResponseGetChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var info: Ocap_ChainInfo {
    get {return _storage._info ?? Ocap_ChainInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_node_info(): retrieve the current node information
public struct Ocap_ResponseGetNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var info: Ocap_NodeInfo {
    get {return _info ?? Ocap_NodeInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Ocap_NodeInfo? = nil
}

public struct Ocap_ResponseGetUnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var unconfirmedTxs: Ocap_UnconfirmedTxs {
    get {return _unconfirmedTxs ?? Ocap_UnconfirmedTxs()}
    set {_unconfirmedTxs = newValue}
  }
  /// Returns true if `unconfirmedTxs` has been explicitly set.
  public var hasUnconfirmedTxs: Bool {return self._unconfirmedTxs != nil}
  /// Clears the value of `unconfirmedTxs`. Subsequent reads from it will return its default value.
  public mutating func clearUnconfirmedTxs() {self._unconfirmedTxs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
  fileprivate var _unconfirmedTxs: Ocap_UnconfirmedTxs? = nil
}

public struct Ocap_ResponseGetNetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var netInfo: Ocap_NetInfo {
    get {return _netInfo ?? Ocap_NetInfo()}
    set {_netInfo = newValue}
  }
  /// Returns true if `netInfo` has been explicitly set.
  public var hasNetInfo: Bool {return self._netInfo != nil}
  /// Clears the value of `netInfo`. Subsequent reads from it will return its default value.
  public mutating func clearNetInfo() {self._netInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _netInfo: Ocap_NetInfo? = nil
}

public struct Ocap_ResponseGetValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var validatorsInfo: Ocap_ValidatorsInfo {
    get {return _validatorsInfo ?? Ocap_ValidatorsInfo()}
    set {_validatorsInfo = newValue}
  }
  /// Returns true if `validatorsInfo` has been explicitly set.
  public var hasValidatorsInfo: Bool {return self._validatorsInfo != nil}
  /// Clears the value of `validatorsInfo`. Subsequent reads from it will return its default value.
  public mutating func clearValidatorsInfo() {self._validatorsInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validatorsInfo: Ocap_ValidatorsInfo? = nil
}

/// get config
public struct Ocap_RequestGetConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parsed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var config: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RequestListTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var timeFilter: Ocap_TimeFilter {
    get {return _storage._timeFilter ?? Ocap_TimeFilter()}
    set {_uniqueStorage()._timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return _storage._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {_uniqueStorage()._timeFilter = nil}

  public var addressFilter: Ocap_AddressFilter {
    get {return _storage._addressFilter ?? Ocap_AddressFilter()}
    set {_uniqueStorage()._addressFilter = newValue}
  }
  /// Returns true if `addressFilter` has been explicitly set.
  public var hasAddressFilter: Bool {return _storage._addressFilter != nil}
  /// Clears the value of `addressFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAddressFilter() {_uniqueStorage()._addressFilter = nil}

  public var typeFilter: Ocap_TypeFilter {
    get {return _storage._typeFilter ?? Ocap_TypeFilter()}
    set {_uniqueStorage()._typeFilter = newValue}
  }
  /// Returns true if `typeFilter` has been explicitly set.
  public var hasTypeFilter: Bool {return _storage._typeFilter != nil}
  /// Clears the value of `typeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTypeFilter() {_uniqueStorage()._typeFilter = nil}

  public var validityFilter: Ocap_ValidityFilter {
    get {return _storage._validityFilter ?? Ocap_ValidityFilter()}
    set {_uniqueStorage()._validityFilter = newValue}
  }
  /// Returns true if `validityFilter` has been explicitly set.
  public var hasValidityFilter: Bool {return _storage._validityFilter != nil}
  /// Clears the value of `validityFilter`. Subsequent reads from it will return its default value.
  public mutating func clearValidityFilter() {_uniqueStorage()._validityFilter = nil}

  public var factoryFilter: Ocap_FactoryFilter {
    get {return _storage._factoryFilter ?? Ocap_FactoryFilter()}
    set {_uniqueStorage()._factoryFilter = newValue}
  }
  /// Returns true if `factoryFilter` has been explicitly set.
  public var hasFactoryFilter: Bool {return _storage._factoryFilter != nil}
  /// Clears the value of `factoryFilter`. Subsequent reads from it will return its default value.
  public mutating func clearFactoryFilter() {_uniqueStorage()._factoryFilter = nil}

  public var tokenFilter: Ocap_TokenFilter {
    get {return _storage._tokenFilter ?? Ocap_TokenFilter()}
    set {_uniqueStorage()._tokenFilter = newValue}
  }
  /// Returns true if `tokenFilter` has been explicitly set.
  public var hasTokenFilter: Bool {return _storage._tokenFilter != nil}
  /// Clears the value of `tokenFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTokenFilter() {_uniqueStorage()._tokenFilter = nil}

  public var assetFilter: Ocap_AssetFilter {
    get {return _storage._assetFilter ?? Ocap_AssetFilter()}
    set {_uniqueStorage()._assetFilter = newValue}
  }
  /// Returns true if `assetFilter` has been explicitly set.
  public var hasAssetFilter: Bool {return _storage._assetFilter != nil}
  /// Clears the value of `assetFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAssetFilter() {_uniqueStorage()._assetFilter = nil}

  public var accountFilter: Ocap_AccountFilter {
    get {return _storage._accountFilter ?? Ocap_AccountFilter()}
    set {_uniqueStorage()._accountFilter = newValue}
  }
  /// Returns true if `accountFilter` has been explicitly set.
  public var hasAccountFilter: Bool {return _storage._accountFilter != nil}
  /// Clears the value of `accountFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAccountFilter() {_uniqueStorage()._accountFilter = nil}

  public var txFilter: Ocap_TxFilter {
    get {return _storage._txFilter ?? Ocap_TxFilter()}
    set {_uniqueStorage()._txFilter = newValue}
  }
  /// Returns true if `txFilter` has been explicitly set.
  public var hasTxFilter: Bool {return _storage._txFilter != nil}
  /// Clears the value of `txFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTxFilter() {_uniqueStorage()._txFilter = nil}

  public var rollupFilter: Ocap_RollupFilter {
    get {return _storage._rollupFilter ?? Ocap_RollupFilter()}
    set {_uniqueStorage()._rollupFilter = newValue}
  }
  /// Returns true if `rollupFilter` has been explicitly set.
  public var hasRollupFilter: Bool {return _storage._rollupFilter != nil}
  /// Clears the value of `rollupFilter`. Subsequent reads from it will return its default value.
  public mutating func clearRollupFilter() {_uniqueStorage()._rollupFilter = nil}

  public var stakeFilter: Ocap_StakeFilter {
    get {return _storage._stakeFilter ?? Ocap_StakeFilter()}
    set {_uniqueStorage()._stakeFilter = newValue}
  }
  /// Returns true if `stakeFilter` has been explicitly set.
  public var hasStakeFilter: Bool {return _storage._stakeFilter != nil}
  /// Clears the value of `stakeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearStakeFilter() {_uniqueStorage()._stakeFilter = nil}

  public var delegationFilter: Ocap_DelegationFilter {
    get {return _storage._delegationFilter ?? Ocap_DelegationFilter()}
    set {_uniqueStorage()._delegationFilter = newValue}
  }
  /// Returns true if `delegationFilter` has been explicitly set.
  public var hasDelegationFilter: Bool {return _storage._delegationFilter != nil}
  /// Clears the value of `delegationFilter`. Subsequent reads from it will return its default value.
  public mutating func clearDelegationFilter() {_uniqueStorage()._delegationFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var transactions: [Ocap_IndexedTransaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var ownerAddress: String = String()

  public var factoryAddress: String = String()

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
}

public struct Ocap_ResponseListAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var assets: [Ocap_IndexedAssetState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListTopAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var tokenAddress: String = String()

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
}

public struct Ocap_ResponseListTopAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var accounts: [Ocap_IndexedAccountState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListAssetTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseListAssetTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var transactions: [Ocap_IndexedTransaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var proposer: String = String()

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var heightFilter: Ocap_RangeFilter {
    get {return _heightFilter ?? Ocap_RangeFilter()}
    set {_heightFilter = newValue}
  }
  /// Returns true if `heightFilter` has been explicitly set.
  public var hasHeightFilter: Bool {return self._heightFilter != nil}
  /// Clears the value of `heightFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHeightFilter() {self._heightFilter = nil}

  public var numTxsFilter: Ocap_RangeFilter {
    get {return _numTxsFilter ?? Ocap_RangeFilter()}
    set {_numTxsFilter = newValue}
  }
  /// Returns true if `numTxsFilter` has been explicitly set.
  public var hasNumTxsFilter: Bool {return self._numTxsFilter != nil}
  /// Clears the value of `numTxsFilter`. Subsequent reads from it will return its default value.
  public mutating func clearNumTxsFilter() {self._numTxsFilter = nil}

  public var numInvalidTxsFilter: Ocap_RangeFilter {
    get {return _numInvalidTxsFilter ?? Ocap_RangeFilter()}
    set {_numInvalidTxsFilter = newValue}
  }
  /// Returns true if `numInvalidTxsFilter` has been explicitly set.
  public var hasNumInvalidTxsFilter: Bool {return self._numInvalidTxsFilter != nil}
  /// Clears the value of `numInvalidTxsFilter`. Subsequent reads from it will return its default value.
  public mutating func clearNumInvalidTxsFilter() {self._numInvalidTxsFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
  fileprivate var _heightFilter: Ocap_RangeFilter? = nil
  fileprivate var _numTxsFilter: Ocap_RangeFilter? = nil
  fileprivate var _numInvalidTxsFilter: Ocap_RangeFilter? = nil
}

public struct Ocap_ResponseListBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var blocks: [Ocap_IndexedBlock] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

/// token related
public struct Ocap_ResponseGetTokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_TokenState {
    get {return _state ?? Ocap_TokenState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_TokenState? = nil
}

public struct Ocap_RequestListTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var issuerAddress: String = String()

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
}

public struct Ocap_ResponseListTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var tokens: [Ocap_IndexedTokenState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

/// asset factory related apis
public struct Ocap_ResponseGetFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_AssetFactoryState {
    get {return _state ?? Ocap_AssetFactoryState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_AssetFactoryState? = nil
}

public struct Ocap_RequestListFactories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var ownerAddress: String = String()

  public var addressList: [String] = []

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
}

public struct Ocap_ResponseListFactories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var factories: [Ocap_IndexedFactoryState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

/// account/factory tokens
public struct Ocap_RequestGetAccountTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be account of factory address
  public var address: String = String()

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetAccountTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var tokens: [Ocap_AccountToken] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// stakes
public struct Ocap_ResponseGetStakeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_StakeState {
    get {return _state ?? Ocap_StakeState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_StakeState? = nil
}

public struct Ocap_RequestListStakes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var addressFilter: Ocap_AddressFilter {
    get {return _addressFilter ?? Ocap_AddressFilter()}
    set {_addressFilter = newValue}
  }
  /// Returns true if `addressFilter` has been explicitly set.
  public var hasAddressFilter: Bool {return self._addressFilter != nil}
  /// Clears the value of `addressFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAddressFilter() {self._addressFilter = nil}

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var assetFilter: Ocap_AssetFilter {
    get {return _assetFilter ?? Ocap_AssetFilter()}
    set {_assetFilter = newValue}
  }
  /// Returns true if `assetFilter` has been explicitly set.
  public var hasAssetFilter: Bool {return self._assetFilter != nil}
  /// Clears the value of `assetFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAssetFilter() {self._assetFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _addressFilter: Ocap_AddressFilter? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
  fileprivate var _assetFilter: Ocap_AssetFilter? = nil
}

public struct Ocap_ResponseListStakes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var stakes: [Ocap_IndexedStakeState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

/// Rollup
public struct Ocap_ResponseGetRollupState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_RollupState {
    get {return _state ?? Ocap_RollupState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_RollupState? = nil
}

public struct Ocap_RequestListRollups {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var tokenAddress: String = String()

  /// same as erc20_token_address
  public var foreignTokenAddress: String = String()

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
}

public struct Ocap_ResponseListRollups {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var rollups: [Ocap_IndexedRollupState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestGetRollupBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var height: UInt64 = 0

  public var rollupAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetRollupBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var block: Ocap_RollupBlock {
    get {return _block ?? Ocap_RollupBlock()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {self._block = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _block: Ocap_RollupBlock? = nil
}

public struct Ocap_RequestListRollupBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var rollupAddress: String = String()

  public var tokenAddress: String = String()

  public var proposer: String = String()

  public var validatorFilter: Ocap_ValidatorFilter {
    get {return _validatorFilter ?? Ocap_ValidatorFilter()}
    set {_validatorFilter = newValue}
  }
  /// Returns true if `validatorFilter` has been explicitly set.
  public var hasValidatorFilter: Bool {return self._validatorFilter != nil}
  /// Clears the value of `validatorFilter`. Subsequent reads from it will return its default value.
  public mutating func clearValidatorFilter() {self._validatorFilter = nil}

  public var txFilter: Ocap_TxFilter {
    get {return _txFilter ?? Ocap_TxFilter()}
    set {_txFilter = newValue}
  }
  /// Returns true if `txFilter` has been explicitly set.
  public var hasTxFilter: Bool {return self._txFilter != nil}
  /// Clears the value of `txFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTxFilter() {self._txFilter = nil}

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _validatorFilter: Ocap_ValidatorFilter? = nil
  fileprivate var _txFilter: Ocap_TxFilter? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
}

public struct Ocap_ResponseListRollupBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var blocks: [Ocap_IndexedRollupBlock] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListRollupValidators {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var rollupAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseListRollupValidators {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var validators: [Ocap_IndexedRollupValidator] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var keyword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var results: [Ocap_SearchResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestGetEvidenceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetEvidenceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_EvidenceState {
    get {return _state ?? Ocap_EvidenceState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_EvidenceState? = nil
}

public struct Ocap_ResponseGetForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var forgeStats: Ocap_ForgeStats {
    get {return _forgeStats ?? Ocap_ForgeStats()}
    set {_forgeStats = newValue}
  }
  /// Returns true if `forgeStats` has been explicitly set.
  public var hasForgeStats: Bool {return self._forgeStats != nil}
  /// Clears the value of `forgeStats`. Subsequent reads from it will return its default value.
  public mutating func clearForgeStats() {self._forgeStats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _forgeStats: Ocap_ForgeStats? = nil
}

public struct Ocap_RequestEstimateGas {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typeURL: String = String()

  public var tx: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseEstimateGas {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var estimate: Ocap_GasEstimate {
    get {return _estimate ?? Ocap_GasEstimate()}
    set {_estimate = newValue}
  }
  /// Returns true if `estimate` has been explicitly set.
  public var hasEstimate: Bool {return self._estimate != nil}
  /// Clears the value of `estimate`. Subsequent reads from it will return its default value.
  public mutating func clearEstimate() {self._estimate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _estimate: Ocap_GasEstimate? = nil
}

public struct Ocap_RequestListDelegations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var from: String = String()

  public var to: String = String()

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
}

public struct Ocap_ResponseListDelegations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var delegations: [Ocap_IndexedDelegationState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_RequestEmpty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestEmpty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestEmpty, rhs: Ocap_RequestEmpty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestPaginated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestPaginated"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestPaginated, rhs: Ocap_RequestPaginated) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetState, rhs: Ocap_RequestGetState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestSendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSendTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "wallet"),
    3: .same(proto: "token"),
    4: .same(proto: "commit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.commit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tx.isEmpty {
      try visitor.visitSingularStringField(value: self.tx, fieldNumber: 1)
    }
    try { if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    if self.commit != false {
      try visitor.visitSingularBoolField(value: self.commit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestSendTx, rhs: Ocap_RequestSendTx) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs._wallet != rhs._wallet {return false}
    if lhs.token != rhs.token {return false}
    if lhs.commit != rhs.commit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseSendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSendTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseSendTx, rhs: Ocap_ResponseSendTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetTx, rhs: Ocap_RequestGetTx) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetTx, rhs: Ocap_ResponseGetTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetBlock, rhs: Ocap_RequestGetBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetBlock, rhs: Ocap_ResponseGetBlock) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._block != rhs._block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "height_filter"),
    3: .standard(proto: "empty_excluded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._heightFilter) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.emptyExcluded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._heightFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.emptyExcluded != false {
      try visitor.visitSingularBoolField(value: self.emptyExcluded, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetBlocks, rhs: Ocap_RequestGetBlocks) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs._heightFilter != rhs._heightFilter {return false}
    if lhs.emptyExcluded != rhs.emptyExcluded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetBlocks, rhs: Ocap_ResponseGetBlocks) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
    4: .standard(proto: "trace_migration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.traceMigration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    if self.traceMigration != false {
      try visitor.visitSingularBoolField(value: self.traceMigration, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetAccountState, rhs: Ocap_RequestGetAccountState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.traceMigration != rhs.traceMigration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAccountState, rhs: Ocap_ResponseGetAccountState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAssetState, rhs: Ocap_ResponseGetAssetState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetForgeState, rhs: Ocap_ResponseGetForgeState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetDelegateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetDelegateState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetDelegateState, rhs: Ocap_ResponseGetDelegateState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetChainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _info: Ocap_ChainInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._info) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      try { if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetChainInfo, rhs: Ocap_ResponseGetChainInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetNodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetNodeInfo, rhs: Ocap_ResponseGetNodeInfo) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetUnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetUnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .standard(proto: "unconfirmed_txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._unconfirmedTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._unconfirmedTxs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetUnconfirmedTxs, rhs: Ocap_ResponseGetUnconfirmedTxs) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs._unconfirmedTxs != rhs._unconfirmedTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetNetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetNetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "net_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._netInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._netInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetNetInfo, rhs: Ocap_ResponseGetNetInfo) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._netInfo != rhs._netInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetValidatorsInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "validators_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validatorsInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._validatorsInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetValidatorsInfo, rhs: Ocap_ResponseGetValidatorsInfo) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._validatorsInfo != rhs._validatorsInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parsed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.parsed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parsed != false {
      try visitor.visitSingularBoolField(value: self.parsed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetConfig, rhs: Ocap_RequestGetConfig) -> Bool {
    if lhs.parsed != rhs.parsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.config.isEmpty {
      try visitor.visitSingularStringField(value: self.config, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetConfig, rhs: Ocap_ResponseGetConfig) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "time_filter"),
    3: .standard(proto: "address_filter"),
    4: .standard(proto: "type_filter"),
    5: .standard(proto: "validity_filter"),
    6: .standard(proto: "factory_filter"),
    7: .standard(proto: "token_filter"),
    8: .standard(proto: "asset_filter"),
    9: .standard(proto: "account_filter"),
    10: .standard(proto: "tx_filter"),
    11: .standard(proto: "rollup_filter"),
    12: .standard(proto: "stake_filter"),
    13: .standard(proto: "delegation_filter"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _timeFilter: Ocap_TimeFilter? = nil
    var _addressFilter: Ocap_AddressFilter? = nil
    var _typeFilter: Ocap_TypeFilter? = nil
    var _validityFilter: Ocap_ValidityFilter? = nil
    var _factoryFilter: Ocap_FactoryFilter? = nil
    var _tokenFilter: Ocap_TokenFilter? = nil
    var _assetFilter: Ocap_AssetFilter? = nil
    var _accountFilter: Ocap_AccountFilter? = nil
    var _txFilter: Ocap_TxFilter? = nil
    var _rollupFilter: Ocap_RollupFilter? = nil
    var _stakeFilter: Ocap_StakeFilter? = nil
    var _delegationFilter: Ocap_DelegationFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _timeFilter = source._timeFilter
      _addressFilter = source._addressFilter
      _typeFilter = source._typeFilter
      _validityFilter = source._validityFilter
      _factoryFilter = source._factoryFilter
      _tokenFilter = source._tokenFilter
      _assetFilter = source._assetFilter
      _accountFilter = source._accountFilter
      _txFilter = source._txFilter
      _rollupFilter = source._rollupFilter
      _stakeFilter = source._stakeFilter
      _delegationFilter = source._delegationFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._paging) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._timeFilter) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._addressFilter) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._typeFilter) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._validityFilter) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._factoryFilter) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tokenFilter) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._assetFilter) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._accountFilter) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._txFilter) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._rollupFilter) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._stakeFilter) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._delegationFilter) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._timeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._addressFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._typeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._validityFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._factoryFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tokenFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._assetFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._accountFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._txFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._rollupFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._stakeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._delegationFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTransactions, rhs: Ocap_RequestListTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._timeFilter != rhs_storage._timeFilter {return false}
        if _storage._addressFilter != rhs_storage._addressFilter {return false}
        if _storage._typeFilter != rhs_storage._typeFilter {return false}
        if _storage._validityFilter != rhs_storage._validityFilter {return false}
        if _storage._factoryFilter != rhs_storage._factoryFilter {return false}
        if _storage._tokenFilter != rhs_storage._tokenFilter {return false}
        if _storage._assetFilter != rhs_storage._assetFilter {return false}
        if _storage._accountFilter != rhs_storage._accountFilter {return false}
        if _storage._txFilter != rhs_storage._txFilter {return false}
        if _storage._rollupFilter != rhs_storage._rollupFilter {return false}
        if _storage._stakeFilter != rhs_storage._stakeFilter {return false}
        if _storage._delegationFilter != rhs_storage._delegationFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTransactions, rhs: Ocap_ResponseListTransactions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "factory_address"),
    4: .standard(proto: "time_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.factoryAddress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 2)
    }
    if !self.factoryAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.factoryAddress, fieldNumber: 3)
    }
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListAssets, rhs: Ocap_RequestListAssets) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.factoryAddress != rhs.factoryAddress {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListAssets, rhs: Ocap_ResponseListAssets) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTopAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTopAccounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "tokenAddress"),
    3: .standard(proto: "time_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 2)
    }
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTopAccounts, rhs: Ocap_RequestListTopAccounts) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTopAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTopAccounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTopAccounts, rhs: Ocap_ResponseListTopAccounts) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListAssetTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAssetTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListAssetTransactions, rhs: Ocap_RequestListAssetTransactions) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListAssetTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAssetTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListAssetTransactions, rhs: Ocap_ResponseListAssetTransactions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "proposer"),
    3: .standard(proto: "time_filter"),
    4: .standard(proto: "height_filter"),
    5: .standard(proto: "num_txs_filter"),
    6: .standard(proto: "num_invalid_txs_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.proposer) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._heightFilter) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._numTxsFilter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._numInvalidTxsFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.proposer.isEmpty {
      try visitor.visitSingularStringField(value: self.proposer, fieldNumber: 2)
    }
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._heightFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._numTxsFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._numInvalidTxsFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListBlocks, rhs: Ocap_RequestListBlocks) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.proposer != rhs.proposer {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs._heightFilter != rhs._heightFilter {return false}
    if lhs._numTxsFilter != rhs._numTxsFilter {return false}
    if lhs._numInvalidTxsFilter != rhs._numInvalidTxsFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListBlocks, rhs: Ocap_ResponseListBlocks) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetTokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetTokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetTokenState, rhs: Ocap_ResponseGetTokenState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "issuer_address"),
    3: .standard(proto: "time_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.issuerAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.issuerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.issuerAddress, fieldNumber: 2)
    }
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTokens, rhs: Ocap_RequestListTokens) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.issuerAddress != rhs.issuerAddress {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTokens, rhs: Ocap_ResponseListTokens) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetFactoryState, rhs: Ocap_ResponseGetFactoryState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListFactories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListFactories"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "address_list"),
    4: .standard(proto: "time_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addressList) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 2)
    }
    if !self.addressList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addressList, fieldNumber: 3)
    }
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListFactories, rhs: Ocap_RequestListFactories) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.addressList != rhs.addressList {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListFactories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListFactories"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "factories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.factories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.factories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.factories, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListFactories, rhs: Ocap_ResponseListFactories) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.factories != rhs.factories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetAccountTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAccountTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetAccountTokens, rhs: Ocap_RequestGetAccountTokens) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAccountTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAccountTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAccountTokens, rhs: Ocap_ResponseGetAccountTokens) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetStakeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetStakeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetStakeState, rhs: Ocap_ResponseGetStakeState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListStakes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListStakes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "address_filter"),
    3: .standard(proto: "time_filter"),
    4: .standard(proto: "asset_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._addressFilter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._assetFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._addressFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._assetFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListStakes, rhs: Ocap_RequestListStakes) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs._addressFilter != rhs._addressFilter {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs._assetFilter != rhs._assetFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListStakes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListStakes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "stakes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.stakes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.stakes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stakes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListStakes, rhs: Ocap_ResponseListStakes) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.stakes != rhs.stakes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetRollupState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetRollupState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetRollupState, rhs: Ocap_ResponseGetRollupState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListRollups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListRollups"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "token_address"),
    3: .standard(proto: "foreign_token_address"),
    4: .standard(proto: "time_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.foreignTokenAddress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 2)
    }
    if !self.foreignTokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.foreignTokenAddress, fieldNumber: 3)
    }
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListRollups, rhs: Ocap_RequestListRollups) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.foreignTokenAddress != rhs.foreignTokenAddress {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListRollups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListRollups"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "rollups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rollups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.rollups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rollups, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListRollups, rhs: Ocap_ResponseListRollups) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.rollups != rhs.rollups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetRollupBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetRollupBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .standard(proto: "rollup_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rollupAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if !self.rollupAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rollupAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetRollupBlock, rhs: Ocap_RequestGetRollupBlock) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs.rollupAddress != rhs.rollupAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetRollupBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetRollupBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetRollupBlock, rhs: Ocap_ResponseGetRollupBlock) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._block != rhs._block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListRollupBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListRollupBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "rollup_address"),
    3: .standard(proto: "token_address"),
    4: .same(proto: "proposer"),
    5: .standard(proto: "validator_filter"),
    6: .standard(proto: "tx_filter"),
    7: .standard(proto: "time_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rollupAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.proposer) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._validatorFilter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._txFilter) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rollupAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rollupAddress, fieldNumber: 2)
    }
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 3)
    }
    if !self.proposer.isEmpty {
      try visitor.visitSingularStringField(value: self.proposer, fieldNumber: 4)
    }
    try { if let v = self._validatorFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._txFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListRollupBlocks, rhs: Ocap_RequestListRollupBlocks) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.rollupAddress != rhs.rollupAddress {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.proposer != rhs.proposer {return false}
    if lhs._validatorFilter != rhs._validatorFilter {return false}
    if lhs._txFilter != rhs._txFilter {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListRollupBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListRollupBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListRollupBlocks, rhs: Ocap_ResponseListRollupBlocks) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListRollupValidators: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListRollupValidators"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "rollup_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rollupAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rollupAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.rollupAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListRollupValidators, rhs: Ocap_RequestListRollupValidators) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.rollupAddress != rhs.rollupAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListRollupValidators: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListRollupValidators"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "validators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListRollupValidators, rhs: Ocap_ResponseListRollupValidators) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSearch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "keyword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestSearch, rhs: Ocap_RequestSearch) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSearch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseSearch, rhs: Ocap_ResponseSearch) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetEvidenceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetEvidenceState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetEvidenceState, rhs: Ocap_RequestGetEvidenceState) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetEvidenceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetEvidenceState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetEvidenceState, rhs: Ocap_ResponseGetEvidenceState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "forge_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._forgeStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._forgeStats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetForgeStats, rhs: Ocap_ResponseGetForgeStats) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._forgeStats != rhs._forgeStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestEstimateGas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestEstimateGas"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_url"),
    2: .same(proto: "tx"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.typeURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tx) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.typeURL, fieldNumber: 1)
    }
    if !self.tx.isEmpty {
      try visitor.visitSingularStringField(value: self.tx, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestEstimateGas, rhs: Ocap_RequestEstimateGas) -> Bool {
    if lhs.typeURL != rhs.typeURL {return false}
    if lhs.tx != rhs.tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseEstimateGas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseEstimateGas"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "estimate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._estimate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._estimate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseEstimateGas, rhs: Ocap_ResponseEstimateGas) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._estimate != rhs._estimate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListDelegations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListDelegations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "time_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 2)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 3)
    }
    try { if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListDelegations, rhs: Ocap_RequestListDelegations) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListDelegations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListDelegations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "delegations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.delegations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.delegations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delegations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListDelegations, rhs: Ocap_ResponseListDelegations) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.delegations != rhs.delegations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
