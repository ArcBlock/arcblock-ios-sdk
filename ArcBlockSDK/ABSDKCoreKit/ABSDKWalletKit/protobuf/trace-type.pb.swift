// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: trace-type.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Ocap_Direction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case mutual // = 0
  case oneWay // = 1
  case union // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .mutual
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mutual
    case 1: self = .oneWay
    case 2: self = .union
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .mutual: return 0
    case .oneWay: return 1
    case .union: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_Direction] = [
    .mutual,
    .oneWay,
    .union,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_Validity: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case both // = 0
  case valid // = 1
  case invalid // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .both
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .both
    case 1: self = .valid
    case 2: self = .invalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .both: return 0
    case .valid: return 1
    case .invalid: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_Validity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_Validity] = [
    .both,
    .valid,
    .invalid,
  ]
}

#endif  // swift(>=4.2)

public struct Ocap_PageOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String = String()

  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_Page {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cursor: String = String()

  public var size: UInt32 = 0

  public var order: [Ocap_PageOrder] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TypeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var types: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assets: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_FactoryFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var factories: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_DelegationFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var delegations: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TokenFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokens: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_StakeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stakes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AccountFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accounts: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TxFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var txs: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RollupFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rollups: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ValidatorFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validators: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TimeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startDateTime: String = String()

  public var endDateTime: String = String()

  public var field: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AddressFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: String = String()

  public var receiver: String = String()

  public var direction: Ocap_Direction = .mutual

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_PageInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cursor: String = String()

  public var next: Bool = false

  public var total: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TokenInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var balance: String = String()

  public var decimal: Int32 = 0

  public var unit: String = String()

  public var symbol: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ValidityFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validity: Ocap_Validity = .both

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RangeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: String = String()

  public var to: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AccountToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var symbol: String = String()

  public var balance: String = String()

  public var decimal: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ByDay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startDate: String = String()

  public var endDate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ByHour {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_IndexedTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  public var time: String {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var tx: Ocap_Transaction {
    get {return _storage._tx ?? Ocap_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  public var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  public mutating func clearTx() {_uniqueStorage()._tx = nil}

  public var valid: Bool {
    get {return _storage._valid}
    set {_uniqueStorage()._valid = newValue}
  }

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var tokenSymbols: [Ocap_TokenSymbol] {
    get {return _storage._tokenSymbols}
    set {_uniqueStorage()._tokenSymbols = newValue}
  }

  public var receipts: [Ocap_TransactionReceipt] {
    get {return _storage._receipts}
    set {_uniqueStorage()._receipts = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var balance: Ocap_BigUint {
    get {return _balance ?? Ocap_BigUint()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {self._balance = nil}

  public var numAssets: String = String()

  public var numTxs: String = String()

  public var nonce: String = String()

  public var genesisTime: String = String()

  public var renaissanceTime: String = String()

  public var moniker: String = String()

  public var migratedFrom: String = String()

  public var migratedTo: String = String()

  public var totalReceivedStakes: Ocap_BigUint {
    get {return _totalReceivedStakes ?? Ocap_BigUint()}
    set {_totalReceivedStakes = newValue}
  }
  /// Returns true if `totalReceivedStakes` has been explicitly set.
  public var hasTotalReceivedStakes: Bool {return self._totalReceivedStakes != nil}
  /// Clears the value of `totalReceivedStakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalReceivedStakes() {self._totalReceivedStakes = nil}

  public var totalStakes: Ocap_BigUint {
    get {return _totalStakes ?? Ocap_BigUint()}
    set {_totalStakes = newValue}
  }
  /// Returns true if `totalStakes` has been explicitly set.
  public var hasTotalStakes: Bool {return self._totalStakes != nil}
  /// Clears the value of `totalStakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalStakes() {self._totalStakes = nil}

  public var totalUnstakes: Ocap_BigUint {
    get {return _totalUnstakes ?? Ocap_BigUint()}
    set {_totalUnstakes = newValue}
  }
  /// Returns true if `totalUnstakes` has been explicitly set.
  public var hasTotalUnstakes: Bool {return self._totalUnstakes != nil}
  /// Clears the value of `totalUnstakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalUnstakes() {self._totalUnstakes = nil}

  public var recentNumTxs: [String] = []

  public var tokens: [Ocap_TokenInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _balance: Ocap_BigUint? = nil
  fileprivate var _totalReceivedStakes: Ocap_BigUint? = nil
  fileprivate var _totalStakes: Ocap_BigUint? = nil
  fileprivate var _totalUnstakes: Ocap_BigUint? = nil
}

public struct Ocap_IndexedAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var readonly: Bool {
    get {return _storage._readonly}
    set {_uniqueStorage()._readonly = newValue}
  }

  public var consumedTime: String {
    get {return _storage._consumedTime}
    set {_uniqueStorage()._consumedTime = newValue}
  }

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  public var transferrable: Bool {
    get {return _storage._transferrable}
    set {_uniqueStorage()._transferrable = newValue}
  }

  public var ttl: String {
    get {return _storage._ttl}
    set {_uniqueStorage()._ttl = newValue}
  }

  public var display: Ocap_NFTDisplay {
    get {return _storage._display ?? Ocap_NFTDisplay()}
    set {_uniqueStorage()._display = newValue}
  }
  /// Returns true if `display` has been explicitly set.
  public var hasDisplay: Bool {return _storage._display != nil}
  /// Clears the value of `display`. Subsequent reads from it will return its default value.
  public mutating func clearDisplay() {_uniqueStorage()._display = nil}

  public var endpoint: Ocap_NFTEndpoint {
    get {return _storage._endpoint ?? Ocap_NFTEndpoint()}
    set {_uniqueStorage()._endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  public var hasEndpoint: Bool {return _storage._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  public mutating func clearEndpoint() {_uniqueStorage()._endpoint = nil}

  public var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: String = String()

  public var time: String = String()

  public var proposer: String = String()

  public var numTxs: String = String()

  public var numInvalidTxs: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_IndexedTokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  public var unit: String {
    get {return _storage._unit}
    set {_uniqueStorage()._unit = newValue}
  }

  public var decimal: Int32 {
    get {return _storage._decimal}
    set {_uniqueStorage()._decimal = newValue}
  }

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var icon: String {
    get {return _storage._icon}
    set {_uniqueStorage()._icon = newValue}
  }

  public var totalSupply: String {
    get {return _storage._totalSupply}
    set {_uniqueStorage()._totalSupply = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var foreignToken: Ocap_ForeignToken {
    get {return _storage._foreignToken ?? Ocap_ForeignToken()}
    set {_uniqueStorage()._foreignToken = newValue}
  }
  /// Returns true if `foreignToken` has been explicitly set.
  public var hasForeignToken: Bool {return _storage._foreignToken != nil}
  /// Clears the value of `foreignToken`. Subsequent reads from it will return its default value.
  public mutating func clearForeignToken() {_uniqueStorage()._foreignToken = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var settlement: String {
    get {return _storage._settlement}
    set {_uniqueStorage()._settlement = newValue}
  }

  public var limit: String {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  public var trustedIssuers: [String] {
    get {return _storage._trustedIssuers}
    set {_uniqueStorage()._trustedIssuers = newValue}
  }

  public var input: Ocap_IndexedFactoryInput {
    get {return _storage._input ?? Ocap_IndexedFactoryInput()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  public var output: Ocap_CreateAssetTx {
    get {return _storage._output ?? Ocap_CreateAssetTx()}
    set {_uniqueStorage()._output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return _storage._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {_uniqueStorage()._output = nil}

  public var hooks: [Ocap_AssetFactoryHook] {
    get {return _storage._hooks}
    set {_uniqueStorage()._hooks = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var balance: String {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  public var tokens: [Ocap_TokenInfo] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var numMinted: UInt32 {
    get {return _storage._numMinted}
    set {_uniqueStorage()._numMinted = newValue}
  }

  public var lastSettlement: String {
    get {return _storage._lastSettlement}
    set {_uniqueStorage()._lastSettlement = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var display: Ocap_NFTDisplay {
    get {return _storage._display ?? Ocap_NFTDisplay()}
    set {_uniqueStorage()._display = newValue}
  }
  /// Returns true if `display` has been explicitly set.
  public var hasDisplay: Bool {return _storage._display != nil}
  /// Clears the value of `display`. Subsequent reads from it will return its default value.
  public mutating func clearDisplay() {_uniqueStorage()._display = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedStakeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var sender: String = String()

  public var receiver: String = String()

  public var tokens: [Ocap_TokenInfo] = []

  public var assets: [String] = []

  public var revocable: Bool = false

  public var genesisTime: String = String()

  public var renaissanceTime: String = String()

  public var message: String = String()

  public var revokeWaitingPeriod: UInt32 = 0

  public var revokedTokens: [Ocap_TokenInfo] = []

  public var revokedAssets: [String] = []

  public var slashers: [String] = []

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Ocap_IndexedRollupState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var tokenAddress: String {
    get {return _storage._tokenAddress}
    set {_uniqueStorage()._tokenAddress = newValue}
  }

  public var vaultAddress: String {
    get {return _storage._vaultAddress}
    set {_uniqueStorage()._vaultAddress = newValue}
  }

  public var contractAddress: String {
    get {return _storage._contractAddress}
    set {_uniqueStorage()._contractAddress = newValue}
  }

  public var seedValidators: [Ocap_RollupValidator] {
    get {return _storage._seedValidators}
    set {_uniqueStorage()._seedValidators = newValue}
  }

  public var validators: [Ocap_RollupValidator] {
    get {return _storage._validators}
    set {_uniqueStorage()._validators = newValue}
  }

  public var minStakeAmount: String {
    get {return _storage._minStakeAmount}
    set {_uniqueStorage()._minStakeAmount = newValue}
  }

  public var maxStakeAmount: String {
    get {return _storage._maxStakeAmount}
    set {_uniqueStorage()._maxStakeAmount = newValue}
  }

  public var minSignerCount: UInt32 {
    get {return _storage._minSignerCount}
    set {_uniqueStorage()._minSignerCount = newValue}
  }

  public var maxSignerCount: UInt32 {
    get {return _storage._maxSignerCount}
    set {_uniqueStorage()._maxSignerCount = newValue}
  }

  public var minBlockSize: UInt32 {
    get {return _storage._minBlockSize}
    set {_uniqueStorage()._minBlockSize = newValue}
  }

  public var maxBlockSize: UInt32 {
    get {return _storage._maxBlockSize}
    set {_uniqueStorage()._maxBlockSize = newValue}
  }

  public var minBlockInterval: UInt32 {
    get {return _storage._minBlockInterval}
    set {_uniqueStorage()._minBlockInterval = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var tokenInfo: Ocap_IndexedTokenInput {
    get {return _storage._tokenInfo ?? Ocap_IndexedTokenInput()}
    set {_uniqueStorage()._tokenInfo = newValue}
  }
  /// Returns true if `tokenInfo` has been explicitly set.
  public var hasTokenInfo: Bool {return _storage._tokenInfo != nil}
  /// Clears the value of `tokenInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTokenInfo() {_uniqueStorage()._tokenInfo = nil}

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var depositFeeRate: UInt32 {
    get {return _storage._depositFeeRate}
    set {_uniqueStorage()._depositFeeRate = newValue}
  }

  public var withdrawFeeRate: UInt32 {
    get {return _storage._withdrawFeeRate}
    set {_uniqueStorage()._withdrawFeeRate = newValue}
  }

  public var proposerFeeShare: UInt32 {
    get {return _storage._proposerFeeShare}
    set {_uniqueStorage()._proposerFeeShare = newValue}
  }

  public var minDepositAmount: String {
    get {return _storage._minDepositAmount}
    set {_uniqueStorage()._minDepositAmount = newValue}
  }

  public var minWithdrawAmount: String {
    get {return _storage._minWithdrawAmount}
    set {_uniqueStorage()._minWithdrawAmount = newValue}
  }

  public var blockHeight: UInt64 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  public var blockHash: String {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  public var minBlockConfirmation: UInt32 {
    get {return _storage._minBlockConfirmation}
    set {_uniqueStorage()._minBlockConfirmation = newValue}
  }

  public var totalDepositAmount: String {
    get {return _storage._totalDepositAmount}
    set {_uniqueStorage()._totalDepositAmount = newValue}
  }

  public var totalWithdrawAmount: String {
    get {return _storage._totalWithdrawAmount}
    set {_uniqueStorage()._totalWithdrawAmount = newValue}
  }

  /// Added since v1.13.45
  public var maxDepositAmount: String {
    get {return _storage._maxDepositAmount}
    set {_uniqueStorage()._maxDepositAmount = newValue}
  }

  public var maxWithdrawAmount: String {
    get {return _storage._maxWithdrawAmount}
    set {_uniqueStorage()._maxWithdrawAmount = newValue}
  }

  public var minDepositFee: String {
    get {return _storage._minDepositFee}
    set {_uniqueStorage()._minDepositFee = newValue}
  }

  public var maxDepositFee: String {
    get {return _storage._maxDepositFee}
    set {_uniqueStorage()._maxDepositFee = newValue}
  }

  public var minWithdrawFee: String {
    get {return _storage._minWithdrawFee}
    set {_uniqueStorage()._minWithdrawFee = newValue}
  }

  public var maxWithdrawFee: String {
    get {return _storage._maxWithdrawFee}
    set {_uniqueStorage()._maxWithdrawFee = newValue}
  }

  public var paused: Bool {
    get {return _storage._paused}
    set {_uniqueStorage()._paused = newValue}
  }

  /// Added since v1.13.47
  public var foreignToken: Ocap_ForeignToken {
    get {return _storage._foreignToken ?? Ocap_ForeignToken()}
    set {_uniqueStorage()._foreignToken = newValue}
  }
  /// Returns true if `foreignToken` has been explicitly set.
  public var hasForeignToken: Bool {return _storage._foreignToken != nil}
  /// Clears the value of `foreignToken`. Subsequent reads from it will return its default value.
  public mutating func clearForeignToken() {_uniqueStorage()._foreignToken = nil}

  /// Added since v1.13.53
  public var leaveWaitingPeriod: UInt32 {
    get {return _storage._leaveWaitingPeriod}
    set {_uniqueStorage()._leaveWaitingPeriod = newValue}
  }

  /// Added since v1.13.57
  public var publisherFeeShare: UInt32 {
    get {return _storage._publisherFeeShare}
    set {_uniqueStorage()._publisherFeeShare = newValue}
  }

  /// Added since v1.13.61
  public var publishWaitingPeriod: UInt32 {
    get {return _storage._publishWaitingPeriod}
    set {_uniqueStorage()._publishWaitingPeriod = newValue}
  }

  public var publishSlashRate: UInt32 {
    get {return _storage._publishSlashRate}
    set {_uniqueStorage()._publishSlashRate = newValue}
  }

  /// Added since v1.13.71
  public var migrateHistory: [String] {
    get {return _storage._migrateHistory}
    set {_uniqueStorage()._migrateHistory = newValue}
  }

  /// Added since v1.18.32
  public var closed: Bool {
    get {return _storage._closed}
    set {_uniqueStorage()._closed = newValue}
  }

  public var vaultHistory: [String] {
    get {return _storage._vaultHistory}
    set {_uniqueStorage()._vaultHistory = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedRollupBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var merkleRoot: String {
    get {return _storage._merkleRoot}
    set {_uniqueStorage()._merkleRoot = newValue}
  }

  public var previousHash: String {
    get {return _storage._previousHash}
    set {_uniqueStorage()._previousHash = newValue}
  }

  public var txsHash: String {
    get {return _storage._txsHash}
    set {_uniqueStorage()._txsHash = newValue}
  }

  public var txs: [String] {
    get {return _storage._txs}
    set {_uniqueStorage()._txs = newValue}
  }

  public var proposer: String {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  public var signatures: [Ocap_Multisig] {
    get {return _storage._signatures}
    set {_uniqueStorage()._signatures = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var rollup: String {
    get {return _storage._rollup}
    set {_uniqueStorage()._rollup = newValue}
  }

  public var mintedAmount: String {
    get {return _storage._mintedAmount}
    set {_uniqueStorage()._mintedAmount = newValue}
  }

  public var burnedAmount: String {
    get {return _storage._burnedAmount}
    set {_uniqueStorage()._burnedAmount = newValue}
  }

  public var rewardAmount: String {
    get {return _storage._rewardAmount}
    set {_uniqueStorage()._rewardAmount = newValue}
  }

  /// Added since v1.18.32
  public var governance: Bool {
    get {return _storage._governance}
    set {_uniqueStorage()._governance = newValue}
  }

  public var tokenInfo: Ocap_IndexedTokenInput {
    get {return _storage._tokenInfo ?? Ocap_IndexedTokenInput()}
    set {_uniqueStorage()._tokenInfo = newValue}
  }
  /// Returns true if `tokenInfo` has been explicitly set.
  public var hasTokenInfo: Bool {return _storage._tokenInfo != nil}
  /// Clears the value of `tokenInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTokenInfo() {_uniqueStorage()._tokenInfo = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_SearchResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_IndexedRollupValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pk: String {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var endpoint: String {
    get {return _storage._endpoint}
    set {_uniqueStorage()._endpoint = newValue}
  }

  public var joinTime: String {
    get {return _storage._joinTime}
    set {_uniqueStorage()._joinTime = newValue}
  }

  public var leaveTime: String {
    get {return _storage._leaveTime}
    set {_uniqueStorage()._leaveTime = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  /// accumulative
  public var totalStake: String {
    get {return _storage._totalStake}
    set {_uniqueStorage()._totalStake = newValue}
  }

  /// accumulative
  public var revokedStake: String {
    get {return _storage._revokedStake}
    set {_uniqueStorage()._revokedStake = newValue}
  }

  /// current
  public var availableStake: String {
    get {return _storage._availableStake}
    set {_uniqueStorage()._availableStake = newValue}
  }

  public var totalGain: String {
    get {return _storage._totalGain}
    set {_uniqueStorage()._totalGain = newValue}
  }

  public var proposedBlockCount: UInt64 {
    get {return _storage._proposedBlockCount}
    set {_uniqueStorage()._proposedBlockCount = newValue}
  }

  public var verifiedBlockCount: UInt64 {
    get {return _storage._verifiedBlockCount}
    set {_uniqueStorage()._verifiedBlockCount = newValue}
  }

  public var latestBlockHeight: UInt64 {
    get {return _storage._latestBlockHeight}
    set {_uniqueStorage()._latestBlockHeight = newValue}
  }

  public var latestBlockHash: String {
    get {return _storage._latestBlockHash}
    set {_uniqueStorage()._latestBlockHash = newValue}
  }

  public var rollup: String {
    get {return _storage._rollup}
    set {_uniqueStorage()._rollup = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedDelegationState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var from: String = String()

  public var to: String = String()

  public var genesisTime: String = String()

  public var renaissanceTime: String = String()

  public var ops: Dictionary<String,Ocap_DelegateOpState> = [:]

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUTUAL"),
    1: .same(proto: "ONE_WAY"),
    2: .same(proto: "UNION"),
  ]
}

extension Ocap_Validity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOTH"),
    1: .same(proto: "VALID"),
    2: .same(proto: "INVALID"),
  ]
}

extension Ocap_PageOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.field) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_PageOrder, rhs: Ocap_PageOrder) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_Page: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Page"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .same(proto: "size"),
    3: .same(proto: "order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.order) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.order.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.order, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_Page, rhs: Ocap_Page) -> Bool {
    if lhs.cursor != rhs.cursor {return false}
    if lhs.size != rhs.size {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TypeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TypeFilter, rhs: Ocap_TypeFilter) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFilter, rhs: Ocap_AssetFilter) -> Bool {
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_FactoryFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FactoryFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "factories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.factories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.factories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.factories, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_FactoryFilter, rhs: Ocap_FactoryFilter) -> Bool {
    if lhs.factories != rhs.factories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegationFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegationFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delegations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.delegations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delegations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.delegations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegationFilter, rhs: Ocap_DelegationFilter) -> Bool {
    if lhs.delegations != rhs.delegations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tokens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenFilter, rhs: Ocap_TokenFilter) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_StakeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stakes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.stakes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stakes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stakes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_StakeFilter, rhs: Ocap_StakeFilter) -> Bool {
    if lhs.stakes != rhs.stakes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AccountFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AccountFilter, rhs: Ocap_AccountFilter) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TxFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.txs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.txs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TxFilter, rhs: Ocap_TxFilter) -> Bool {
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RollupFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollupFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rollups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.rollups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rollups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rollups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RollupFilter, rhs: Ocap_RollupFilter) -> Bool {
    if lhs.rollups != rhs.rollups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ValidatorFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.validators) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validators.isEmpty {
      try visitor.visitRepeatedStringField(value: self.validators, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ValidatorFilter, rhs: Ocap_ValidatorFilter) -> Bool {
    if lhs.validators != rhs.validators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TimeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_date_time"),
    2: .standard(proto: "end_date_time"),
    3: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.startDateTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endDateTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.field) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startDateTime.isEmpty {
      try visitor.visitSingularStringField(value: self.startDateTime, fieldNumber: 1)
    }
    if !self.endDateTime.isEmpty {
      try visitor.visitSingularStringField(value: self.endDateTime, fieldNumber: 2)
    }
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TimeFilter, rhs: Ocap_TimeFilter) -> Bool {
    if lhs.startDateTime != rhs.startDateTime {return false}
    if lhs.endDateTime != rhs.endDateTime {return false}
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AddressFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "receiver"),
    3: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 2)
    }
    if self.direction != .mutual {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AddressFilter, rhs: Ocap_AddressFilter) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_PageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .same(proto: "next"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.next) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 1)
    }
    if self.next != false {
      try visitor.visitSingularBoolField(value: self.next, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularUInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_PageInfo, rhs: Ocap_PageInfo) -> Bool {
    if lhs.cursor != rhs.cursor {return false}
    if lhs.next != rhs.next {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
    3: .same(proto: "decimal"),
    4: .same(proto: "unit"),
    5: .same(proto: "symbol"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.balance) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.decimal) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.balance.isEmpty {
      try visitor.visitSingularStringField(value: self.balance, fieldNumber: 2)
    }
    if self.decimal != 0 {
      try visitor.visitSingularInt32Field(value: self.decimal, fieldNumber: 3)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 4)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenInfo, rhs: Ocap_TokenInfo) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.decimal != rhs.decimal {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ValidityFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidityFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.validity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.validity != .both {
      try visitor.visitSingularEnumField(value: self.validity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ValidityFilter, rhs: Ocap_ValidityFilter) -> Bool {
    if lhs.validity != rhs.validity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RangeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RangeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RangeFilter, rhs: Ocap_RangeFilter) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AccountToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "symbol"),
    3: .same(proto: "balance"),
    4: .same(proto: "decimal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.balance) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.decimal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.balance.isEmpty {
      try visitor.visitSingularStringField(value: self.balance, fieldNumber: 3)
    }
    if self.decimal != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimal, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AccountToken, rhs: Ocap_AccountToken) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.decimal != rhs.decimal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ByDay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByDay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_date"),
    2: .standard(proto: "end_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.startDate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 1)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ByDay, rhs: Ocap_ByDay) -> Bool {
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ByHour: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByHour"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ByHour, rhs: Ocap_ByHour) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .same(proto: "time"),
    5: .same(proto: "type"),
    6: .same(proto: "tx"),
    20: .same(proto: "valid"),
    21: .same(proto: "code"),
    22: .standard(proto: "token_symbols"),
    16: .same(proto: "receipts"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _sender: String = String()
    var _receiver: String = String()
    var _time: String = String()
    var _type: String = String()
    var _tx: Ocap_Transaction? = nil
    var _valid: Bool = false
    var _code: Ocap_StatusCode = .ok
    var _tokenSymbols: [Ocap_TokenSymbol] = []
    var _receipts: [Ocap_TransactionReceipt] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _sender = source._sender
      _receiver = source._receiver
      _time = source._time
      _type = source._type
      _tx = source._tx
      _valid = source._valid
      _code = source._code
      _tokenSymbols = source._tokenSymbols
      _receipts = source._receipts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._hash) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sender) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._receiver) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._tx) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._receipts) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._valid) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokenSymbols) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 2)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 3)
      }
      if !_storage._time.isEmpty {
        try visitor.visitSingularStringField(value: _storage._time, fieldNumber: 4)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 5)
      }
      try { if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._receipts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._receipts, fieldNumber: 16)
      }
      if _storage._valid != false {
        try visitor.visitSingularBoolField(value: _storage._valid, fieldNumber: 20)
      }
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 21)
      }
      if !_storage._tokenSymbols.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokenSymbols, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedTransaction, rhs: Ocap_IndexedTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._tx != rhs_storage._tx {return false}
        if _storage._valid != rhs_storage._valid {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._tokenSymbols != rhs_storage._tokenSymbols {return false}
        if _storage._receipts != rhs_storage._receipts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
    3: .standard(proto: "num_assets"),
    4: .standard(proto: "num_txs"),
    5: .same(proto: "nonce"),
    6: .standard(proto: "genesis_time"),
    7: .standard(proto: "renaissance_time"),
    8: .same(proto: "moniker"),
    9: .standard(proto: "migrated_from"),
    10: .standard(proto: "migrated_to"),
    11: .standard(proto: "total_received_stakes"),
    12: .standard(proto: "total_stakes"),
    13: .standard(proto: "total_unstakes"),
    14: .standard(proto: "recent_num_txs"),
    15: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.numAssets) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.numTxs) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nonce) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.genesisTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.renaissanceTime) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.moniker) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.migratedFrom) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.migratedTo) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._totalReceivedStakes) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._totalStakes) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._totalUnstakes) }()
      case 14: try { try decoder.decodeRepeatedStringField(value: &self.recentNumTxs) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.numAssets.isEmpty {
      try visitor.visitSingularStringField(value: self.numAssets, fieldNumber: 3)
    }
    if !self.numTxs.isEmpty {
      try visitor.visitSingularStringField(value: self.numTxs, fieldNumber: 4)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 5)
    }
    if !self.genesisTime.isEmpty {
      try visitor.visitSingularStringField(value: self.genesisTime, fieldNumber: 6)
    }
    if !self.renaissanceTime.isEmpty {
      try visitor.visitSingularStringField(value: self.renaissanceTime, fieldNumber: 7)
    }
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 8)
    }
    if !self.migratedFrom.isEmpty {
      try visitor.visitSingularStringField(value: self.migratedFrom, fieldNumber: 9)
    }
    if !self.migratedTo.isEmpty {
      try visitor.visitSingularStringField(value: self.migratedTo, fieldNumber: 10)
    }
    try { if let v = self._totalReceivedStakes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._totalStakes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._totalUnstakes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    if !self.recentNumTxs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.recentNumTxs, fieldNumber: 14)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedAccountState, rhs: Ocap_IndexedAccountState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.numAssets != rhs.numAssets {return false}
    if lhs.numTxs != rhs.numTxs {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.genesisTime != rhs.genesisTime {return false}
    if lhs.renaissanceTime != rhs.renaissanceTime {return false}
    if lhs.moniker != rhs.moniker {return false}
    if lhs.migratedFrom != rhs.migratedFrom {return false}
    if lhs.migratedTo != rhs.migratedTo {return false}
    if lhs._totalReceivedStakes != rhs._totalReceivedStakes {return false}
    if lhs._totalStakes != rhs._totalStakes {return false}
    if lhs._totalUnstakes != rhs._totalUnstakes {return false}
    if lhs.recentNumTxs != rhs.recentNumTxs {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .standard(proto: "genesis_time"),
    4: .standard(proto: "renaissance_time"),
    5: .same(proto: "moniker"),
    6: .same(proto: "readonly"),
    7: .standard(proto: "consumed_time"),
    8: .same(proto: "issuer"),
    9: .same(proto: "parent"),
    10: .same(proto: "transferrable"),
    11: .same(proto: "ttl"),
    12: .same(proto: "display"),
    13: .same(proto: "endpoint"),
    14: .same(proto: "tags"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _moniker: String = String()
    var _readonly: Bool = false
    var _consumedTime: String = String()
    var _issuer: String = String()
    var _parent: String = String()
    var _transferrable: Bool = false
    var _ttl: String = String()
    var _display: Ocap_NFTDisplay? = nil
    var _endpoint: Ocap_NFTEndpoint? = nil
    var _tags: [String] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _moniker = source._moniker
      _readonly = source._readonly
      _consumedTime = source._consumedTime
      _issuer = source._issuer
      _parent = source._parent
      _transferrable = source._transferrable
      _ttl = source._ttl
      _display = source._display
      _endpoint = source._endpoint
      _tags = source._tags
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._owner) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._genesisTime) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._renaissanceTime) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._moniker) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._readonly) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._consumedTime) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._issuer) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._transferrable) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._ttl) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._display) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._endpoint) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 3)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 4)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 5)
      }
      if _storage._readonly != false {
        try visitor.visitSingularBoolField(value: _storage._readonly, fieldNumber: 6)
      }
      if !_storage._consumedTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._consumedTime, fieldNumber: 7)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 8)
      }
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 9)
      }
      if _storage._transferrable != false {
        try visitor.visitSingularBoolField(value: _storage._transferrable, fieldNumber: 10)
      }
      if !_storage._ttl.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ttl, fieldNumber: 11)
      }
      try { if let v = _storage._display {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._endpoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 14)
      }
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedAssetState, rhs: Ocap_IndexedAssetState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._readonly != rhs_storage._readonly {return false}
        if _storage._consumedTime != rhs_storage._consumedTime {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._transferrable != rhs_storage._transferrable {return false}
        if _storage._ttl != rhs_storage._ttl {return false}
        if _storage._display != rhs_storage._display {return false}
        if _storage._endpoint != rhs_storage._endpoint {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "time"),
    3: .same(proto: "proposer"),
    4: .standard(proto: "num_txs"),
    5: .standard(proto: "num_invalid_txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.height) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.proposer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.numTxs) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.numInvalidTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.height.isEmpty {
      try visitor.visitSingularStringField(value: self.height, fieldNumber: 1)
    }
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 2)
    }
    if !self.proposer.isEmpty {
      try visitor.visitSingularStringField(value: self.proposer, fieldNumber: 3)
    }
    if !self.numTxs.isEmpty {
      try visitor.visitSingularStringField(value: self.numTxs, fieldNumber: 4)
    }
    if !self.numInvalidTxs.isEmpty {
      try visitor.visitSingularStringField(value: self.numInvalidTxs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedBlock, rhs: Ocap_IndexedBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.time != rhs.time {return false}
    if lhs.proposer != rhs.proposer {return false}
    if lhs.numTxs != rhs.numTxs {return false}
    if lhs.numInvalidTxs != rhs.numInvalidTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedTokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedTokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "symbol"),
    4: .same(proto: "unit"),
    5: .same(proto: "decimal"),
    6: .same(proto: "issuer"),
    7: .same(proto: "icon"),
    8: .standard(proto: "total_supply"),
    9: .same(proto: "address"),
    10: .standard(proto: "genesis_time"),
    11: .standard(proto: "renaissance_time"),
    13: .standard(proto: "foreign_token"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _symbol: String = String()
    var _unit: String = String()
    var _decimal: Int32 = 0
    var _issuer: String = String()
    var _icon: String = String()
    var _totalSupply: String = String()
    var _address: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _foreignToken: Ocap_ForeignToken? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _symbol = source._symbol
      _unit = source._unit
      _decimal = source._decimal
      _issuer = source._issuer
      _icon = source._icon
      _totalSupply = source._totalSupply
      _address = source._address
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _foreignToken = source._foreignToken
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._symbol) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._unit) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._decimal) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._issuer) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._icon) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._totalSupply) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._genesisTime) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._renaissanceTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._foreignToken) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 3)
      }
      if !_storage._unit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unit, fieldNumber: 4)
      }
      if _storage._decimal != 0 {
        try visitor.visitSingularInt32Field(value: _storage._decimal, fieldNumber: 5)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 6)
      }
      if !_storage._icon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._icon, fieldNumber: 7)
      }
      if !_storage._totalSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalSupply, fieldNumber: 8)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 9)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 10)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 11)
      }
      try { if let v = _storage._foreignToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedTokenState, rhs: Ocap_IndexedTokenState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        if _storage._unit != rhs_storage._unit {return false}
        if _storage._decimal != rhs_storage._decimal {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._icon != rhs_storage._icon {return false}
        if _storage._totalSupply != rhs_storage._totalSupply {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._foreignToken != rhs_storage._foreignToken {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "settlement"),
    6: .same(proto: "limit"),
    7: .standard(proto: "trusted_issuers"),
    8: .same(proto: "input"),
    9: .same(proto: "output"),
    10: .same(proto: "hooks"),
    11: .same(proto: "data"),
    13: .same(proto: "balance"),
    14: .same(proto: "tokens"),
    15: .standard(proto: "num_minted"),
    16: .standard(proto: "last_settlement"),
    17: .standard(proto: "genesis_time"),
    18: .standard(proto: "renaissance_time"),
    19: .same(proto: "display"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _settlement: String = String()
    var _limit: String = String()
    var _trustedIssuers: [String] = []
    var _input: Ocap_IndexedFactoryInput? = nil
    var _output: Ocap_CreateAssetTx? = nil
    var _hooks: [Ocap_AssetFactoryHook] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _balance: String = String()
    var _tokens: [Ocap_TokenInfo] = []
    var _numMinted: UInt32 = 0
    var _lastSettlement: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _display: Ocap_NFTDisplay? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _name = source._name
      _description_p = source._description_p
      _settlement = source._settlement
      _limit = source._limit
      _trustedIssuers = source._trustedIssuers
      _input = source._input
      _output = source._output
      _hooks = source._hooks
      _data = source._data
      _balance = source._balance
      _tokens = source._tokens
      _numMinted = source._numMinted
      _lastSettlement = source._lastSettlement
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _display = source._display
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._owner) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._settlement) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._limit) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._trustedIssuers) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._output) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._hooks) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._balance) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokens) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._numMinted) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._lastSettlement) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._genesisTime) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._renaissanceTime) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._display) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if !_storage._settlement.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlement, fieldNumber: 5)
      }
      if !_storage._limit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._limit, fieldNumber: 6)
      }
      if !_storage._trustedIssuers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._trustedIssuers, fieldNumber: 7)
      }
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._output {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._hooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hooks, fieldNumber: 10)
      }
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._balance.isEmpty {
        try visitor.visitSingularStringField(value: _storage._balance, fieldNumber: 13)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 14)
      }
      if _storage._numMinted != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numMinted, fieldNumber: 15)
      }
      if !_storage._lastSettlement.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastSettlement, fieldNumber: 16)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 17)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 18)
      }
      try { if let v = _storage._display {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedFactoryState, rhs: Ocap_IndexedFactoryState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._settlement != rhs_storage._settlement {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._trustedIssuers != rhs_storage._trustedIssuers {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._hooks != rhs_storage._hooks {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._numMinted != rhs_storage._numMinted {return false}
        if _storage._lastSettlement != rhs_storage._lastSettlement {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._display != rhs_storage._display {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedStakeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedStakeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .same(proto: "tokens"),
    5: .same(proto: "assets"),
    6: .same(proto: "revocable"),
    7: .standard(proto: "genesis_time"),
    8: .standard(proto: "renaissance_time"),
    9: .same(proto: "message"),
    10: .standard(proto: "revoke_waiting_period"),
    11: .standard(proto: "revoked_tokens"),
    12: .standard(proto: "revoked_assets"),
    13: .same(proto: "slashers"),
    50: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.revocable) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.genesisTime) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.renaissanceTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.revokeWaitingPeriod) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.revokedTokens) }()
      case 12: try { try decoder.decodeRepeatedStringField(value: &self.revokedAssets) }()
      case 13: try { try decoder.decodeRepeatedStringField(value: &self.slashers) }()
      case 50: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 3)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 4)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 5)
    }
    if self.revocable != false {
      try visitor.visitSingularBoolField(value: self.revocable, fieldNumber: 6)
    }
    if !self.genesisTime.isEmpty {
      try visitor.visitSingularStringField(value: self.genesisTime, fieldNumber: 7)
    }
    if !self.renaissanceTime.isEmpty {
      try visitor.visitSingularStringField(value: self.renaissanceTime, fieldNumber: 8)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 9)
    }
    if self.revokeWaitingPeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.revokeWaitingPeriod, fieldNumber: 10)
    }
    if !self.revokedTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.revokedTokens, fieldNumber: 11)
    }
    if !self.revokedAssets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.revokedAssets, fieldNumber: 12)
    }
    if !self.slashers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.slashers, fieldNumber: 13)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedStakeState, rhs: Ocap_IndexedStakeState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.revocable != rhs.revocable {return false}
    if lhs.genesisTime != rhs.genesisTime {return false}
    if lhs.renaissanceTime != rhs.renaissanceTime {return false}
    if lhs.message != rhs.message {return false}
    if lhs.revokeWaitingPeriod != rhs.revokeWaitingPeriod {return false}
    if lhs.revokedTokens != rhs.revokedTokens {return false}
    if lhs.revokedAssets != rhs.revokedAssets {return false}
    if lhs.slashers != rhs.slashers {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedRollupState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedRollupState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "token_address"),
    3: .standard(proto: "vault_address"),
    4: .standard(proto: "contract_address"),
    5: .standard(proto: "seed_validators"),
    6: .same(proto: "validators"),
    7: .standard(proto: "min_stake_amount"),
    8: .standard(proto: "max_stake_amount"),
    9: .standard(proto: "min_signer_count"),
    10: .standard(proto: "max_signer_count"),
    11: .standard(proto: "min_block_size"),
    12: .standard(proto: "max_block_size"),
    13: .standard(proto: "min_block_interval"),
    16: .standard(proto: "genesis_time"),
    17: .standard(proto: "renaissance_time"),
    18: .standard(proto: "token_info"),
    19: .same(proto: "issuer"),
    20: .standard(proto: "deposit_fee_rate"),
    21: .standard(proto: "withdraw_fee_rate"),
    22: .standard(proto: "proposer_fee_share"),
    23: .standard(proto: "min_deposit_amount"),
    24: .standard(proto: "min_withdraw_amount"),
    25: .standard(proto: "block_height"),
    26: .standard(proto: "block_hash"),
    27: .standard(proto: "min_block_confirmation"),
    28: .standard(proto: "total_deposit_amount"),
    29: .standard(proto: "total_withdraw_amount"),
    30: .standard(proto: "max_deposit_amount"),
    31: .standard(proto: "max_withdraw_amount"),
    32: .standard(proto: "min_deposit_fee"),
    33: .standard(proto: "max_deposit_fee"),
    34: .standard(proto: "min_withdraw_fee"),
    35: .standard(proto: "max_withdraw_fee"),
    36: .same(proto: "paused"),
    37: .standard(proto: "foreign_token"),
    38: .standard(proto: "leave_waiting_period"),
    39: .standard(proto: "publisher_fee_share"),
    40: .standard(proto: "publish_waiting_period"),
    41: .standard(proto: "publish_slash_rate"),
    42: .standard(proto: "migrate_history"),
    43: .same(proto: "closed"),
    44: .standard(proto: "vault_history"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _tokenAddress: String = String()
    var _vaultAddress: String = String()
    var _contractAddress: String = String()
    var _seedValidators: [Ocap_RollupValidator] = []
    var _validators: [Ocap_RollupValidator] = []
    var _minStakeAmount: String = String()
    var _maxStakeAmount: String = String()
    var _minSignerCount: UInt32 = 0
    var _maxSignerCount: UInt32 = 0
    var _minBlockSize: UInt32 = 0
    var _maxBlockSize: UInt32 = 0
    var _minBlockInterval: UInt32 = 0
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _tokenInfo: Ocap_IndexedTokenInput? = nil
    var _issuer: String = String()
    var _depositFeeRate: UInt32 = 0
    var _withdrawFeeRate: UInt32 = 0
    var _proposerFeeShare: UInt32 = 0
    var _minDepositAmount: String = String()
    var _minWithdrawAmount: String = String()
    var _blockHeight: UInt64 = 0
    var _blockHash: String = String()
    var _minBlockConfirmation: UInt32 = 0
    var _totalDepositAmount: String = String()
    var _totalWithdrawAmount: String = String()
    var _maxDepositAmount: String = String()
    var _maxWithdrawAmount: String = String()
    var _minDepositFee: String = String()
    var _maxDepositFee: String = String()
    var _minWithdrawFee: String = String()
    var _maxWithdrawFee: String = String()
    var _paused: Bool = false
    var _foreignToken: Ocap_ForeignToken? = nil
    var _leaveWaitingPeriod: UInt32 = 0
    var _publisherFeeShare: UInt32 = 0
    var _publishWaitingPeriod: UInt32 = 0
    var _publishSlashRate: UInt32 = 0
    var _migrateHistory: [String] = []
    var _closed: Bool = false
    var _vaultHistory: [String] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _tokenAddress = source._tokenAddress
      _vaultAddress = source._vaultAddress
      _contractAddress = source._contractAddress
      _seedValidators = source._seedValidators
      _validators = source._validators
      _minStakeAmount = source._minStakeAmount
      _maxStakeAmount = source._maxStakeAmount
      _minSignerCount = source._minSignerCount
      _maxSignerCount = source._maxSignerCount
      _minBlockSize = source._minBlockSize
      _maxBlockSize = source._maxBlockSize
      _minBlockInterval = source._minBlockInterval
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _tokenInfo = source._tokenInfo
      _issuer = source._issuer
      _depositFeeRate = source._depositFeeRate
      _withdrawFeeRate = source._withdrawFeeRate
      _proposerFeeShare = source._proposerFeeShare
      _minDepositAmount = source._minDepositAmount
      _minWithdrawAmount = source._minWithdrawAmount
      _blockHeight = source._blockHeight
      _blockHash = source._blockHash
      _minBlockConfirmation = source._minBlockConfirmation
      _totalDepositAmount = source._totalDepositAmount
      _totalWithdrawAmount = source._totalWithdrawAmount
      _maxDepositAmount = source._maxDepositAmount
      _maxWithdrawAmount = source._maxWithdrawAmount
      _minDepositFee = source._minDepositFee
      _maxDepositFee = source._maxDepositFee
      _minWithdrawFee = source._minWithdrawFee
      _maxWithdrawFee = source._maxWithdrawFee
      _paused = source._paused
      _foreignToken = source._foreignToken
      _leaveWaitingPeriod = source._leaveWaitingPeriod
      _publisherFeeShare = source._publisherFeeShare
      _publishWaitingPeriod = source._publishWaitingPeriod
      _publishSlashRate = source._publishSlashRate
      _migrateHistory = source._migrateHistory
      _closed = source._closed
      _vaultHistory = source._vaultHistory
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._tokenAddress) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._vaultAddress) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._contractAddress) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._seedValidators) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._validators) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._minStakeAmount) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._maxStakeAmount) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._minSignerCount) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxSignerCount) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._minBlockSize) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxBlockSize) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._minBlockInterval) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._genesisTime) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._renaissanceTime) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._tokenInfo) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._issuer) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._depositFeeRate) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._withdrawFeeRate) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._proposerFeeShare) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._minDepositAmount) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._minWithdrawAmount) }()
        case 25: try { try decoder.decodeSingularUInt64Field(value: &_storage._blockHeight) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._blockHash) }()
        case 27: try { try decoder.decodeSingularUInt32Field(value: &_storage._minBlockConfirmation) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._totalDepositAmount) }()
        case 29: try { try decoder.decodeSingularStringField(value: &_storage._totalWithdrawAmount) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._maxDepositAmount) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._maxWithdrawAmount) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._minDepositFee) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._maxDepositFee) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._minWithdrawFee) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._maxWithdrawFee) }()
        case 36: try { try decoder.decodeSingularBoolField(value: &_storage._paused) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._foreignToken) }()
        case 38: try { try decoder.decodeSingularUInt32Field(value: &_storage._leaveWaitingPeriod) }()
        case 39: try { try decoder.decodeSingularUInt32Field(value: &_storage._publisherFeeShare) }()
        case 40: try { try decoder.decodeSingularUInt32Field(value: &_storage._publishWaitingPeriod) }()
        case 41: try { try decoder.decodeSingularUInt32Field(value: &_storage._publishSlashRate) }()
        case 42: try { try decoder.decodeRepeatedStringField(value: &_storage._migrateHistory) }()
        case 43: try { try decoder.decodeSingularBoolField(value: &_storage._closed) }()
        case 44: try { try decoder.decodeRepeatedStringField(value: &_storage._vaultHistory) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._tokenAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tokenAddress, fieldNumber: 2)
      }
      if !_storage._vaultAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vaultAddress, fieldNumber: 3)
      }
      if !_storage._contractAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contractAddress, fieldNumber: 4)
      }
      if !_storage._seedValidators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._seedValidators, fieldNumber: 5)
      }
      if !_storage._validators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._validators, fieldNumber: 6)
      }
      if !_storage._minStakeAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minStakeAmount, fieldNumber: 7)
      }
      if !_storage._maxStakeAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxStakeAmount, fieldNumber: 8)
      }
      if _storage._minSignerCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minSignerCount, fieldNumber: 9)
      }
      if _storage._maxSignerCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxSignerCount, fieldNumber: 10)
      }
      if _storage._minBlockSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minBlockSize, fieldNumber: 11)
      }
      if _storage._maxBlockSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxBlockSize, fieldNumber: 12)
      }
      if _storage._minBlockInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minBlockInterval, fieldNumber: 13)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 16)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 17)
      }
      try { if let v = _storage._tokenInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 19)
      }
      if _storage._depositFeeRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._depositFeeRate, fieldNumber: 20)
      }
      if _storage._withdrawFeeRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._withdrawFeeRate, fieldNumber: 21)
      }
      if _storage._proposerFeeShare != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._proposerFeeShare, fieldNumber: 22)
      }
      if !_storage._minDepositAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minDepositAmount, fieldNumber: 23)
      }
      if !_storage._minWithdrawAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minWithdrawAmount, fieldNumber: 24)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._blockHeight, fieldNumber: 25)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockHash, fieldNumber: 26)
      }
      if _storage._minBlockConfirmation != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minBlockConfirmation, fieldNumber: 27)
      }
      if !_storage._totalDepositAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalDepositAmount, fieldNumber: 28)
      }
      if !_storage._totalWithdrawAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalWithdrawAmount, fieldNumber: 29)
      }
      if !_storage._maxDepositAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxDepositAmount, fieldNumber: 30)
      }
      if !_storage._maxWithdrawAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxWithdrawAmount, fieldNumber: 31)
      }
      if !_storage._minDepositFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minDepositFee, fieldNumber: 32)
      }
      if !_storage._maxDepositFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxDepositFee, fieldNumber: 33)
      }
      if !_storage._minWithdrawFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minWithdrawFee, fieldNumber: 34)
      }
      if !_storage._maxWithdrawFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxWithdrawFee, fieldNumber: 35)
      }
      if _storage._paused != false {
        try visitor.visitSingularBoolField(value: _storage._paused, fieldNumber: 36)
      }
      try { if let v = _storage._foreignToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      } }()
      if _storage._leaveWaitingPeriod != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._leaveWaitingPeriod, fieldNumber: 38)
      }
      if _storage._publisherFeeShare != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._publisherFeeShare, fieldNumber: 39)
      }
      if _storage._publishWaitingPeriod != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._publishWaitingPeriod, fieldNumber: 40)
      }
      if _storage._publishSlashRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._publishSlashRate, fieldNumber: 41)
      }
      if !_storage._migrateHistory.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migrateHistory, fieldNumber: 42)
      }
      if _storage._closed != false {
        try visitor.visitSingularBoolField(value: _storage._closed, fieldNumber: 43)
      }
      if !_storage._vaultHistory.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._vaultHistory, fieldNumber: 44)
      }
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedRollupState, rhs: Ocap_IndexedRollupState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._tokenAddress != rhs_storage._tokenAddress {return false}
        if _storage._vaultAddress != rhs_storage._vaultAddress {return false}
        if _storage._contractAddress != rhs_storage._contractAddress {return false}
        if _storage._seedValidators != rhs_storage._seedValidators {return false}
        if _storage._validators != rhs_storage._validators {return false}
        if _storage._minStakeAmount != rhs_storage._minStakeAmount {return false}
        if _storage._maxStakeAmount != rhs_storage._maxStakeAmount {return false}
        if _storage._minSignerCount != rhs_storage._minSignerCount {return false}
        if _storage._maxSignerCount != rhs_storage._maxSignerCount {return false}
        if _storage._minBlockSize != rhs_storage._minBlockSize {return false}
        if _storage._maxBlockSize != rhs_storage._maxBlockSize {return false}
        if _storage._minBlockInterval != rhs_storage._minBlockInterval {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._tokenInfo != rhs_storage._tokenInfo {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._depositFeeRate != rhs_storage._depositFeeRate {return false}
        if _storage._withdrawFeeRate != rhs_storage._withdrawFeeRate {return false}
        if _storage._proposerFeeShare != rhs_storage._proposerFeeShare {return false}
        if _storage._minDepositAmount != rhs_storage._minDepositAmount {return false}
        if _storage._minWithdrawAmount != rhs_storage._minWithdrawAmount {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._minBlockConfirmation != rhs_storage._minBlockConfirmation {return false}
        if _storage._totalDepositAmount != rhs_storage._totalDepositAmount {return false}
        if _storage._totalWithdrawAmount != rhs_storage._totalWithdrawAmount {return false}
        if _storage._maxDepositAmount != rhs_storage._maxDepositAmount {return false}
        if _storage._maxWithdrawAmount != rhs_storage._maxWithdrawAmount {return false}
        if _storage._minDepositFee != rhs_storage._minDepositFee {return false}
        if _storage._maxDepositFee != rhs_storage._maxDepositFee {return false}
        if _storage._minWithdrawFee != rhs_storage._minWithdrawFee {return false}
        if _storage._maxWithdrawFee != rhs_storage._maxWithdrawFee {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._foreignToken != rhs_storage._foreignToken {return false}
        if _storage._leaveWaitingPeriod != rhs_storage._leaveWaitingPeriod {return false}
        if _storage._publisherFeeShare != rhs_storage._publisherFeeShare {return false}
        if _storage._publishWaitingPeriod != rhs_storage._publishWaitingPeriod {return false}
        if _storage._publishSlashRate != rhs_storage._publishSlashRate {return false}
        if _storage._migrateHistory != rhs_storage._migrateHistory {return false}
        if _storage._closed != rhs_storage._closed {return false}
        if _storage._vaultHistory != rhs_storage._vaultHistory {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedRollupBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedRollupBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .standard(proto: "merkle_root"),
    4: .standard(proto: "previous_hash"),
    5: .standard(proto: "txs_hash"),
    6: .same(proto: "txs"),
    7: .same(proto: "proposer"),
    8: .same(proto: "signatures"),
    10: .standard(proto: "genesis_time"),
    11: .standard(proto: "renaissance_time"),
    12: .same(proto: "rollup"),
    13: .standard(proto: "minted_amount"),
    14: .standard(proto: "burned_amount"),
    15: .standard(proto: "reward_amount"),
    16: .same(proto: "governance"),
    18: .standard(proto: "token_info"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _height: UInt64 = 0
    var _merkleRoot: String = String()
    var _previousHash: String = String()
    var _txsHash: String = String()
    var _txs: [String] = []
    var _proposer: String = String()
    var _signatures: [Ocap_Multisig] = []
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _rollup: String = String()
    var _mintedAmount: String = String()
    var _burnedAmount: String = String()
    var _rewardAmount: String = String()
    var _governance: Bool = false
    var _tokenInfo: Ocap_IndexedTokenInput? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _height = source._height
      _merkleRoot = source._merkleRoot
      _previousHash = source._previousHash
      _txsHash = source._txsHash
      _txs = source._txs
      _proposer = source._proposer
      _signatures = source._signatures
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _rollup = source._rollup
      _mintedAmount = source._mintedAmount
      _burnedAmount = source._burnedAmount
      _rewardAmount = source._rewardAmount
      _governance = source._governance
      _tokenInfo = source._tokenInfo
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._hash) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._height) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._merkleRoot) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._previousHash) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._txsHash) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._txs) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._proposer) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._signatures) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._genesisTime) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._renaissanceTime) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._rollup) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._mintedAmount) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._burnedAmount) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._rewardAmount) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._governance) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._tokenInfo) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 2)
      }
      if !_storage._merkleRoot.isEmpty {
        try visitor.visitSingularStringField(value: _storage._merkleRoot, fieldNumber: 3)
      }
      if !_storage._previousHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._previousHash, fieldNumber: 4)
      }
      if !_storage._txsHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._txsHash, fieldNumber: 5)
      }
      if !_storage._txs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._txs, fieldNumber: 6)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proposer, fieldNumber: 7)
      }
      if !_storage._signatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signatures, fieldNumber: 8)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 10)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 11)
      }
      if !_storage._rollup.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rollup, fieldNumber: 12)
      }
      if !_storage._mintedAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mintedAmount, fieldNumber: 13)
      }
      if !_storage._burnedAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._burnedAmount, fieldNumber: 14)
      }
      if !_storage._rewardAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rewardAmount, fieldNumber: 15)
      }
      if _storage._governance != false {
        try visitor.visitSingularBoolField(value: _storage._governance, fieldNumber: 16)
      }
      try { if let v = _storage._tokenInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedRollupBlock, rhs: Ocap_IndexedRollupBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._merkleRoot != rhs_storage._merkleRoot {return false}
        if _storage._previousHash != rhs_storage._previousHash {return false}
        if _storage._txsHash != rhs_storage._txsHash {return false}
        if _storage._txs != rhs_storage._txs {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._signatures != rhs_storage._signatures {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._rollup != rhs_storage._rollup {return false}
        if _storage._mintedAmount != rhs_storage._mintedAmount {return false}
        if _storage._burnedAmount != rhs_storage._burnedAmount {return false}
        if _storage._rewardAmount != rhs_storage._rewardAmount {return false}
        if _storage._governance != rhs_storage._governance {return false}
        if _storage._tokenInfo != rhs_storage._tokenInfo {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_SearchResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_SearchResult, rhs: Ocap_SearchResult) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedRollupValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedRollupValidator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pk"),
    2: .same(proto: "address"),
    3: .same(proto: "moniker"),
    4: .same(proto: "endpoint"),
    5: .standard(proto: "join_time"),
    6: .standard(proto: "leave_time"),
    7: .standard(proto: "genesis_time"),
    8: .standard(proto: "renaissance_time"),
    9: .standard(proto: "total_stake"),
    10: .standard(proto: "revoked_stake"),
    11: .standard(proto: "available_stake"),
    12: .standard(proto: "total_gain"),
    13: .standard(proto: "proposed_block_count"),
    14: .standard(proto: "verified_block_count"),
    15: .standard(proto: "latest_block_height"),
    16: .standard(proto: "latest_block_hash"),
    17: .same(proto: "rollup"),
  ]

  fileprivate class _StorageClass {
    var _pk: String = String()
    var _address: String = String()
    var _moniker: String = String()
    var _endpoint: String = String()
    var _joinTime: String = String()
    var _leaveTime: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _totalStake: String = String()
    var _revokedStake: String = String()
    var _availableStake: String = String()
    var _totalGain: String = String()
    var _proposedBlockCount: UInt64 = 0
    var _verifiedBlockCount: UInt64 = 0
    var _latestBlockHeight: UInt64 = 0
    var _latestBlockHash: String = String()
    var _rollup: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pk = source._pk
      _address = source._address
      _moniker = source._moniker
      _endpoint = source._endpoint
      _joinTime = source._joinTime
      _leaveTime = source._leaveTime
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _totalStake = source._totalStake
      _revokedStake = source._revokedStake
      _availableStake = source._availableStake
      _totalGain = source._totalGain
      _proposedBlockCount = source._proposedBlockCount
      _verifiedBlockCount = source._verifiedBlockCount
      _latestBlockHeight = source._latestBlockHeight
      _latestBlockHash = source._latestBlockHash
      _rollup = source._rollup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._pk) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._moniker) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._endpoint) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._joinTime) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._leaveTime) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._genesisTime) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._renaissanceTime) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._totalStake) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._revokedStake) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._availableStake) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._totalGain) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._proposedBlockCount) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._verifiedBlockCount) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._latestBlockHeight) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._latestBlockHash) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._rollup) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._pk.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pk, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 3)
      }
      if !_storage._endpoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._endpoint, fieldNumber: 4)
      }
      if !_storage._joinTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._joinTime, fieldNumber: 5)
      }
      if !_storage._leaveTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._leaveTime, fieldNumber: 6)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 7)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 8)
      }
      if !_storage._totalStake.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalStake, fieldNumber: 9)
      }
      if !_storage._revokedStake.isEmpty {
        try visitor.visitSingularStringField(value: _storage._revokedStake, fieldNumber: 10)
      }
      if !_storage._availableStake.isEmpty {
        try visitor.visitSingularStringField(value: _storage._availableStake, fieldNumber: 11)
      }
      if !_storage._totalGain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalGain, fieldNumber: 12)
      }
      if _storage._proposedBlockCount != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._proposedBlockCount, fieldNumber: 13)
      }
      if _storage._verifiedBlockCount != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._verifiedBlockCount, fieldNumber: 14)
      }
      if _storage._latestBlockHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._latestBlockHeight, fieldNumber: 15)
      }
      if !_storage._latestBlockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._latestBlockHash, fieldNumber: 16)
      }
      if !_storage._rollup.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rollup, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedRollupValidator, rhs: Ocap_IndexedRollupValidator) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._endpoint != rhs_storage._endpoint {return false}
        if _storage._joinTime != rhs_storage._joinTime {return false}
        if _storage._leaveTime != rhs_storage._leaveTime {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._totalStake != rhs_storage._totalStake {return false}
        if _storage._revokedStake != rhs_storage._revokedStake {return false}
        if _storage._availableStake != rhs_storage._availableStake {return false}
        if _storage._totalGain != rhs_storage._totalGain {return false}
        if _storage._proposedBlockCount != rhs_storage._proposedBlockCount {return false}
        if _storage._verifiedBlockCount != rhs_storage._verifiedBlockCount {return false}
        if _storage._latestBlockHeight != rhs_storage._latestBlockHeight {return false}
        if _storage._latestBlockHash != rhs_storage._latestBlockHash {return false}
        if _storage._rollup != rhs_storage._rollup {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedDelegationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedDelegationState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .standard(proto: "genesis_time"),
    5: .standard(proto: "renaissance_time"),
    6: .same(proto: "ops"),
    7: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.genesisTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.renaissanceTime) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_DelegateOpState>.self, value: &self.ops) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 2)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 3)
    }
    if !self.genesisTime.isEmpty {
      try visitor.visitSingularStringField(value: self.genesisTime, fieldNumber: 4)
    }
    if !self.renaissanceTime.isEmpty {
      try visitor.visitSingularStringField(value: self.renaissanceTime, fieldNumber: 5)
    }
    if !self.ops.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_DelegateOpState>.self, value: self.ops, fieldNumber: 6)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedDelegationState, rhs: Ocap_IndexedDelegationState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.genesisTime != rhs.genesisTime {return false}
    if lhs.renaissanceTime != rhs.renaissanceTime {return false}
    if lhs.ops != rhs.ops {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
