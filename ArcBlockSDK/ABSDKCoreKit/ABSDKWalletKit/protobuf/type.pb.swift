// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: type.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Ocap_BigUint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_BigSint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = Data()

  public var minus: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TokenSymbol {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var symbol: String = String()

  public var decimal: Int32 = 0

  public var unit: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_WalletType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pk: Ocap_KeyType = .ed25519

  public var hash: Ocap_HashType = .keccak

  public var address: Ocap_EncodingType = .base16

  public var role: Ocap_RoleType = .roleAccount

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_WalletInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Ocap_WalletType {
    get {return _type ?? Ocap_WalletType()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var sk: Data = Data()

  public var pk: Data = Data()

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: Ocap_WalletType? = nil
}

public struct Ocap_ChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// node id.
  public var id: String = String()

  /// which network the node belongs to.
  public var network: String = String()

  /// name of the node.
  public var moniker: String = String()

  /// consensus engine version for this node.
  public var consensusVersion: String = String()

  /// indicate if this node is fully synced.
  public var synced: Bool = false

  /// current application hash.
  public var appHash: Data = Data()

  /// current block hash.
  public var blockHash: Data = Data()

  /// latest block height, in integer.
  public var blockHeight: String = String()

  /// latest block time.
  public var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  public var hasBlockTime: Bool {return self._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  public mutating func clearBlockTime() {self._blockTime = nil}

  /// the address of the node.
  public var address: String = String()

  /// the voting power of the node, in integer.
  public var votingPower: String = String()

  /// total number of txs up to the latest block
  public var totalTxs: String = String()

  /// current forge version
  public var version: String = String()

  ///  string data_version = 14;  current data version deprecated
  public var forgeAppsVersion: Dictionary<String,String> = [:]

  public var supportedTxs: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Ocap_NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// node id.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// which network the node belongs to.
  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  /// name of the node.
  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  /// consensus engine version for this node.
  public var consensusVersion: String {
    get {return _storage._consensusVersion}
    set {_uniqueStorage()._consensusVersion = newValue}
  }

  /// indicate if this node is fully synced.
  public var synced: Bool {
    get {return _storage._synced}
    set {_uniqueStorage()._synced = newValue}
  }

  /// current application hash.
  public var appHash: Data {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  /// current block hash.
  public var blockHash: Data {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  /// latest block height, in integer.
  public var blockHeight: String {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  /// latest block time.
  public var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  public var hasBlockTime: Bool {return _storage._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  public mutating func clearBlockTime() {_uniqueStorage()._blockTime = nil}

  /// the address of the node.
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// the voting power of the node, in integer.
  public var votingPower: String {
    get {return _storage._votingPower}
    set {_uniqueStorage()._votingPower = newValue}
  }

  /// total number of txs up to the latest block
  public var totalTxs: String {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  /// current forge version
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// string data_version = 14;  current data version deprecated
  public var forgeAppsVersion: Dictionary<String,String> {
    get {return _storage._forgeAppsVersion}
    set {_uniqueStorage()._forgeAppsVersion = newValue}
  }

  public var supportedTxs: [String] {
    get {return _storage._supportedTxs}
    set {_uniqueStorage()._supportedTxs = newValue}
  }

  /// self node ip
  public var ip: String {
    get {return _storage._ip}
    set {_uniqueStorage()._ip = newValue}
  }

  /// self node geo info
  public var geoInfo: Ocap_GeoInfo {
    get {return _storage._geoInfo ?? Ocap_GeoInfo()}
    set {_uniqueStorage()._geoInfo = newValue}
  }
  /// Returns true if `geoInfo` has been explicitly set.
  public var hasGeoInfo: Bool {return _storage._geoInfo != nil}
  /// Clears the value of `geoInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGeoInfo() {_uniqueStorage()._geoInfo = nil}

  /// id@ip:port
  public var p2PAddress: String {
    get {return _storage._p2PAddress}
    set {_uniqueStorage()._p2PAddress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  /// setting power to 0 will remove existing address from validator
  public var power: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ConsensusParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maxBytes: String = String()

  public var maxGas: String = String()

  /// we keep max_validators + max_candidates items in validator list, and only
  /// use max_validators items for the validators.
  public var maxValidators: UInt32 = 0

  public var maxCandidates: UInt32 = 0

  public var pubKeyTypes: [String] = []

  public var validators: [Ocap_Validator] = []

  public var validatorChanged: Bool = false

  public var paramChanged: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// a deferred task (need more consideration)
public struct Ocap_UpgradeTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Ocap_UpgradeType = .configApp

  /// data shall be first put into IPFS
  public var dataHash: String = String()

  /// actions
  public var actions: [Ocap_UpgradeAction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_UpgradeTasks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: [Ocap_UpgradeTask] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_Multisig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// signer address
  public var signer: String = String()

  /// public key for signer
  public var pk: Data = Data()

  /// signature
  public var signature: Data = Data()

  /// delegator
  public var delegator: String = String()

  /// extra data
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Ocap_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: String = String()

  /// Used for anti-replay
  public var nonce: UInt64 = 0

  /// use DID for the chain. "did:" prefix is omitted
  public var chainID: String = String()

  /// public key of the sender
  public var pk: Data = Data()

  /// gas required for this tx
  public var gas: UInt32 = 0

  /// delegator
  public var delegator: String = String()

  /// signature of the transaction
  /// tx.from 应该最后签名，并且把签名放在 tx.signature 上面，不论 tx.itx.inputs 是否为空
  public var signature: Data = Data()

  /// v1.11.0 版本的一些变化
  /// The order of tx.signatures does not matter since we encode messages using protobuf
  /// Any owner in tx.itx.inputs should sign the tx and put their signature in tx.signatures
  /// Any owner in tx.itx.inputs should sign the tx without tx.signature and tx.signatures[n].signature
  /// If tx.from exist in tx.itx.inputs as an asset owner, his signature must also exist
  public var signatures: [Ocap_Multisig] = []

  /// itx may contain the inputs property to indicate that this is an multiple input tx
  public var itx: SwiftProtobuf.Google_Protobuf_Any {
    get {return _itx ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_itx = newValue}
  }
  /// Returns true if `itx` has been explicitly set.
  public var hasItx: Bool {return self._itx != nil}
  /// Clears the value of `itx`. Subsequent reads from it will return its default value.
  public mutating func clearItx() {self._itx = nil}

  public var receipts: [Ocap_TransactionReceipt] = []

  /// service fee for this tx
  public var serviceFee: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _itx: SwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Ocap_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: Ocap_Transaction {
    get {return _storage._tx ?? Ocap_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  public var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  public mutating func clearTx() {_uniqueStorage()._tx = nil}

  public var height: String {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var tags: [Vendor_KVPair] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var receipts: [Ocap_TransactionReceipt] {
    get {return _storage._receipts}
    set {_uniqueStorage()._receipts = newValue}
  }

  /// added on v1.10.5 to indicate accounts with net asset gain/lose
  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  public var tokenSymbols: [Ocap_TokenSymbol] {
    get {return _storage._tokenSymbols}
    set {_uniqueStorage()._tokenSymbols = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_TransactionReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var changes: [Ocap_ReceiptChange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ReceiptChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var target: String = String()

  public var action: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// How do we define tx.itx.inputs
public struct Ocap_TokenInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TransactionInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var owner: String = String()

  public var tokens: [Ocap_TokenInput] = []

  public var assets: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_VariableInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var description_p: String = String()

  public var required: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_DelegateConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the interval used for calculate the num_txs_delta / num_tokens_delta
  public var deltaInterval: UInt32 = 0

  /// a list of type_urls that are allowed for delegation
  public var typeUrls: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_VaultConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var slashedStake: String = String()

  public var txFee: String = String()

  public var txGas: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TxFeeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typeURL: String = String()

  public var fee: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TxGasConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var price: UInt64 = 0

  public var createState: UInt64 = 0

  public var updateState: UInt64 = 0

  public var dataStorage: UInt64 = 0

  public var minStake: String = String()

  public var maxStake: String = String()

  public var stakeLockPeriod: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TransactionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maxAssetSize: UInt32 = 0

  public var maxListSize: UInt32 = 0

  public var maxMultisig: UInt32 = 0

  public var delegate: Ocap_DelegateConfig {
    get {return _delegate ?? Ocap_DelegateConfig()}
    set {_delegate = newValue}
  }
  /// Returns true if `delegate` has been explicitly set.
  public var hasDelegate: Bool {return self._delegate != nil}
  /// Clears the value of `delegate`. Subsequent reads from it will return its default value.
  public mutating func clearDelegate() {self._delegate = nil}

  public var txFee: [Ocap_TxFeeConfig] = []

  public var txGas: Ocap_TxGasConfig {
    get {return _txGas ?? Ocap_TxGasConfig()}
    set {_txGas = newValue}
  }
  /// Returns true if `txGas` has been explicitly set.
  public var hasTxGas: Bool {return self._txGas != nil}
  /// Clears the value of `txGas`. Subsequent reads from it will return its default value.
  public mutating func clearTxGas() {self._txGas = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _delegate: Ocap_DelegateConfig? = nil
  fileprivate var _txGas: Ocap_TxGasConfig? = nil
}

public struct Ocap_BlockInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: String {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var numTxs: UInt32 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var appHash: Data {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  public var proposer: Data {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  public var txs: [Ocap_TransactionInfo] {
    get {return _storage._txs}
    set {_uniqueStorage()._txs = newValue}
  }

  public var totalTxs: String {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  public var invalidTxs: [Ocap_TransactionInfo] {
    get {return _storage._invalidTxs}
    set {_uniqueStorage()._invalidTxs = newValue}
  }

  public var txsHashes: [String] {
    get {return _storage._txsHashes}
    set {_uniqueStorage()._txsHashes = newValue}
  }

  public var invalidTxsHashes: [String] {
    get {return _storage._invalidTxsHashes}
    set {_uniqueStorage()._invalidTxsHashes = newValue}
  }

  public var consensusHash: Data {
    get {return _storage._consensusHash}
    set {_uniqueStorage()._consensusHash = newValue}
  }

  public var dataHash: Data {
    get {return _storage._dataHash}
    set {_uniqueStorage()._dataHash = newValue}
  }

  public var evidenceHash: Data {
    get {return _storage._evidenceHash}
    set {_uniqueStorage()._evidenceHash = newValue}
  }

  public var lastCommitHash: Data {
    get {return _storage._lastCommitHash}
    set {_uniqueStorage()._lastCommitHash = newValue}
  }

  public var lastResultsHash: Data {
    get {return _storage._lastResultsHash}
    set {_uniqueStorage()._lastResultsHash = newValue}
  }

  public var nextValidatorsHash: Data {
    get {return _storage._nextValidatorsHash}
    set {_uniqueStorage()._nextValidatorsHash = newValue}
  }

  public var validatorsHash: Data {
    get {return _storage._validatorsHash}
    set {_uniqueStorage()._validatorsHash = newValue}
  }

  public var version: Vendor_Version {
    get {return _storage._version ?? Vendor_Version()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {_uniqueStorage()._version = nil}

  public var lastBlockID: Vendor_BlockID {
    get {return _storage._lastBlockID ?? Vendor_BlockID()}
    set {_uniqueStorage()._lastBlockID = newValue}
  }
  /// Returns true if `lastBlockID` has been explicitly set.
  public var hasLastBlockID: Bool {return _storage._lastBlockID != nil}
  /// Clears the value of `lastBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearLastBlockID() {_uniqueStorage()._lastBlockID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_BlockInfoSimple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: String {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var numTxs: UInt32 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var appHash: Data {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  public var proposer: Data {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  public var totalTxs: String {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  public var txsHashes: [String] {
    get {return _storage._txsHashes}
    set {_uniqueStorage()._txsHashes = newValue}
  }

  public var invalidTxsHashes: [String] {
    get {return _storage._invalidTxsHashes}
    set {_uniqueStorage()._invalidTxsHashes = newValue}
  }

  public var consensusHash: Data {
    get {return _storage._consensusHash}
    set {_uniqueStorage()._consensusHash = newValue}
  }

  public var dataHash: Data {
    get {return _storage._dataHash}
    set {_uniqueStorage()._dataHash = newValue}
  }

  public var evidenceHash: Data {
    get {return _storage._evidenceHash}
    set {_uniqueStorage()._evidenceHash = newValue}
  }

  public var lastCommitHash: Data {
    get {return _storage._lastCommitHash}
    set {_uniqueStorage()._lastCommitHash = newValue}
  }

  public var lastResultsHash: Data {
    get {return _storage._lastResultsHash}
    set {_uniqueStorage()._lastResultsHash = newValue}
  }

  public var nextValidatorsHash: Data {
    get {return _storage._nextValidatorsHash}
    set {_uniqueStorage()._nextValidatorsHash = newValue}
  }

  public var validatorsHash: Data {
    get {return _storage._validatorsHash}
    set {_uniqueStorage()._validatorsHash = newValue}
  }

  public var version: Vendor_Version {
    get {return _storage._version ?? Vendor_Version()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {_uniqueStorage()._version = nil}

  public var lastBlockID: Vendor_BlockID {
    get {return _storage._lastBlockID ?? Vendor_BlockID()}
    set {_uniqueStorage()._lastBlockID = newValue}
  }
  /// Returns true if `lastBlockID` has been explicitly set.
  public var hasLastBlockID: Bool {return _storage._lastBlockID != nil}
  /// Clears the value of `lastBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearLastBlockID() {_uniqueStorage()._lastBlockID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_StateContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var genesisTx: String = String()

  public var renaissanceTx: String = String()

  public var genesisTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _genesisTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_genesisTime = newValue}
  }
  /// Returns true if `genesisTime` has been explicitly set.
  public var hasGenesisTime: Bool {return self._genesisTime != nil}
  /// Clears the value of `genesisTime`. Subsequent reads from it will return its default value.
  public mutating func clearGenesisTime() {self._genesisTime = nil}

  public var renaissanceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _renaissanceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_renaissanceTime = newValue}
  }
  /// Returns true if `renaissanceTime` has been explicitly set.
  public var hasRenaissanceTime: Bool {return self._renaissanceTime != nil}
  /// Clears the value of `renaissanceTime`. Subsequent reads from it will return its default value.
  public mutating func clearRenaissanceTime() {self._renaissanceTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _genesisTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _renaissanceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Ocap_StakeSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalStakes: Ocap_BigUint {
    get {return _totalStakes ?? Ocap_BigUint()}
    set {_totalStakes = newValue}
  }
  /// Returns true if `totalStakes` has been explicitly set.
  public var hasTotalStakes: Bool {return self._totalStakes != nil}
  /// Clears the value of `totalStakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalStakes() {self._totalStakes = nil}

  public var totalUnstakes: Ocap_BigUint {
    get {return _totalUnstakes ?? Ocap_BigUint()}
    set {_totalUnstakes = newValue}
  }
  /// Returns true if `totalUnstakes` has been explicitly set.
  public var hasTotalUnstakes: Bool {return self._totalUnstakes != nil}
  /// Clears the value of `totalUnstakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalUnstakes() {self._totalUnstakes = nil}

  public var context: Ocap_StateContext {
    get {return _context ?? Ocap_StateContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _totalStakes: Ocap_BigUint? = nil
  fileprivate var _totalUnstakes: Ocap_BigUint? = nil
  fileprivate var _context: Ocap_StateContext? = nil
}

public struct Ocap_UnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nTxs: UInt32 = 0

  public var txs: [Ocap_Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_NetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listening: Bool = false

  public var listeners: [String] = []

  public var nPeers: UInt32 = 0

  public var peers: [Ocap_PeerInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_GeoInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var city: String = String()

  public var country: String = String()

  public var latitude: Float = 0

  public var longitude: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_PeerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var network: String = String()

  public var consensusVersion: String = String()

  public var moniker: String = String()

  public var ip: String = String()

  public var geoInfo: Ocap_GeoInfo {
    get {return _geoInfo ?? Ocap_GeoInfo()}
    set {_geoInfo = newValue}
  }
  /// Returns true if `geoInfo` has been explicitly set.
  public var hasGeoInfo: Bool {return self._geoInfo != nil}
  /// Clears the value of `geoInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGeoInfo() {self._geoInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _geoInfo: Ocap_GeoInfo? = nil
}

public struct Ocap_ValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockHeight: String = String()

  public var validators: [Ocap_ValidatorInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ValidatorInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var pubKey: Vendor_PubKey {
    get {return _pubKey ?? Vendor_PubKey()}
    set {_pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  public var hasPubKey: Bool {return self._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  public mutating func clearPubKey() {self._pubKey = nil}

  public var votingPower: String = String()

  public var proposerPriority: String = String()

  public var name: String = String()

  /// validator geo info
  public var geoInfo: Ocap_GeoInfo {
    get {return _geoInfo ?? Ocap_GeoInfo()}
    set {_geoInfo = newValue}
  }
  /// Returns true if `geoInfo` has been explicitly set.
  public var hasGeoInfo: Bool {return self._geoInfo != nil}
  /// Clears the value of `geoInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGeoInfo() {self._geoInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pubKey: Vendor_PubKey? = nil
  fileprivate var _geoInfo: Ocap_GeoInfo? = nil
}

public struct Ocap_ForgeToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token name
  public var name: String = String()

  /// token symbol
  public var symbol: String = String()

  /// token smallest unit
  public var unit: String = String()

  /// token description
  public var description_p: String = String()

  /// token icon file in bytes
  public var icon: Data = Data()

  /// token decimal
  public var decimal: UInt32 = 0

  /// token initial supply amount
  public var initialSupply: String = String()

  /// token total supply amount
  public var totalSupply: String = String()

  /// token inflation rate in integer
  public var inflationRate: UInt32 = 0

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_UpgradeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: String = String()

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_WithdrawItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var value: Ocap_BigUint {
    get {return _value ?? Ocap_BigUint()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Ocap_BigUint? = nil
}

public struct Ocap_AccountConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var pk: Data = Data()

  public var balance: Ocap_BigUint {
    get {return _balance ?? Ocap_BigUint()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {self._balance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _balance: Ocap_BigUint? = nil
}

public struct Ocap_Evidence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tx hash from a foreign chain
  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// @link https://github.com/ArcBlock/blockchain/issues/112#issuecomment-814487646
public struct Ocap_NFTEndpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the url of the endpoint, must be a permanent url
  public var id: String = String()

  /// for private endpoints, client must request with owner signature
  public var scope: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_NFTDisplay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Can be svg|url|svg_gzipped|uri
  public var type: String = String()

  /// Varies according to the type
  /// For svg type, content should be the svg itsself
  /// For url type, content should be the url to fetch the display content
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_NFTIssuer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var pk: String = String()

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetFactoryHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be mint/postMint
  public var name: String = String()

  /// can be callback/contract
  public var type: String = String()

  public var hook: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_IndexedTokenInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var value: String = String()

  public var decimal: Int32 = 0

  public var unit: String = String()

  public var symbol: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 和 AssetFactoryInput 数据结构类似，可以参考其注释
public struct Ocap_IndexedFactoryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var tokens: [Ocap_IndexedTokenInput] = []

  public var assets: [String] = []

  public var variables: [Ocap_VariableInput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RollupValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pk: String = String()

  public var address: String = String()

  public var endpoint: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RollupSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var signer: String = String()

  public var signature: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ForeignToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be erc20, brc20, erc721
  public var type: String = String()

  public var contractAddress: String = String()

  /// can be ethereum, bsc, fantom, matic
  public var chainType: String = String()

  /// can be rinkeby, main, test
  public var chainName: String = String()

  /// can be 1, 4
  public var chainID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RevokedStake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokens: [Ocap_TokenInput] = []

  public var assets: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numBlocks: [String] {
    get {return _storage._numBlocks}
    set {_uniqueStorage()._numBlocks = newValue}
  }

  public var numTxs: [String] {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var numStakes: [Ocap_BigUint] {
    get {return _storage._numStakes}
    set {_uniqueStorage()._numStakes = newValue}
  }

  public var numValidators: [UInt32] {
    get {return _storage._numValidators}
    set {_uniqueStorage()._numValidators = newValue}
  }

  public var numAccountMigrateTxs: [String] {
    get {return _storage._numAccountMigrateTxs}
    set {_uniqueStorage()._numAccountMigrateTxs = newValue}
  }

  public var numCreateAssetTxs: [String] {
    get {return _storage._numCreateAssetTxs}
    set {_uniqueStorage()._numCreateAssetTxs = newValue}
  }

  public var numConsensusUpgradeTxs: [UInt32] {
    get {return _storage._numConsensusUpgradeTxs}
    set {_uniqueStorage()._numConsensusUpgradeTxs = newValue}
  }

  public var numDeclareTxs: [String] {
    get {return _storage._numDeclareTxs}
    set {_uniqueStorage()._numDeclareTxs = newValue}
  }

  public var numDeclareFileTxs: [String] {
    get {return _storage._numDeclareFileTxs}
    set {_uniqueStorage()._numDeclareFileTxs = newValue}
  }

  public var numExchangeTxs: [String] {
    get {return _storage._numExchangeTxs}
    set {_uniqueStorage()._numExchangeTxs = newValue}
  }

  public var numStakeTxs: [String] {
    get {return _storage._numStakeTxs}
    set {_uniqueStorage()._numStakeTxs = newValue}
  }

  public var numSysUpgradeTxs: [UInt32] {
    get {return _storage._numSysUpgradeTxs}
    set {_uniqueStorage()._numSysUpgradeTxs = newValue}
  }

  public var numTransferTxs: [String] {
    get {return _storage._numTransferTxs}
    set {_uniqueStorage()._numTransferTxs = newValue}
  }

  public var numUpdateAssetTxs: [String] {
    get {return _storage._numUpdateAssetTxs}
    set {_uniqueStorage()._numUpdateAssetTxs = newValue}
  }

  public var numConsumeAssetTxs: [String] {
    get {return _storage._numConsumeAssetTxs}
    set {_uniqueStorage()._numConsumeAssetTxs = newValue}
  }

  public var tps: [UInt32] {
    get {return _storage._tps}
    set {_uniqueStorage()._tps = newValue}
  }

  /// maximum tps in given time range
  public var maxTps: UInt32 {
    get {return _storage._maxTps}
    set {_uniqueStorage()._maxTps = newValue}
  }

  /// average tps in given time range
  public var avgTps: UInt32 {
    get {return _storage._avgTps}
    set {_uniqueStorage()._avgTps = newValue}
  }

  /// average blocks in given time range
  public var avgBlockTime: Float {
    get {return _storage._avgBlockTime}
    set {_uniqueStorage()._avgBlockTime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_GasEstimate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// max gas for this tx
  public var max: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RateLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// interval in seconds
  public var interval: UInt64 = 0

  /// when to start the rate limit, default to current timestamp, can be future or past
  public var anchor: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TokenLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// which token allowed to transfer
  public var address: String = String()

  /// which address allowed to transfer to, empty is unlimited
  public var to: [String] = []

  /// how many txs allowed to send, 0 is unlimited
  public var txCount: UInt32 = 0

  /// how much token allowed to transfer, 0 is unlimited
  public var txAllowance: String = String()

  /// how much token allowed to transfer, accumulated, 0 is unlimited
  public var totalAllowance: String = String()

  /// in seconds, empty for unlimited
  public var validUntil: UInt64 = 0

  /// limit frequency, empty for unlimited
  public var rate: Ocap_RateLimit {
    get {return _rate ?? Ocap_RateLimit()}
    set {_rate = newValue}
  }
  /// Returns true if `rate` has been explicitly set.
  public var hasRate: Bool {return self._rate != nil}
  /// Clears the value of `rate`. Subsequent reads from it will return its default value.
  public mutating func clearRate() {self._rate = nil}

  /// stats fields maintained by chain
  public var txSent: UInt32 = 0

  /// how much token allowed to transfer, 0 is unlimited
  public var spentAllowance: String = String()

  /// last tx time
  public var lastTx: UInt64 = 0

  /// fields used for display purpose
  public var decimal: UInt32 = 0

  public var symbol: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rate: Ocap_RateLimit? = nil
}

public struct Ocap_AssetLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// which asset allowed to transfer, empty is unlimited
  public var address: [String] = []

  /// which address allowed to transfer to, empty is unlimited
  public var to: [String] = []

  /// how many txs allowed to send, 0 is unlimited
  public var txCount: UInt32 = 0

  /// in seconds, empty for unlimited
  public var validUntil: UInt64 = 0

  /// limit frequency, empty for unlimited
  public var rate: Ocap_RateLimit {
    get {return _rate ?? Ocap_RateLimit()}
    set {_rate = newValue}
  }
  /// Returns true if `rate` has been explicitly set.
  public var hasRate: Bool {return self._rate != nil}
  /// Clears the value of `rate`. Subsequent reads from it will return its default value.
  public mutating func clearRate() {self._rate = nil}

  /// how much tx allowed to send, accumulated, 0 is unlimited
  public var txSent: UInt32 = 0

  /// last tx time
  public var lastTx: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rate: Ocap_RateLimit? = nil
}

public struct Ocap_DelegateLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokens: [Ocap_TokenLimit] = []

  public var assets: [Ocap_AssetLimit] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_BigUint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigUint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_BigUint, rhs: Ocap_BigUint) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_BigSint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigSint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "minus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.minus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    if self.minus != false {
      try visitor.visitSingularBoolField(value: self.minus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_BigSint, rhs: Ocap_BigSint) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.minus != rhs.minus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenSymbol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenSymbol"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "symbol"),
    3: .same(proto: "decimal"),
    4: .same(proto: "unit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.decimal) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.decimal != 0 {
      try visitor.visitSingularInt32Field(value: self.decimal, fieldNumber: 3)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenSymbol, rhs: Ocap_TokenSymbol) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.decimal != rhs.decimal {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_WalletType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalletType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pk"),
    2: .same(proto: "hash"),
    3: .same(proto: "address"),
    4: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.pk) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.hash) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pk != .ed25519 {
      try visitor.visitSingularEnumField(value: self.pk, fieldNumber: 1)
    }
    if self.hash != .keccak {
      try visitor.visitSingularEnumField(value: self.hash, fieldNumber: 2)
    }
    if self.address != .base16 {
      try visitor.visitSingularEnumField(value: self.address, fieldNumber: 3)
    }
    if self.role != .roleAccount {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_WalletType, rhs: Ocap_WalletType) -> Bool {
    if lhs.pk != rhs.pk {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.address != rhs.address {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_WalletInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalletInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "sk"),
    3: .same(proto: "pk"),
    4: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.sk) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pk) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sk.isEmpty {
      try visitor.visitSingularBytesField(value: self.sk, fieldNumber: 2)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pk, fieldNumber: 3)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_WalletInfo, rhs: Ocap_WalletInfo) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.sk != rhs.sk {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "network"),
    3: .same(proto: "moniker"),
    4: .standard(proto: "consensus_version"),
    5: .same(proto: "synced"),
    6: .standard(proto: "app_hash"),
    7: .standard(proto: "block_hash"),
    8: .standard(proto: "block_height"),
    9: .standard(proto: "block_time"),
    10: .same(proto: "address"),
    11: .standard(proto: "voting_power"),
    12: .standard(proto: "total_txs"),
    13: .same(proto: "version"),
    15: .standard(proto: "forge_apps_version"),
    16: .standard(proto: "supported_txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.moniker) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.consensusVersion) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.synced) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.appHash) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.blockHash) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.blockHeight) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._blockTime) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.votingPower) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.totalTxs) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.forgeAppsVersion) }()
      case 16: try { try decoder.decodeRepeatedStringField(value: &self.supportedTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 3)
    }
    if !self.consensusVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.consensusVersion, fieldNumber: 4)
    }
    if self.synced != false {
      try visitor.visitSingularBoolField(value: self.synced, fieldNumber: 5)
    }
    if !self.appHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.appHash, fieldNumber: 6)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 7)
    }
    if !self.blockHeight.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHeight, fieldNumber: 8)
    }
    try { if let v = self._blockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 10)
    }
    if !self.votingPower.isEmpty {
      try visitor.visitSingularStringField(value: self.votingPower, fieldNumber: 11)
    }
    if !self.totalTxs.isEmpty {
      try visitor.visitSingularStringField(value: self.totalTxs, fieldNumber: 12)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 13)
    }
    if !self.forgeAppsVersion.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.forgeAppsVersion, fieldNumber: 15)
    }
    if !self.supportedTxs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.supportedTxs, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ChainInfo, rhs: Ocap_ChainInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.network != rhs.network {return false}
    if lhs.moniker != rhs.moniker {return false}
    if lhs.consensusVersion != rhs.consensusVersion {return false}
    if lhs.synced != rhs.synced {return false}
    if lhs.appHash != rhs.appHash {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs._blockTime != rhs._blockTime {return false}
    if lhs.address != rhs.address {return false}
    if lhs.votingPower != rhs.votingPower {return false}
    if lhs.totalTxs != rhs.totalTxs {return false}
    if lhs.version != rhs.version {return false}
    if lhs.forgeAppsVersion != rhs.forgeAppsVersion {return false}
    if lhs.supportedTxs != rhs.supportedTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "network"),
    3: .same(proto: "moniker"),
    4: .standard(proto: "consensus_version"),
    5: .same(proto: "synced"),
    6: .standard(proto: "app_hash"),
    7: .standard(proto: "block_hash"),
    8: .standard(proto: "block_height"),
    9: .standard(proto: "block_time"),
    10: .same(proto: "address"),
    11: .standard(proto: "voting_power"),
    12: .standard(proto: "total_txs"),
    13: .same(proto: "version"),
    15: .standard(proto: "forge_apps_version"),
    16: .standard(proto: "supported_txs"),
    17: .same(proto: "ip"),
    18: .standard(proto: "geo_info"),
    19: .standard(proto: "p2p_address"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _network: String = String()
    var _moniker: String = String()
    var _consensusVersion: String = String()
    var _synced: Bool = false
    var _appHash: Data = Data()
    var _blockHash: Data = Data()
    var _blockHeight: String = String()
    var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _address: String = String()
    var _votingPower: String = String()
    var _totalTxs: String = String()
    var _version: String = String()
    var _forgeAppsVersion: Dictionary<String,String> = [:]
    var _supportedTxs: [String] = []
    var _ip: String = String()
    var _geoInfo: Ocap_GeoInfo? = nil
    var _p2PAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _network = source._network
      _moniker = source._moniker
      _consensusVersion = source._consensusVersion
      _synced = source._synced
      _appHash = source._appHash
      _blockHash = source._blockHash
      _blockHeight = source._blockHeight
      _blockTime = source._blockTime
      _address = source._address
      _votingPower = source._votingPower
      _totalTxs = source._totalTxs
      _version = source._version
      _forgeAppsVersion = source._forgeAppsVersion
      _supportedTxs = source._supportedTxs
      _ip = source._ip
      _geoInfo = source._geoInfo
      _p2PAddress = source._p2PAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._network) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._moniker) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._consensusVersion) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._synced) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._appHash) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._blockHash) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._blockHeight) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._blockTime) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._votingPower) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._totalTxs) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._forgeAppsVersion) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._supportedTxs) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._ip) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._geoInfo) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._p2PAddress) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 2)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 3)
      }
      if !_storage._consensusVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._consensusVersion, fieldNumber: 4)
      }
      if _storage._synced != false {
        try visitor.visitSingularBoolField(value: _storage._synced, fieldNumber: 5)
      }
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 6)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._blockHash, fieldNumber: 7)
      }
      if !_storage._blockHeight.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockHeight, fieldNumber: 8)
      }
      try { if let v = _storage._blockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 10)
      }
      if !_storage._votingPower.isEmpty {
        try visitor.visitSingularStringField(value: _storage._votingPower, fieldNumber: 11)
      }
      if !_storage._totalTxs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalTxs, fieldNumber: 12)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 13)
      }
      if !_storage._forgeAppsVersion.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._forgeAppsVersion, fieldNumber: 15)
      }
      if !_storage._supportedTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._supportedTxs, fieldNumber: 16)
      }
      if !_storage._ip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ip, fieldNumber: 17)
      }
      try { if let v = _storage._geoInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._p2PAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._p2PAddress, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_NodeInfo, rhs: Ocap_NodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._consensusVersion != rhs_storage._consensusVersion {return false}
        if _storage._synced != rhs_storage._synced {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockTime != rhs_storage._blockTime {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._votingPower != rhs_storage._votingPower {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._forgeAppsVersion != rhs_storage._forgeAppsVersion {return false}
        if _storage._supportedTxs != rhs_storage._supportedTxs {return false}
        if _storage._ip != rhs_storage._ip {return false}
        if _storage._geoInfo != rhs_storage._geoInfo {return false}
        if _storage._p2PAddress != rhs_storage._p2PAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Validator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.power) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.power.isEmpty {
      try visitor.visitSingularStringField(value: self.power, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_Validator, rhs: Ocap_Validator) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ConsensusParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsensusParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_bytes"),
    2: .standard(proto: "max_gas"),
    3: .standard(proto: "max_validators"),
    4: .standard(proto: "max_candidates"),
    5: .standard(proto: "pub_key_types"),
    6: .same(proto: "validators"),
    7: .standard(proto: "validator_changed"),
    8: .standard(proto: "param_changed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.maxBytes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.maxGas) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxValidators) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maxCandidates) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.pubKeyTypes) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.validatorChanged) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.paramChanged) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.maxBytes.isEmpty {
      try visitor.visitSingularStringField(value: self.maxBytes, fieldNumber: 1)
    }
    if !self.maxGas.isEmpty {
      try visitor.visitSingularStringField(value: self.maxGas, fieldNumber: 2)
    }
    if self.maxValidators != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxValidators, fieldNumber: 3)
    }
    if self.maxCandidates != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxCandidates, fieldNumber: 4)
    }
    if !self.pubKeyTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pubKeyTypes, fieldNumber: 5)
    }
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 6)
    }
    if self.validatorChanged != false {
      try visitor.visitSingularBoolField(value: self.validatorChanged, fieldNumber: 7)
    }
    if self.paramChanged != false {
      try visitor.visitSingularBoolField(value: self.paramChanged, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ConsensusParams, rhs: Ocap_ConsensusParams) -> Bool {
    if lhs.maxBytes != rhs.maxBytes {return false}
    if lhs.maxGas != rhs.maxGas {return false}
    if lhs.maxValidators != rhs.maxValidators {return false}
    if lhs.maxCandidates != rhs.maxCandidates {return false}
    if lhs.pubKeyTypes != rhs.pubKeyTypes {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.validatorChanged != rhs.validatorChanged {return false}
    if lhs.paramChanged != rhs.paramChanged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UpgradeTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "data_hash"),
    4: .same(proto: "actions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dataHash) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .configApp {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.dataHash.isEmpty {
      try visitor.visitSingularStringField(value: self.dataHash, fieldNumber: 2)
    }
    if !self.actions.isEmpty {
      try visitor.visitPackedEnumField(value: self.actions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UpgradeTask, rhs: Ocap_UpgradeTask) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.dataHash != rhs.dataHash {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UpgradeTasks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeTasks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UpgradeTasks, rhs: Ocap_UpgradeTasks) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_Multisig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Multisig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .same(proto: "pk"),
    3: .same(proto: "signature"),
    4: .same(proto: "delegator"),
    15: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pk) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.delegator) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 1)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pk, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    if !self.delegator.isEmpty {
      try visitor.visitSingularStringField(value: self.delegator, fieldNumber: 4)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_Multisig, rhs: Ocap_Multisig) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.delegator != rhs.delegator {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "chain_id"),
    4: .same(proto: "pk"),
    5: .same(proto: "gas"),
    6: .same(proto: "delegator"),
    13: .same(proto: "signature"),
    14: .same(proto: "signatures"),
    15: .same(proto: "itx"),
    16: .same(proto: "receipts"),
    17: .standard(proto: "service_fee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.pk) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.gas) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.delegator) }()
      case 13: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.signatures) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._itx) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.receipts) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.serviceFee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pk, fieldNumber: 4)
    }
    if self.gas != 0 {
      try visitor.visitSingularUInt32Field(value: self.gas, fieldNumber: 5)
    }
    if !self.delegator.isEmpty {
      try visitor.visitSingularStringField(value: self.delegator, fieldNumber: 6)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 13)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 14)
    }
    try { if let v = self._itx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    if !self.receipts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receipts, fieldNumber: 16)
    }
    if !self.serviceFee.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceFee, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_Transaction, rhs: Ocap_Transaction) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.delegator != rhs.delegator {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs._itx != rhs._itx {return false}
    if lhs.receipts != rhs.receipts {return false}
    if lhs.serviceFee != rhs.serviceFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "height"),
    3: .same(proto: "index"),
    4: .same(proto: "hash"),
    5: .same(proto: "tags"),
    6: .same(proto: "code"),
    7: .same(proto: "time"),
    8: .same(proto: "receipts"),
    9: .same(proto: "sender"),
    10: .same(proto: "receiver"),
    22: .standard(proto: "token_symbols"),
  ]

  fileprivate class _StorageClass {
    var _tx: Ocap_Transaction? = nil
    var _height: String = String()
    var _index: UInt32 = 0
    var _hash: String = String()
    var _tags: [Vendor_KVPair] = []
    var _code: Ocap_StatusCode = .ok
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _receipts: [Ocap_TransactionReceipt] = []
    var _sender: String = String()
    var _receiver: String = String()
    var _tokenSymbols: [Ocap_TokenSymbol] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tx = source._tx
      _height = source._height
      _index = source._index
      _hash = source._hash
      _tags = source._tags
      _code = source._code
      _time = source._time
      _receipts = source._receipts
      _sender = source._sender
      _receiver = source._receiver
      _tokenSymbols = source._tokenSymbols
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tx) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._height) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._index) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._hash) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._receipts) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._sender) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._receiver) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokenSymbols) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._height.isEmpty {
        try visitor.visitSingularStringField(value: _storage._height, fieldNumber: 2)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 3)
      }
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 4)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 5)
      }
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 6)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._receipts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._receipts, fieldNumber: 8)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 9)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 10)
      }
      if !_storage._tokenSymbols.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokenSymbols, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TransactionInfo, rhs: Ocap_TransactionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tx != rhs_storage._tx {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._receipts != rhs_storage._receipts {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._tokenSymbols != rhs_storage._tokenSymbols {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TransactionReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "changes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.changes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.changes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TransactionReceipt, rhs: Ocap_TransactionReceipt) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.changes != rhs.changes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ReceiptChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiptChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "action"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 1)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ReceiptChange, rhs: Ocap_ReceiptChange) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.action != rhs.action {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenInput, rhs: Ocap_TokenInput) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TransactionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "tokens"),
    3: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TransactionInput, rhs: Ocap_TransactionInput) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_VariableInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariableInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "description"),
    4: .same(proto: "required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_VariableInput, rhs: Ocap_VariableInput) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.required != rhs.required {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delta_interval"),
    2: .standard(proto: "type_urls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deltaInterval) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.typeUrls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deltaInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.deltaInterval, fieldNumber: 1)
    }
    if !self.typeUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeUrls, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegateConfig, rhs: Ocap_DelegateConfig) -> Bool {
    if lhs.deltaInterval != rhs.deltaInterval {return false}
    if lhs.typeUrls != rhs.typeUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_VaultConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VaultConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slashed_stake"),
    2: .standard(proto: "tx_fee"),
    3: .standard(proto: "tx_gas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.slashedStake) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.txFee) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.txGas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.slashedStake.isEmpty {
      try visitor.visitSingularStringField(value: self.slashedStake, fieldNumber: 1)
    }
    if !self.txFee.isEmpty {
      try visitor.visitSingularStringField(value: self.txFee, fieldNumber: 2)
    }
    if !self.txGas.isEmpty {
      try visitor.visitRepeatedStringField(value: self.txGas, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_VaultConfig, rhs: Ocap_VaultConfig) -> Bool {
    if lhs.slashedStake != rhs.slashedStake {return false}
    if lhs.txFee != rhs.txFee {return false}
    if lhs.txGas != rhs.txGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TxFeeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxFeeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_url"),
    2: .same(proto: "fee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.typeURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.typeURL, fieldNumber: 1)
    }
    if !self.fee.isEmpty {
      try visitor.visitSingularStringField(value: self.fee, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TxFeeConfig, rhs: Ocap_TxFeeConfig) -> Bool {
    if lhs.typeURL != rhs.typeURL {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TxGasConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxGasConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .standard(proto: "create_state"),
    3: .standard(proto: "update_state"),
    4: .standard(proto: "data_storage"),
    5: .standard(proto: "min_stake"),
    6: .standard(proto: "max_stake"),
    7: .standard(proto: "stake_lock_period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.price) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.createState) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.updateState) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.dataStorage) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.minStake) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.maxStake) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.stakeLockPeriod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.price != 0 {
      try visitor.visitSingularUInt64Field(value: self.price, fieldNumber: 1)
    }
    if self.createState != 0 {
      try visitor.visitSingularUInt64Field(value: self.createState, fieldNumber: 2)
    }
    if self.updateState != 0 {
      try visitor.visitSingularUInt64Field(value: self.updateState, fieldNumber: 3)
    }
    if self.dataStorage != 0 {
      try visitor.visitSingularUInt64Field(value: self.dataStorage, fieldNumber: 4)
    }
    if !self.minStake.isEmpty {
      try visitor.visitSingularStringField(value: self.minStake, fieldNumber: 5)
    }
    if !self.maxStake.isEmpty {
      try visitor.visitSingularStringField(value: self.maxStake, fieldNumber: 6)
    }
    if self.stakeLockPeriod != 0 {
      try visitor.visitSingularUInt64Field(value: self.stakeLockPeriod, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TxGasConfig, rhs: Ocap_TxGasConfig) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.createState != rhs.createState {return false}
    if lhs.updateState != rhs.updateState {return false}
    if lhs.dataStorage != rhs.dataStorage {return false}
    if lhs.minStake != rhs.minStake {return false}
    if lhs.maxStake != rhs.maxStake {return false}
    if lhs.stakeLockPeriod != rhs.stakeLockPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TransactionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_asset_size"),
    2: .standard(proto: "max_list_size"),
    3: .standard(proto: "max_multisig"),
    4: .same(proto: "delegate"),
    5: .standard(proto: "tx_fee"),
    6: .standard(proto: "tx_gas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxAssetSize) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxListSize) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxMultisig) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._delegate) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.txFee) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._txGas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.maxAssetSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxAssetSize, fieldNumber: 1)
    }
    if self.maxListSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxListSize, fieldNumber: 2)
    }
    if self.maxMultisig != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxMultisig, fieldNumber: 3)
    }
    try { if let v = self._delegate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.txFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txFee, fieldNumber: 5)
    }
    try { if let v = self._txGas {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TransactionConfig, rhs: Ocap_TransactionConfig) -> Bool {
    if lhs.maxAssetSize != rhs.maxAssetSize {return false}
    if lhs.maxListSize != rhs.maxListSize {return false}
    if lhs.maxMultisig != rhs.maxMultisig {return false}
    if lhs._delegate != rhs._delegate {return false}
    if lhs.txFee != rhs.txFee {return false}
    if lhs._txGas != rhs._txGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_BlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "num_txs"),
    3: .same(proto: "time"),
    4: .standard(proto: "app_hash"),
    5: .same(proto: "proposer"),
    6: .same(proto: "txs"),
    7: .standard(proto: "total_txs"),
    8: .standard(proto: "invalid_txs"),
    9: .standard(proto: "txs_hashes"),
    10: .standard(proto: "invalid_txs_hashes"),
    11: .standard(proto: "consensus_hash"),
    12: .standard(proto: "data_hash"),
    13: .standard(proto: "evidence_hash"),
    14: .standard(proto: "last_commit_hash"),
    15: .standard(proto: "last_results_hash"),
    16: .standard(proto: "next_validators_hash"),
    17: .standard(proto: "validators_hash"),
    18: .same(proto: "version"),
    19: .standard(proto: "last_block_id"),
  ]

  fileprivate class _StorageClass {
    var _height: String = String()
    var _numTxs: UInt32 = 0
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _appHash: Data = Data()
    var _proposer: Data = Data()
    var _txs: [Ocap_TransactionInfo] = []
    var _totalTxs: String = String()
    var _invalidTxs: [Ocap_TransactionInfo] = []
    var _txsHashes: [String] = []
    var _invalidTxsHashes: [String] = []
    var _consensusHash: Data = Data()
    var _dataHash: Data = Data()
    var _evidenceHash: Data = Data()
    var _lastCommitHash: Data = Data()
    var _lastResultsHash: Data = Data()
    var _nextValidatorsHash: Data = Data()
    var _validatorsHash: Data = Data()
    var _version: Vendor_Version? = nil
    var _lastBlockID: Vendor_BlockID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _numTxs = source._numTxs
      _time = source._time
      _appHash = source._appHash
      _proposer = source._proposer
      _txs = source._txs
      _totalTxs = source._totalTxs
      _invalidTxs = source._invalidTxs
      _txsHashes = source._txsHashes
      _invalidTxsHashes = source._invalidTxsHashes
      _consensusHash = source._consensusHash
      _dataHash = source._dataHash
      _evidenceHash = source._evidenceHash
      _lastCommitHash = source._lastCommitHash
      _lastResultsHash = source._lastResultsHash
      _nextValidatorsHash = source._nextValidatorsHash
      _validatorsHash = source._validatorsHash
      _version = source._version
      _lastBlockID = source._lastBlockID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._height) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._numTxs) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._appHash) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._proposer) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._txs) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._totalTxs) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._invalidTxs) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._txsHashes) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._invalidTxsHashes) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._consensusHash) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._dataHash) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._evidenceHash) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._lastCommitHash) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._lastResultsHash) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._nextValidatorsHash) }()
        case 17: try { try decoder.decodeSingularBytesField(value: &_storage._validatorsHash) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._version) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._lastBlockID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._height.isEmpty {
        try visitor.visitSingularStringField(value: _storage._height, fieldNumber: 1)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numTxs, fieldNumber: 2)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 4)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proposer, fieldNumber: 5)
      }
      if !_storage._txs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._txs, fieldNumber: 6)
      }
      if !_storage._totalTxs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalTxs, fieldNumber: 7)
      }
      if !_storage._invalidTxs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._invalidTxs, fieldNumber: 8)
      }
      if !_storage._txsHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._txsHashes, fieldNumber: 9)
      }
      if !_storage._invalidTxsHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._invalidTxsHashes, fieldNumber: 10)
      }
      if !_storage._consensusHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._consensusHash, fieldNumber: 11)
      }
      if !_storage._dataHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._dataHash, fieldNumber: 12)
      }
      if !_storage._evidenceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._evidenceHash, fieldNumber: 13)
      }
      if !_storage._lastCommitHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastCommitHash, fieldNumber: 14)
      }
      if !_storage._lastResultsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastResultsHash, fieldNumber: 15)
      }
      if !_storage._nextValidatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nextValidatorsHash, fieldNumber: 16)
      }
      if !_storage._validatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._validatorsHash, fieldNumber: 17)
      }
      try { if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._lastBlockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_BlockInfo, rhs: Ocap_BlockInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._txs != rhs_storage._txs {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._invalidTxs != rhs_storage._invalidTxs {return false}
        if _storage._txsHashes != rhs_storage._txsHashes {return false}
        if _storage._invalidTxsHashes != rhs_storage._invalidTxsHashes {return false}
        if _storage._consensusHash != rhs_storage._consensusHash {return false}
        if _storage._dataHash != rhs_storage._dataHash {return false}
        if _storage._evidenceHash != rhs_storage._evidenceHash {return false}
        if _storage._lastCommitHash != rhs_storage._lastCommitHash {return false}
        if _storage._lastResultsHash != rhs_storage._lastResultsHash {return false}
        if _storage._nextValidatorsHash != rhs_storage._nextValidatorsHash {return false}
        if _storage._validatorsHash != rhs_storage._validatorsHash {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._lastBlockID != rhs_storage._lastBlockID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_BlockInfoSimple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockInfoSimple"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "num_txs"),
    3: .same(proto: "time"),
    4: .standard(proto: "app_hash"),
    5: .same(proto: "proposer"),
    6: .standard(proto: "total_txs"),
    7: .standard(proto: "txs_hashes"),
    8: .standard(proto: "invalid_txs_hashes"),
    9: .standard(proto: "consensus_hash"),
    10: .standard(proto: "data_hash"),
    11: .standard(proto: "evidence_hash"),
    12: .standard(proto: "last_commit_hash"),
    13: .standard(proto: "last_results_hash"),
    14: .standard(proto: "next_validators_hash"),
    15: .standard(proto: "validators_hash"),
    16: .same(proto: "version"),
    17: .standard(proto: "last_block_id"),
  ]

  fileprivate class _StorageClass {
    var _height: String = String()
    var _numTxs: UInt32 = 0
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _appHash: Data = Data()
    var _proposer: Data = Data()
    var _totalTxs: String = String()
    var _txsHashes: [String] = []
    var _invalidTxsHashes: [String] = []
    var _consensusHash: Data = Data()
    var _dataHash: Data = Data()
    var _evidenceHash: Data = Data()
    var _lastCommitHash: Data = Data()
    var _lastResultsHash: Data = Data()
    var _nextValidatorsHash: Data = Data()
    var _validatorsHash: Data = Data()
    var _version: Vendor_Version? = nil
    var _lastBlockID: Vendor_BlockID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _numTxs = source._numTxs
      _time = source._time
      _appHash = source._appHash
      _proposer = source._proposer
      _totalTxs = source._totalTxs
      _txsHashes = source._txsHashes
      _invalidTxsHashes = source._invalidTxsHashes
      _consensusHash = source._consensusHash
      _dataHash = source._dataHash
      _evidenceHash = source._evidenceHash
      _lastCommitHash = source._lastCommitHash
      _lastResultsHash = source._lastResultsHash
      _nextValidatorsHash = source._nextValidatorsHash
      _validatorsHash = source._validatorsHash
      _version = source._version
      _lastBlockID = source._lastBlockID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._height) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._numTxs) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._appHash) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._proposer) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._totalTxs) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._txsHashes) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._invalidTxsHashes) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._consensusHash) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._dataHash) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._evidenceHash) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._lastCommitHash) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._lastResultsHash) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._nextValidatorsHash) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._validatorsHash) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._version) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._lastBlockID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._height.isEmpty {
        try visitor.visitSingularStringField(value: _storage._height, fieldNumber: 1)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numTxs, fieldNumber: 2)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 4)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proposer, fieldNumber: 5)
      }
      if !_storage._totalTxs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalTxs, fieldNumber: 6)
      }
      if !_storage._txsHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._txsHashes, fieldNumber: 7)
      }
      if !_storage._invalidTxsHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._invalidTxsHashes, fieldNumber: 8)
      }
      if !_storage._consensusHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._consensusHash, fieldNumber: 9)
      }
      if !_storage._dataHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._dataHash, fieldNumber: 10)
      }
      if !_storage._evidenceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._evidenceHash, fieldNumber: 11)
      }
      if !_storage._lastCommitHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastCommitHash, fieldNumber: 12)
      }
      if !_storage._lastResultsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastResultsHash, fieldNumber: 13)
      }
      if !_storage._nextValidatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nextValidatorsHash, fieldNumber: 14)
      }
      if !_storage._validatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._validatorsHash, fieldNumber: 15)
      }
      try { if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._lastBlockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_BlockInfoSimple, rhs: Ocap_BlockInfoSimple) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._txsHashes != rhs_storage._txsHashes {return false}
        if _storage._invalidTxsHashes != rhs_storage._invalidTxsHashes {return false}
        if _storage._consensusHash != rhs_storage._consensusHash {return false}
        if _storage._dataHash != rhs_storage._dataHash {return false}
        if _storage._evidenceHash != rhs_storage._evidenceHash {return false}
        if _storage._lastCommitHash != rhs_storage._lastCommitHash {return false}
        if _storage._lastResultsHash != rhs_storage._lastResultsHash {return false}
        if _storage._nextValidatorsHash != rhs_storage._nextValidatorsHash {return false}
        if _storage._validatorsHash != rhs_storage._validatorsHash {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._lastBlockID != rhs_storage._lastBlockID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_StateContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "genesis_tx"),
    2: .standard(proto: "renaissance_tx"),
    3: .standard(proto: "genesis_time"),
    4: .standard(proto: "renaissance_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.genesisTx) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.renaissanceTx) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._genesisTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._renaissanceTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.genesisTx.isEmpty {
      try visitor.visitSingularStringField(value: self.genesisTx, fieldNumber: 1)
    }
    if !self.renaissanceTx.isEmpty {
      try visitor.visitSingularStringField(value: self.renaissanceTx, fieldNumber: 2)
    }
    try { if let v = self._genesisTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._renaissanceTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_StateContext, rhs: Ocap_StateContext) -> Bool {
    if lhs.genesisTx != rhs.genesisTx {return false}
    if lhs.renaissanceTx != rhs.renaissanceTx {return false}
    if lhs._genesisTime != rhs._genesisTime {return false}
    if lhs._renaissanceTime != rhs._renaissanceTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_StakeSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_stakes"),
    2: .standard(proto: "total_unstakes"),
    3: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._totalStakes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totalUnstakes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._totalStakes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._totalUnstakes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_StakeSummary, rhs: Ocap_StakeSummary) -> Bool {
    if lhs._totalStakes != rhs._totalStakes {return false}
    if lhs._totalUnstakes != rhs._totalUnstakes {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "n_txs"),
    2: .same(proto: "txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.nTxs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.txs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nTxs != 0 {
      try visitor.visitSingularUInt32Field(value: self.nTxs, fieldNumber: 1)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UnconfirmedTxs, rhs: Ocap_UnconfirmedTxs) -> Bool {
    if lhs.nTxs != rhs.nTxs {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_NetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listening"),
    2: .same(proto: "listeners"),
    3: .standard(proto: "n_peers"),
    4: .same(proto: "peers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.listening) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.listeners) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.nPeers) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listening != false {
      try visitor.visitSingularBoolField(value: self.listening, fieldNumber: 1)
    }
    if !self.listeners.isEmpty {
      try visitor.visitRepeatedStringField(value: self.listeners, fieldNumber: 2)
    }
    if self.nPeers != 0 {
      try visitor.visitSingularUInt32Field(value: self.nPeers, fieldNumber: 3)
    }
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_NetInfo, rhs: Ocap_NetInfo) -> Bool {
    if lhs.listening != rhs.listening {return false}
    if lhs.listeners != rhs.listeners {return false}
    if lhs.nPeers != rhs.nPeers {return false}
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_GeoInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "city"),
    2: .same(proto: "country"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.latitude) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.longitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 1)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 2)
    }
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 3)
    }
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_GeoInfo, rhs: Ocap_GeoInfo) -> Bool {
    if lhs.city != rhs.city {return false}
    if lhs.country != rhs.country {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_PeerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "network"),
    3: .standard(proto: "consensus_version"),
    4: .same(proto: "moniker"),
    5: .same(proto: "ip"),
    6: .standard(proto: "geo_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.consensusVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.moniker) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._geoInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    if !self.consensusVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.consensusVersion, fieldNumber: 3)
    }
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 4)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 5)
    }
    try { if let v = self._geoInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_PeerInfo, rhs: Ocap_PeerInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.network != rhs.network {return false}
    if lhs.consensusVersion != rhs.consensusVersion {return false}
    if lhs.moniker != rhs.moniker {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs._geoInfo != rhs._geoInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorsInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .same(proto: "validators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.blockHeight) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockHeight.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHeight, fieldNumber: 1)
    }
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ValidatorsInfo, rhs: Ocap_ValidatorsInfo) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ValidatorInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "pub_key"),
    3: .standard(proto: "voting_power"),
    4: .standard(proto: "proposer_priority"),
    5: .same(proto: "name"),
    6: .standard(proto: "geo_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pubKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.votingPower) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.proposerPriority) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._geoInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try { if let v = self._pubKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.votingPower.isEmpty {
      try visitor.visitSingularStringField(value: self.votingPower, fieldNumber: 3)
    }
    if !self.proposerPriority.isEmpty {
      try visitor.visitSingularStringField(value: self.proposerPriority, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try { if let v = self._geoInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ValidatorInfo, rhs: Ocap_ValidatorInfo) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._pubKey != rhs._pubKey {return false}
    if lhs.votingPower != rhs.votingPower {return false}
    if lhs.proposerPriority != rhs.proposerPriority {return false}
    if lhs.name != rhs.name {return false}
    if lhs._geoInfo != rhs._geoInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ForgeToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgeToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .same(proto: "unit"),
    4: .same(proto: "description"),
    5: .same(proto: "icon"),
    6: .same(proto: "decimal"),
    7: .standard(proto: "initial_supply"),
    8: .standard(proto: "total_supply"),
    9: .standard(proto: "inflation_rate"),
    10: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.decimal) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.initialSupply) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.totalSupply) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.inflationRate) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularBytesField(value: self.icon, fieldNumber: 5)
    }
    if self.decimal != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimal, fieldNumber: 6)
    }
    if !self.initialSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.initialSupply, fieldNumber: 7)
    }
    if !self.totalSupply.isEmpty {
      try visitor.visitSingularStringField(value: self.totalSupply, fieldNumber: 8)
    }
    if self.inflationRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.inflationRate, fieldNumber: 9)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ForgeToken, rhs: Ocap_ForgeToken) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.decimal != rhs.decimal {return false}
    if lhs.initialSupply != rhs.initialSupply {return false}
    if lhs.totalSupply != rhs.totalSupply {return false}
    if lhs.inflationRate != rhs.inflationRate {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UpgradeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.height) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.height.isEmpty {
      try visitor.visitSingularStringField(value: self.height, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UpgradeInfo, rhs: Ocap_UpgradeInfo) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_WithdrawItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_WithdrawItem, rhs: Ocap_WithdrawItem) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AccountConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "pk"),
    3: .same(proto: "balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pk) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularBytesField(value: self.pk, fieldNumber: 2)
    }
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AccountConfig, rhs: Ocap_AccountConfig) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_Evidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Evidence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_Evidence, rhs: Ocap_Evidence) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_NFTEndpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NFTEndpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "scope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_NFTEndpoint, rhs: Ocap_NFTEndpoint) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_NFTDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NFTDisplay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_NFTDisplay, rhs: Ocap_NFTDisplay) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_NFTIssuer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NFTIssuer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "pk"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularStringField(value: self.pk, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_NFTIssuer, rhs: Ocap_NFTIssuer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFactoryHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFactoryHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "hook"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hook) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.hook.isEmpty {
      try visitor.visitSingularStringField(value: self.hook, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFactoryHook, rhs: Ocap_AssetFactoryHook) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.hook != rhs.hook {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedTokenInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedTokenInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "value"),
    3: .same(proto: "decimal"),
    4: .same(proto: "unit"),
    5: .same(proto: "symbol"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.decimal) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.decimal != 0 {
      try visitor.visitSingularInt32Field(value: self.decimal, fieldNumber: 3)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 4)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedTokenInput, rhs: Ocap_IndexedTokenInput) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.value != rhs.value {return false}
    if lhs.decimal != rhs.decimal {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedFactoryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedFactoryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "tokens"),
    3: .same(proto: "assets"),
    4: .same(proto: "variables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 3)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedFactoryInput, rhs: Ocap_IndexedFactoryInput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RollupValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollupValidator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pk"),
    2: .same(proto: "address"),
    3: .same(proto: "endpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pk) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pk.isEmpty {
      try visitor.visitSingularStringField(value: self.pk, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RollupValidator, rhs: Ocap_RollupValidator) -> Bool {
    if lhs.pk != rhs.pk {return false}
    if lhs.address != rhs.address {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RollupSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollupSignature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RollupSignature, rhs: Ocap_RollupSignature) -> Bool {
    if lhs.signer != rhs.signer {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ForeignToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForeignToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "contract_address"),
    3: .standard(proto: "chain_type"),
    4: .standard(proto: "chain_name"),
    5: .standard(proto: "chain_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contractAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.chainName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.chainID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.contractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.contractAddress, fieldNumber: 2)
    }
    if !self.chainType.isEmpty {
      try visitor.visitSingularStringField(value: self.chainType, fieldNumber: 3)
    }
    if !self.chainName.isEmpty {
      try visitor.visitSingularStringField(value: self.chainName, fieldNumber: 4)
    }
    if self.chainID != 0 {
      try visitor.visitSingularInt32Field(value: self.chainID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ForeignToken, rhs: Ocap_ForeignToken) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.contractAddress != rhs.contractAddress {return false}
    if lhs.chainType != rhs.chainType {return false}
    if lhs.chainName != rhs.chainName {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RevokedStake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokedStake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokens"),
    2: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 1)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RevokedStake, rhs: Ocap_RevokedStake) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_blocks"),
    2: .standard(proto: "num_txs"),
    3: .standard(proto: "num_stakes"),
    4: .standard(proto: "num_validators"),
    5: .standard(proto: "num_account_migrate_txs"),
    6: .standard(proto: "num_create_asset_txs"),
    7: .standard(proto: "num_consensus_upgrade_txs"),
    8: .standard(proto: "num_declare_txs"),
    9: .standard(proto: "num_declare_file_txs"),
    10: .standard(proto: "num_exchange_txs"),
    11: .standard(proto: "num_stake_txs"),
    12: .standard(proto: "num_sys_upgrade_txs"),
    13: .standard(proto: "num_transfer_txs"),
    14: .standard(proto: "num_update_asset_txs"),
    15: .standard(proto: "num_consume_asset_txs"),
    16: .same(proto: "tps"),
    17: .standard(proto: "max_tps"),
    18: .standard(proto: "avg_tps"),
    19: .standard(proto: "avg_block_time"),
  ]

  fileprivate class _StorageClass {
    var _numBlocks: [String] = []
    var _numTxs: [String] = []
    var _numStakes: [Ocap_BigUint] = []
    var _numValidators: [UInt32] = []
    var _numAccountMigrateTxs: [String] = []
    var _numCreateAssetTxs: [String] = []
    var _numConsensusUpgradeTxs: [UInt32] = []
    var _numDeclareTxs: [String] = []
    var _numDeclareFileTxs: [String] = []
    var _numExchangeTxs: [String] = []
    var _numStakeTxs: [String] = []
    var _numSysUpgradeTxs: [UInt32] = []
    var _numTransferTxs: [String] = []
    var _numUpdateAssetTxs: [String] = []
    var _numConsumeAssetTxs: [String] = []
    var _tps: [UInt32] = []
    var _maxTps: UInt32 = 0
    var _avgTps: UInt32 = 0
    var _avgBlockTime: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _numBlocks = source._numBlocks
      _numTxs = source._numTxs
      _numStakes = source._numStakes
      _numValidators = source._numValidators
      _numAccountMigrateTxs = source._numAccountMigrateTxs
      _numCreateAssetTxs = source._numCreateAssetTxs
      _numConsensusUpgradeTxs = source._numConsensusUpgradeTxs
      _numDeclareTxs = source._numDeclareTxs
      _numDeclareFileTxs = source._numDeclareFileTxs
      _numExchangeTxs = source._numExchangeTxs
      _numStakeTxs = source._numStakeTxs
      _numSysUpgradeTxs = source._numSysUpgradeTxs
      _numTransferTxs = source._numTransferTxs
      _numUpdateAssetTxs = source._numUpdateAssetTxs
      _numConsumeAssetTxs = source._numConsumeAssetTxs
      _tps = source._tps
      _maxTps = source._maxTps
      _avgTps = source._avgTps
      _avgBlockTime = source._avgBlockTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedStringField(value: &_storage._numBlocks) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._numTxs) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._numStakes) }()
        case 4: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._numValidators) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._numAccountMigrateTxs) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._numCreateAssetTxs) }()
        case 7: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._numConsensusUpgradeTxs) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._numDeclareTxs) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._numDeclareFileTxs) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._numExchangeTxs) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._numStakeTxs) }()
        case 12: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._numSysUpgradeTxs) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._numTransferTxs) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._numUpdateAssetTxs) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._numConsumeAssetTxs) }()
        case 16: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._tps) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxTps) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._avgTps) }()
        case 19: try { try decoder.decodeSingularFloatField(value: &_storage._avgBlockTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._numBlocks.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numBlocks, fieldNumber: 1)
      }
      if !_storage._numTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numTxs, fieldNumber: 2)
      }
      if !_storage._numStakes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._numStakes, fieldNumber: 3)
      }
      if !_storage._numValidators.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._numValidators, fieldNumber: 4)
      }
      if !_storage._numAccountMigrateTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numAccountMigrateTxs, fieldNumber: 5)
      }
      if !_storage._numCreateAssetTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numCreateAssetTxs, fieldNumber: 6)
      }
      if !_storage._numConsensusUpgradeTxs.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._numConsensusUpgradeTxs, fieldNumber: 7)
      }
      if !_storage._numDeclareTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numDeclareTxs, fieldNumber: 8)
      }
      if !_storage._numDeclareFileTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numDeclareFileTxs, fieldNumber: 9)
      }
      if !_storage._numExchangeTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numExchangeTxs, fieldNumber: 10)
      }
      if !_storage._numStakeTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numStakeTxs, fieldNumber: 11)
      }
      if !_storage._numSysUpgradeTxs.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._numSysUpgradeTxs, fieldNumber: 12)
      }
      if !_storage._numTransferTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numTransferTxs, fieldNumber: 13)
      }
      if !_storage._numUpdateAssetTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numUpdateAssetTxs, fieldNumber: 14)
      }
      if !_storage._numConsumeAssetTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._numConsumeAssetTxs, fieldNumber: 15)
      }
      if !_storage._tps.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._tps, fieldNumber: 16)
      }
      if _storage._maxTps != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxTps, fieldNumber: 17)
      }
      if _storage._avgTps != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._avgTps, fieldNumber: 18)
      }
      if _storage._avgBlockTime != 0 {
        try visitor.visitSingularFloatField(value: _storage._avgBlockTime, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ForgeStats, rhs: Ocap_ForgeStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._numBlocks != rhs_storage._numBlocks {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._numStakes != rhs_storage._numStakes {return false}
        if _storage._numValidators != rhs_storage._numValidators {return false}
        if _storage._numAccountMigrateTxs != rhs_storage._numAccountMigrateTxs {return false}
        if _storage._numCreateAssetTxs != rhs_storage._numCreateAssetTxs {return false}
        if _storage._numConsensusUpgradeTxs != rhs_storage._numConsensusUpgradeTxs {return false}
        if _storage._numDeclareTxs != rhs_storage._numDeclareTxs {return false}
        if _storage._numDeclareFileTxs != rhs_storage._numDeclareFileTxs {return false}
        if _storage._numExchangeTxs != rhs_storage._numExchangeTxs {return false}
        if _storage._numStakeTxs != rhs_storage._numStakeTxs {return false}
        if _storage._numSysUpgradeTxs != rhs_storage._numSysUpgradeTxs {return false}
        if _storage._numTransferTxs != rhs_storage._numTransferTxs {return false}
        if _storage._numUpdateAssetTxs != rhs_storage._numUpdateAssetTxs {return false}
        if _storage._numConsumeAssetTxs != rhs_storage._numConsumeAssetTxs {return false}
        if _storage._tps != rhs_storage._tps {return false}
        if _storage._maxTps != rhs_storage._maxTps {return false}
        if _storage._avgTps != rhs_storage._avgTps {return false}
        if _storage._avgBlockTime != rhs_storage._avgBlockTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_GasEstimate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GasEstimate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.max) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.max.isEmpty {
      try visitor.visitSingularStringField(value: self.max, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_GasEstimate, rhs: Ocap_GasEstimate) -> Bool {
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RateLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
    3: .same(proto: "anchor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.interval) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.anchor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interval != 0 {
      try visitor.visitSingularUInt64Field(value: self.interval, fieldNumber: 1)
    }
    if self.anchor != 0 {
      try visitor.visitSingularUInt64Field(value: self.anchor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RateLimit, rhs: Ocap_RateLimit) -> Bool {
    if lhs.interval != rhs.interval {return false}
    if lhs.anchor != rhs.anchor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "to"),
    3: .standard(proto: "tx_count"),
    4: .standard(proto: "tx_allowance"),
    5: .standard(proto: "total_allowance"),
    6: .standard(proto: "valid_until"),
    7: .same(proto: "rate"),
    8: .standard(proto: "tx_sent"),
    9: .standard(proto: "spent_allowance"),
    10: .standard(proto: "last_tx"),
    11: .same(proto: "decimal"),
    12: .same(proto: "symbol"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.txCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.txAllowance) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalAllowance) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.validUntil) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._rate) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.txSent) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.spentAllowance) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.lastTx) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.decimal) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitRepeatedStringField(value: self.to, fieldNumber: 2)
    }
    if self.txCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.txCount, fieldNumber: 3)
    }
    if !self.txAllowance.isEmpty {
      try visitor.visitSingularStringField(value: self.txAllowance, fieldNumber: 4)
    }
    if !self.totalAllowance.isEmpty {
      try visitor.visitSingularStringField(value: self.totalAllowance, fieldNumber: 5)
    }
    if self.validUntil != 0 {
      try visitor.visitSingularUInt64Field(value: self.validUntil, fieldNumber: 6)
    }
    try { if let v = self._rate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.txSent != 0 {
      try visitor.visitSingularUInt32Field(value: self.txSent, fieldNumber: 8)
    }
    if !self.spentAllowance.isEmpty {
      try visitor.visitSingularStringField(value: self.spentAllowance, fieldNumber: 9)
    }
    if self.lastTx != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastTx, fieldNumber: 10)
    }
    if self.decimal != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimal, fieldNumber: 11)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenLimit, rhs: Ocap_TokenLimit) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.to != rhs.to {return false}
    if lhs.txCount != rhs.txCount {return false}
    if lhs.txAllowance != rhs.txAllowance {return false}
    if lhs.totalAllowance != rhs.totalAllowance {return false}
    if lhs.validUntil != rhs.validUntil {return false}
    if lhs._rate != rhs._rate {return false}
    if lhs.txSent != rhs.txSent {return false}
    if lhs.spentAllowance != rhs.spentAllowance {return false}
    if lhs.lastTx != rhs.lastTx {return false}
    if lhs.decimal != rhs.decimal {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "to"),
    3: .standard(proto: "tx_count"),
    4: .standard(proto: "valid_until"),
    5: .same(proto: "rate"),
    6: .standard(proto: "tx_sent"),
    7: .standard(proto: "last_tx"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.to) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.txCount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.validUntil) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._rate) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.txSent) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.lastTx) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitRepeatedStringField(value: self.address, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitRepeatedStringField(value: self.to, fieldNumber: 2)
    }
    if self.txCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.txCount, fieldNumber: 3)
    }
    if self.validUntil != 0 {
      try visitor.visitSingularUInt64Field(value: self.validUntil, fieldNumber: 4)
    }
    try { if let v = self._rate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.txSent != 0 {
      try visitor.visitSingularUInt32Field(value: self.txSent, fieldNumber: 6)
    }
    if self.lastTx != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastTx, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetLimit, rhs: Ocap_AssetLimit) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.to != rhs.to {return false}
    if lhs.txCount != rhs.txCount {return false}
    if lhs.validUntil != rhs.validUntil {return false}
    if lhs._rate != rhs._rate {return false}
    if lhs.txSent != rhs.txSent {return false}
    if lhs.lastTx != rhs.lastTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokens"),
    2: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 1)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegateLimit, rhs: Ocap_DelegateLimit) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
