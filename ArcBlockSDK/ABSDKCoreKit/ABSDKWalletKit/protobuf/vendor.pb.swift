// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vendor.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ================================================================
/// import "github.com/tendermint/tendermint/libs/common/proto";
/// ================================================================
public struct Vendor_KVPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Data = Data()

  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BlockParams contains limits on the block size and timestamp.
public struct Vendor_BlockParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Note: must be greater than 0
  public var maxBytes: Int64 = 0

  /// Note: must be greater or equal to -1
  public var maxGas: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// EvidenceParams contains limits on the evidence.
public struct Vendor_EvidenceParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Note: must be greater than 0
  public var maxAge: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ValidatorParams contains limits on validators.
public struct Vendor_ValidatorParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKeyTypes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ConsensusParams contains all consensus-relevant parameters
/// that can be adjusted by the abci app
public struct Vendor_ConsensusParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var block: Vendor_BlockParams {
    get {return _block ?? Vendor_BlockParams()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {self._block = nil}

  public var evidence: Vendor_EvidenceParams {
    get {return _evidence ?? Vendor_EvidenceParams()}
    set {_evidence = newValue}
  }
  /// Returns true if `evidence` has been explicitly set.
  public var hasEvidence: Bool {return self._evidence != nil}
  /// Clears the value of `evidence`. Subsequent reads from it will return its default value.
  public mutating func clearEvidence() {self._evidence = nil}

  public var validator: Vendor_ValidatorParams {
    get {return _validator ?? Vendor_ValidatorParams()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  public var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  public mutating func clearValidator() {self._validator = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _block: Vendor_BlockParams? = nil
  fileprivate var _evidence: Vendor_EvidenceParams? = nil
  fileprivate var _validator: Vendor_ValidatorParams? = nil
}

public struct Vendor_LastCommitInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var round: Int32 = 0

  public var votes: [Vendor_VoteInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vendor_Version {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var block: UInt64 = 0

  public var app: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vendor_BlockID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = Data()

  public var partsHeader: Vendor_PartSetHeader {
    get {return _partsHeader ?? Vendor_PartSetHeader()}
    set {_partsHeader = newValue}
  }
  /// Returns true if `partsHeader` has been explicitly set.
  public var hasPartsHeader: Bool {return self._partsHeader != nil}
  /// Clears the value of `partsHeader`. Subsequent reads from it will return its default value.
  public mutating func clearPartsHeader() {self._partsHeader = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _partsHeader: Vendor_PartSetHeader? = nil
}

public struct Vendor_PartSetHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var total: Int32 = 0

  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Validator
public struct Vendor_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Data = Data()

  ///PubKey pub_key = 2;
  public var power: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ValidatorUpdate
public struct Vendor_ValidatorUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pubKey: Vendor_PubKey {
    get {return _pubKey ?? Vendor_PubKey()}
    set {_pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  public var hasPubKey: Bool {return self._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  public mutating func clearPubKey() {self._pubKey = nil}

  public var power: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pubKey: Vendor_PubKey? = nil
}

/// VoteInfo
public struct Vendor_VoteInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validator: Vendor_Validator {
    get {return _validator ?? Vendor_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  public var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  public mutating func clearValidator() {self._validator = nil}

  public var signedLastBlock: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validator: Vendor_Validator? = nil
}

public struct Vendor_PubKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Vendor_Evidence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String = String()

  public var validator: Vendor_Validator {
    get {return _validator ?? Vendor_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  public var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  public mutating func clearValidator() {self._validator = nil}

  public var height: Int64 = 0

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  public var totalVotingPower: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validator: Vendor_Validator? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Vendor_Header {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// basic block info
  public var version: Vendor_Version {
    get {return _storage._version ?? Vendor_Version()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {_uniqueStorage()._version = nil}

  public var chainID: String {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  public var height: Int64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var numTxs: Int64 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var totalTxs: Int64 {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  /// prev block info
  public var lastBlockID: Vendor_BlockID {
    get {return _storage._lastBlockID ?? Vendor_BlockID()}
    set {_uniqueStorage()._lastBlockID = newValue}
  }
  /// Returns true if `lastBlockID` has been explicitly set.
  public var hasLastBlockID: Bool {return _storage._lastBlockID != nil}
  /// Clears the value of `lastBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearLastBlockID() {_uniqueStorage()._lastBlockID = nil}

  /// hashes of block data
  public var lastCommitHash: Data {
    get {return _storage._lastCommitHash}
    set {_uniqueStorage()._lastCommitHash = newValue}
  }

  /// transactions
  public var dataHash: Data {
    get {return _storage._dataHash}
    set {_uniqueStorage()._dataHash = newValue}
  }

  /// hashes from the app output from the prev block
  public var validatorsHash: Data {
    get {return _storage._validatorsHash}
    set {_uniqueStorage()._validatorsHash = newValue}
  }

  /// validators for the next block
  public var nextValidatorsHash: Data {
    get {return _storage._nextValidatorsHash}
    set {_uniqueStorage()._nextValidatorsHash = newValue}
  }

  /// consensus params for current block
  public var consensusHash: Data {
    get {return _storage._consensusHash}
    set {_uniqueStorage()._consensusHash = newValue}
  }

  /// state after txs from the previous block
  public var appHash: Data {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  /// root hash of all results from the txs from the previous block
  public var lastResultsHash: Data {
    get {return _storage._lastResultsHash}
    set {_uniqueStorage()._lastResultsHash = newValue}
  }

  /// consensus info
  public var evidenceHash: Data {
    get {return _storage._evidenceHash}
    set {_uniqueStorage()._evidenceHash = newValue}
  }

  /// original proposer of the block
  public var proposerAddress: Data {
    get {return _storage._proposerAddress}
    set {_uniqueStorage()._proposerAddress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Vendor_RequestBeginBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = Data()

  public var header: Vendor_Header {
    get {return _header ?? Vendor_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var lastCommitInfo: Vendor_LastCommitInfo {
    get {return _lastCommitInfo ?? Vendor_LastCommitInfo()}
    set {_lastCommitInfo = newValue}
  }
  /// Returns true if `lastCommitInfo` has been explicitly set.
  public var hasLastCommitInfo: Bool {return self._lastCommitInfo != nil}
  /// Clears the value of `lastCommitInfo`. Subsequent reads from it will return its default value.
  public mutating func clearLastCommitInfo() {self._lastCommitInfo = nil}

  public var byzantineValidators: [Vendor_Evidence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Vendor_Header? = nil
  fileprivate var _lastCommitInfo: Vendor_LastCommitInfo? = nil
}

public struct Vendor_RequestEndBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Vendor_KVPair: @unchecked Sendable {}
extension Vendor_BlockParams: @unchecked Sendable {}
extension Vendor_EvidenceParams: @unchecked Sendable {}
extension Vendor_ValidatorParams: @unchecked Sendable {}
extension Vendor_ConsensusParams: @unchecked Sendable {}
extension Vendor_LastCommitInfo: @unchecked Sendable {}
extension Vendor_Version: @unchecked Sendable {}
extension Vendor_BlockID: @unchecked Sendable {}
extension Vendor_PartSetHeader: @unchecked Sendable {}
extension Vendor_Validator: @unchecked Sendable {}
extension Vendor_ValidatorUpdate: @unchecked Sendable {}
extension Vendor_VoteInfo: @unchecked Sendable {}
extension Vendor_PubKey: @unchecked Sendable {}
extension Vendor_Evidence: @unchecked Sendable {}
extension Vendor_Header: @unchecked Sendable {}
extension Vendor_RequestBeginBlock: @unchecked Sendable {}
extension Vendor_RequestEndBlock: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "vendor"

extension Vendor_KVPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KVPair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_KVPair, rhs: Vendor_KVPair) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_BlockParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_bytes"),
    2: .standard(proto: "max_gas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxBytes) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxGas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.maxBytes, fieldNumber: 1)
    }
    if self.maxGas != 0 {
      try visitor.visitSingularInt64Field(value: self.maxGas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_BlockParams, rhs: Vendor_BlockParams) -> Bool {
    if lhs.maxBytes != rhs.maxBytes {return false}
    if lhs.maxGas != rhs.maxGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_EvidenceParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvidenceParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_age"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxAge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxAge != 0 {
      try visitor.visitSingularInt64Field(value: self.maxAge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_EvidenceParams, rhs: Vendor_EvidenceParams) -> Bool {
    if lhs.maxAge != rhs.maxAge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_ValidatorParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.pubKeyTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKeyTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pubKeyTypes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_ValidatorParams, rhs: Vendor_ValidatorParams) -> Bool {
    if lhs.pubKeyTypes != rhs.pubKeyTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_ConsensusParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsensusParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "evidence"),
    3: .same(proto: "validator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._evidence) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._evidence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_ConsensusParams, rhs: Vendor_ConsensusParams) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs._evidence != rhs._evidence {return false}
    if lhs._validator != rhs._validator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_LastCommitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastCommitInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "votes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.votes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_LastCommitInfo, rhs: Vendor_LastCommitInfo) -> Bool {
    if lhs.round != rhs.round {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_Version: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Version"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Block"),
    2: .same(proto: "App"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.block) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.app) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.block != 0 {
      try visitor.visitSingularUInt64Field(value: self.block, fieldNumber: 1)
    }
    if self.app != 0 {
      try visitor.visitSingularUInt64Field(value: self.app, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_Version, rhs: Vendor_Version) -> Bool {
    if lhs.block != rhs.block {return false}
    if lhs.app != rhs.app {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_BlockID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "parts_header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._partsHeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try { if let v = self._partsHeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_BlockID, rhs: Vendor_BlockID) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs._partsHeader != rhs._partsHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_PartSetHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartSetHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_PartSetHeader, rhs: Vendor_PartSetHeader) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Validator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    3: .same(proto: "power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.power) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.power != 0 {
      try visitor.visitSingularInt64Field(value: self.power, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_Validator, rhs: Vendor_Validator) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_ValidatorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pubKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.power) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pubKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.power != 0 {
      try visitor.visitSingularInt64Field(value: self.power, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_ValidatorUpdate, rhs: Vendor_ValidatorUpdate) -> Bool {
    if lhs._pubKey != rhs._pubKey {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_VoteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VoteInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    2: .standard(proto: "signed_last_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.signedLastBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.signedLastBlock != false {
      try visitor.visitSingularBoolField(value: self.signedLastBlock, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_VoteInfo, rhs: Vendor_VoteInfo) -> Bool {
    if lhs._validator != rhs._validator {return false}
    if lhs.signedLastBlock != rhs.signedLastBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_PubKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PubKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_PubKey, rhs: Vendor_PubKey) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_Evidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Evidence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "validator"),
    3: .same(proto: "height"),
    4: .same(proto: "time"),
    5: .standard(proto: "total_voting_power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalVotingPower) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.totalVotingPower != 0 {
      try visitor.visitSingularInt64Field(value: self.totalVotingPower, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_Evidence, rhs: Vendor_Evidence) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._validator != rhs._validator {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.totalVotingPower != rhs.totalVotingPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Header"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "chain_id"),
    3: .same(proto: "height"),
    4: .same(proto: "time"),
    5: .standard(proto: "num_txs"),
    6: .standard(proto: "total_txs"),
    7: .standard(proto: "last_block_id"),
    8: .standard(proto: "last_commit_hash"),
    9: .standard(proto: "data_hash"),
    10: .standard(proto: "validators_hash"),
    11: .standard(proto: "next_validators_hash"),
    12: .standard(proto: "consensus_hash"),
    13: .standard(proto: "app_hash"),
    14: .standard(proto: "last_results_hash"),
    15: .standard(proto: "evidence_hash"),
    16: .standard(proto: "proposer_address"),
  ]

  fileprivate class _StorageClass {
    var _version: Vendor_Version? = nil
    var _chainID: String = String()
    var _height: Int64 = 0
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _numTxs: Int64 = 0
    var _totalTxs: Int64 = 0
    var _lastBlockID: Vendor_BlockID? = nil
    var _lastCommitHash: Data = Data()
    var _dataHash: Data = Data()
    var _validatorsHash: Data = Data()
    var _nextValidatorsHash: Data = Data()
    var _consensusHash: Data = Data()
    var _appHash: Data = Data()
    var _lastResultsHash: Data = Data()
    var _evidenceHash: Data = Data()
    var _proposerAddress: Data = Data()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _chainID = source._chainID
      _height = source._height
      _time = source._time
      _numTxs = source._numTxs
      _totalTxs = source._totalTxs
      _lastBlockID = source._lastBlockID
      _lastCommitHash = source._lastCommitHash
      _dataHash = source._dataHash
      _validatorsHash = source._validatorsHash
      _nextValidatorsHash = source._nextValidatorsHash
      _consensusHash = source._consensusHash
      _appHash = source._appHash
      _lastResultsHash = source._lastResultsHash
      _evidenceHash = source._evidenceHash
      _proposerAddress = source._proposerAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._chainID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._height) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._numTxs) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._totalTxs) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._lastBlockID) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._lastCommitHash) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._dataHash) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._validatorsHash) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._nextValidatorsHash) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._consensusHash) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._appHash) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._lastResultsHash) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._evidenceHash) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._proposerAddress) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._chainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 2)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt64Field(value: _storage._height, fieldNumber: 3)
      }
      try { if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._numTxs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._numTxs, fieldNumber: 5)
      }
      if _storage._totalTxs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalTxs, fieldNumber: 6)
      }
      try { if let v = _storage._lastBlockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._lastCommitHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastCommitHash, fieldNumber: 8)
      }
      if !_storage._dataHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._dataHash, fieldNumber: 9)
      }
      if !_storage._validatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._validatorsHash, fieldNumber: 10)
      }
      if !_storage._nextValidatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nextValidatorsHash, fieldNumber: 11)
      }
      if !_storage._consensusHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._consensusHash, fieldNumber: 12)
      }
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 13)
      }
      if !_storage._lastResultsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastResultsHash, fieldNumber: 14)
      }
      if !_storage._evidenceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._evidenceHash, fieldNumber: 15)
      }
      if !_storage._proposerAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proposerAddress, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_Header, rhs: Vendor_Header) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._lastBlockID != rhs_storage._lastBlockID {return false}
        if _storage._lastCommitHash != rhs_storage._lastCommitHash {return false}
        if _storage._dataHash != rhs_storage._dataHash {return false}
        if _storage._validatorsHash != rhs_storage._validatorsHash {return false}
        if _storage._nextValidatorsHash != rhs_storage._nextValidatorsHash {return false}
        if _storage._consensusHash != rhs_storage._consensusHash {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._lastResultsHash != rhs_storage._lastResultsHash {return false}
        if _storage._evidenceHash != rhs_storage._evidenceHash {return false}
        if _storage._proposerAddress != rhs_storage._proposerAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_RequestBeginBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestBeginBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "header"),
    3: .standard(proto: "last_commit_info"),
    4: .standard(proto: "byzantine_validators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastCommitInfo) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.byzantineValidators) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastCommitInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.byzantineValidators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.byzantineValidators, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_RequestBeginBlock, rhs: Vendor_RequestBeginBlock) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs._header != rhs._header {return false}
    if lhs._lastCommitInfo != rhs._lastCommitInfo {return false}
    if lhs.byzantineValidators != rhs.byzantineValidators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Vendor_RequestEndBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestEndBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Vendor_RequestEndBlock, rhs: Vendor_RequestEndBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
