// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: asset.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Ocap_FactoryInputVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var description_p: String = String()

  public var required: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetFactoryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// how much primary token required to mint
  /// usually used to set a price for the NFT
  public var value: String = String()

  /// how much secondary tokens required to mint asset from this factory
  /// usually used to set a price for the NFT
  public var tokens: [Ocap_TokenInput] = []

  /// which asset(s) required to mint new nft
  /// can be either a list of specific assets or factories
  /// if specific assets are provided, we should ensure they are not consumed when creating the factory
  /// and then mark the input assets as consumed when minting success, in such case, this factory usage is limited
  /// if a factory is provided, we should ensure each input assets is not consumed and all minted from that factory on minting
  /// in such case, we can pipe factory to build very complex business logic
  /// optional, default to empty array
  public var assets: [String] = []

  /// variables that will be inserted into the output
  /// limitation: all variables should be strings
  public var variables: [Ocap_FactoryInputVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseFactoryInputToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var value: String = String()

  public var decimal: Int32 = 0

  public var unit: String = String()

  public var symbol: String = String()

  /// TODO: 这里是为了测试时兼容，应该删除
  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 和 AssetFactoryInput 数据结构类似，可以参考其注释
public struct Ocap_ResponseAssetFactoryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var tokens: [Ocap_ResponseFactoryInputToken] = []

  public var assets: [String] = []

  public var variables: [Ocap_FactoryInputVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetDisplay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be svg_gzipped, base64, url
  public var type: String = String()

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetIssuer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var pk: String = String()

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetFactoryHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be mint/postMint
  public var name: String = String()

  /// can be callback/contract
  public var type: String = String()

  public var hook: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Granted issuers can help users to mint new assets with predefined costs
public struct Ocap_AcquireAssetV2Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the asset factory
  public var factory: String = String()

  /// address of the minted asset
  /// must be calculated on client side to make things deterministic
  public var address: String = String()

  /// assets to consume to mint new asset
  /// should be a list of specific asset (not factory)
  /// each asset will be checked for consumption before minting
  /// and marked as consumed when minting success
  public var assets: [String] = []

  /// template variables, should all be strings
  /// this list should contain all required variables to populate the factory output template
  public var variables: [Ocap_FactoryInputVariable] = []

  /// issuer info to mint the asset
  /// TODO: enforce issuer in acquire/mint asset protocol
  public var issuer: Ocap_AssetIssuer {
    get {return _issuer ?? Ocap_AssetIssuer()}
    set {_issuer = newValue}
  }
  /// Returns true if `issuer` has been explicitly set.
  public var hasIssuer: Bool {return self._issuer != nil}
  /// Clears the value of `issuer`. Subsequent reads from it will return its default value.
  public mutating func clearIssuer() {self._issuer = nil}

  /// ocap won't touch this field. Only app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _issuer: Ocap_AssetIssuer? = nil
  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Ocap_AcquireAssetV3Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the asset factory
  public var factory: String = String()

  /// address of the minted asset
  /// must be calculated on client side to make things deterministic
  public var address: String = String()

  /// Who pays for this acquire
  public var inputs: [Ocap_TransactionInput] = []

  /// Who gets the minted asset
  public var owner: String = String()

  /// template variables, should all be strings
  /// this list should contain all required variables to populate the factory output template
  public var variables: [Ocap_FactoryInputVariable] = []

  /// issuer info to mint the asset
  /// TODO: enforce issuer in acquire/mint asset protocol
  public var issuer: Ocap_AssetIssuer {
    get {return _issuer ?? Ocap_AssetIssuer()}
    set {_issuer = newValue}
  }
  /// Returns true if `issuer` has been explicitly set.
  public var hasIssuer: Bool {return self._issuer != nil}
  /// Clears the value of `issuer`. Subsequent reads from it will return its default value.
  public mutating func clearIssuer() {self._issuer = nil}

  /// ocap won't touch this field. Only app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _issuer: Ocap_AssetIssuer? = nil
  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// The factory owner can mint new assets without any cost
public struct Ocap_MintAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the asset factory
  public var factory: String = String()

  /// address of the minted asset
  /// must be calculated on client side to make things deterministic
  public var address: String = String()

  /// assets to consume to mint new asset
  /// should be a list of specific asset (not factory)
  /// each asset will be checked for consumption before minting
  /// and marked as consumed when minting success
  public var assets: [String] = []

  /// template variables
  public var variables: [Ocap_FactoryInputVariable] = []

  /// owner of the minted asset
  public var owner: String = String()

  /// ocap won't touch this field. Only app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Ocap_AssetSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the generated asset. The sender shall apply the spec to the
  /// template to generate a structure of the asset, and then generate the
  /// CreateAssetTx, and then calculate the address. SDK could help to alleviate
  /// the process.
  public var address: String = String()

  /// json string that contains args for the asset factory template
  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: deprecated this
public struct Ocap_AcquireAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the asset factory
  public var to: String = String()

  /// asset spec
  public var specs: [Ocap_AssetSpec] = []

  /// forge won't touch this field. Only forge app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// TODO: deprecated this
public struct Ocap_ConsumeAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `issuer` could be the same as `from`, or different, depending on use case.
  /// when this tx is being mutisigned by the asset holder, the wallet could
  /// check if the issuer is the issuer of the asset, otherwise wallet shall
  /// refuse signing it. when it goes into the chain, at verify state stage, we
  /// shall check `from` of this tx:
  ///  a. the same as the issuer
  ///  b. `from.issuer == issuer`
  /// For example, a museum issued a ticket and Alice bought it. At the
  /// door (doorman) of the meseum, Alice need to consume the asset, which she
  /// scan a QR code with a prepolulated ConsumeAssetTx. Most of the time, this
  /// prepopulated tx shall be signed by the account of the door (doorman) so
  /// that we can trace where and how Alice consumed this asset, however we don't
  /// want anyone to be able to create this tx to allure Alice to consume the
  /// asset, thus the door (doorman) shall be an account that issued by the
  /// museum. The chain will make sure only accounts that has this issuer would
  /// be able to successfully sign this tx.
  public var issuer: String = String()

  /// an asset might belong to another asset, for example a ticket belongs to a
  /// specific concert or movie asset. If this is provided, besides issuer we
  /// will verify if the parent address of the asset equals to this address.
  public var address: String = String()

  /// ocap won't update data into state if app is interested in this tx.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Ocap_CreateAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var moniker: String = String()

  /// ocap won't update data into state if app is interested in this tx.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var readonly: Bool = false

  public var transferrable: Bool = false

  /// ttl for the asset after first consumption. 0 means unlimited.
  public var ttl: UInt32 = 0

  public var parent: String = String()

  public var address: String = String()

  public var issuer: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Ocap_UpdateAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var moniker: String = String()

  /// ocap won't update data into state if app is interested in this tx.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// An asset factory is readonly by default
/// Thus any change to the factory result a new factory
public struct Ocap_CreateFactoryTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// If the input requires some tokens, how are they settled?
  /// Currently we only support instant settlement
  /// In future we may consider periodic settlement
  public var settlement: String {
    get {return _storage._settlement}
    set {_uniqueStorage()._settlement = newValue}
  }

  /// total assets can mint from this factory, set to 0 to allow infinite minting
  public var limit: UInt32 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  /// who can mint assets from this factory
  /// default to empty, which only the factory owner can mint assets from
  /// If set to ["*"], then anyone can mint from this factory
  public var trustedIssuers: [String] {
    get {return _storage._trustedIssuers}
    set {_uniqueStorage()._trustedIssuers = newValue}
  }

  /// input params to mint new asset, can be any combination of tokens + assets
  public var input: Ocap_AssetFactoryInput {
    get {return _storage._input ?? Ocap_AssetFactoryInput()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  /// the template that asset factory will use to generate the asset
  /// the output must be the same structure as `CreateAssetTx`
  /// from which we can derive the asset address from
  /// the output object can contain template variable placeholders to populate
  public var output: Ocap_CreateAssetTx {
    get {return _storage._output ?? Ocap_CreateAssetTx()}
    set {_uniqueStorage()._output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return _storage._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {_uniqueStorage()._output = nil}

  /// hooks called when new assets minted
  public var hooks: [Ocap_AssetFactoryHook] {
    get {return _storage._hooks}
    set {_uniqueStorage()._hooks = newValue}
  }

  /// address for the factory
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// how the nft factory will look like
  public var display: Ocap_AssetDisplay {
    get {return _storage._display ?? Ocap_AssetDisplay()}
    set {_uniqueStorage()._display = newValue}
  }
  /// Returns true if `display` has been explicitly set.
  public var hasDisplay: Bool {return _storage._display != nil}
  /// Clears the value of `display`. Subsequent reads from it will return its default value.
  public mutating func clearDisplay() {_uniqueStorage()._display = nil}

  /// extra content that can populate into the output object when minting
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_FactoryInputVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FactoryInputVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "description"),
    4: .same(proto: "required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_FactoryInputVariable, rhs: Ocap_FactoryInputVariable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.required != rhs.required {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFactoryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFactoryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "tokens"),
    3: .same(proto: "assets"),
    4: .same(proto: "variables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 3)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFactoryInput, rhs: Ocap_AssetFactoryInput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseFactoryInputToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseFactoryInputToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "value"),
    3: .same(proto: "decimal"),
    4: .same(proto: "unit"),
    5: .same(proto: "symbol"),
    10: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.decimal) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.decimal != 0 {
      try visitor.visitSingularInt32Field(value: self.decimal, fieldNumber: 3)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 4)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 5)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseFactoryInputToken, rhs: Ocap_ResponseFactoryInputToken) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.value != rhs.value {return false}
    if lhs.decimal != rhs.decimal {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseAssetFactoryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseAssetFactoryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "tokens"),
    3: .same(proto: "assets"),
    4: .same(proto: "variables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 3)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseAssetFactoryInput, rhs: Ocap_ResponseAssetFactoryInput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetDisplay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetDisplay, rhs: Ocap_AssetDisplay) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetIssuer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetIssuer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "pk"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularStringField(value: self.pk, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetIssuer, rhs: Ocap_AssetIssuer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFactoryHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFactoryHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "hook"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hook) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.hook.isEmpty {
      try visitor.visitSingularStringField(value: self.hook, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFactoryHook, rhs: Ocap_AssetFactoryHook) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.hook != rhs.hook {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AcquireAssetV2Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcquireAssetV2Tx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "factory"),
    2: .same(proto: "address"),
    3: .same(proto: "assets"),
    4: .same(proto: "variables"),
    5: .same(proto: "issuer"),
    15: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.factory) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._issuer) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.factory.isEmpty {
      try visitor.visitSingularStringField(value: self.factory, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 3)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 4)
    }
    if let v = self._issuer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AcquireAssetV2Tx, rhs: Ocap_AcquireAssetV2Tx) -> Bool {
    if lhs.factory != rhs.factory {return false}
    if lhs.address != rhs.address {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs._issuer != rhs._issuer {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AcquireAssetV3Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcquireAssetV3Tx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "factory"),
    2: .same(proto: "address"),
    3: .same(proto: "inputs"),
    4: .same(proto: "owner"),
    5: .same(proto: "variables"),
    6: .same(proto: "issuer"),
    15: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.factory) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._issuer) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.factory.isEmpty {
      try visitor.visitSingularStringField(value: self.factory, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 3)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 4)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 5)
    }
    if let v = self._issuer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AcquireAssetV3Tx, rhs: Ocap_AcquireAssetV3Tx) -> Bool {
    if lhs.factory != rhs.factory {return false}
    if lhs.address != rhs.address {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs._issuer != rhs._issuer {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_MintAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MintAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "factory"),
    2: .same(proto: "address"),
    3: .same(proto: "assets"),
    4: .same(proto: "variables"),
    5: .same(proto: "owner"),
    15: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.factory) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.factory.isEmpty {
      try visitor.visitSingularStringField(value: self.factory, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 3)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 4)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 5)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_MintAssetTx, rhs: Ocap_MintAssetTx) -> Bool {
    if lhs.factory != rhs.factory {return false}
    if lhs.address != rhs.address {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetSpec, rhs: Ocap_AssetSpec) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AcquireAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcquireAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "specs"),
    15: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.to) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.specs) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 1)
    }
    if !self.specs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.specs, fieldNumber: 2)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AcquireAssetTx, rhs: Ocap_AcquireAssetTx) -> Bool {
    if lhs.to != rhs.to {return false}
    if lhs.specs != rhs.specs {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ConsumeAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsumeAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .same(proto: "address"),
    15: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ConsumeAssetTx, rhs: Ocap_ConsumeAssetTx) -> Bool {
    if lhs.issuer != rhs.issuer {return false}
    if lhs.address != rhs.address {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_CreateAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moniker"),
    2: .same(proto: "data"),
    3: .same(proto: "readonly"),
    4: .same(proto: "transferrable"),
    5: .same(proto: "ttl"),
    6: .same(proto: "parent"),
    7: .same(proto: "address"),
    8: .same(proto: "issuer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.moniker) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.readonly) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.transferrable) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.readonly != false {
      try visitor.visitSingularBoolField(value: self.readonly, fieldNumber: 3)
    }
    if self.transferrable != false {
      try visitor.visitSingularBoolField(value: self.transferrable, fieldNumber: 4)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 5)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 6)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 7)
    }
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_CreateAssetTx, rhs: Ocap_CreateAssetTx) -> Bool {
    if lhs.moniker != rhs.moniker {return false}
    if lhs._data != rhs._data {return false}
    if lhs.readonly != rhs.readonly {return false}
    if lhs.transferrable != rhs.transferrable {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.address != rhs.address {return false}
    if lhs.issuer != rhs.issuer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UpdateAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "moniker"),
    15: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moniker) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 2)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UpdateAssetTx, rhs: Ocap_UpdateAssetTx) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.moniker != rhs.moniker {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_CreateFactoryTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFactoryTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "settlement"),
    4: .same(proto: "limit"),
    5: .standard(proto: "trusted_issuers"),
    6: .same(proto: "input"),
    7: .same(proto: "output"),
    8: .same(proto: "hooks"),
    9: .same(proto: "address"),
    10: .same(proto: "display"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _settlement: String = String()
    var _limit: UInt32 = 0
    var _trustedIssuers: [String] = []
    var _input: Ocap_AssetFactoryInput? = nil
    var _output: Ocap_CreateAssetTx? = nil
    var _hooks: [Ocap_AssetFactoryHook] = []
    var _address: String = String()
    var _display: Ocap_AssetDisplay? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _settlement = source._settlement
      _limit = source._limit
      _trustedIssuers = source._trustedIssuers
      _input = source._input
      _output = source._output
      _hooks = source._hooks
      _address = source._address
      _display = source._display
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._settlement) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._limit) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._trustedIssuers) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._output) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._hooks) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._display) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._settlement.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlement, fieldNumber: 3)
      }
      if _storage._limit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._limit, fieldNumber: 4)
      }
      if !_storage._trustedIssuers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._trustedIssuers, fieldNumber: 5)
      }
      if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._output {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._hooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hooks, fieldNumber: 8)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 9)
      }
      if let v = _storage._display {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_CreateFactoryTx, rhs: Ocap_CreateFactoryTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._settlement != rhs_storage._settlement {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._trustedIssuers != rhs_storage._trustedIssuers {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._hooks != rhs_storage._hooks {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._display != rhs_storage._display {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
