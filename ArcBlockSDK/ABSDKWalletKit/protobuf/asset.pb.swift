// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: asset.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Ocap_FactoryInputToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_FactoryInputVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var description_p: String = String()

  public var required: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetFactoryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// how much primary token required to mint
  /// usually used to set a price for the NFT
  public var value: String = String()

  /// how much secondary tokens required to mint asset from this factory
  /// usually used to set a price for the NFT
  public var tokens: [Ocap_FactoryInputToken] = []

  /// which asset(s) required to mint new nft
  /// can be either a list of specific assets or a factory
  /// if specific assets are provided, we should ensure they are not consumed when creating the factory
  /// and then mark the input assets as consumed when minting success, in such case, this factory usage is limited
  /// if a factory is provided, we should ensure each input assets is not consumed and all minted from that factory on minting
  /// in such case, we can pipe factory to build very complex business logic
  /// optional, default to empty array
  public var assets: [String] = []

  /// variables that will be inserted into the output
  /// limitation: all variables should be strings
  public var variables: [Ocap_FactoryInputVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetDisplay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be svg_gzipped, base64, url
  public var type: String = String()

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetIssuer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var pk: String = String()

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetFactoryHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be mint/postMint
  public var name: String = String()

  /// can be callback/contract
  public var type: String = String()

  public var hook: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// FIXME: this transaction should be a multisign transaction to improve security
/// Granted issuers can help users to mint new assets with predefined costs
public struct Ocap_AcquireAssetV2Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the asset factory
  public var factory: String {
    get {return _storage._factory}
    set {_uniqueStorage()._factory = newValue}
  }

  /// address of the minted asset
  /// must be calculated on client side to make things deterministic
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// assets to burn to mint new asset
  /// should be a list of specific asset (not factory)
  /// each asset will be checked for consumption before minting
  /// and marked as consumed when minting success
  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  /// template variables, should all be strings
  /// this list should contain all required variables to populate the factory output template
  public var variables: [Ocap_FactoryInputVariable] {
    get {return _storage._variables}
    set {_uniqueStorage()._variables = newValue}
  }

  /// issuer info to mint the asset
  public var issuer: Ocap_AssetIssuer {
    get {return _storage._issuer ?? Ocap_AssetIssuer()}
    set {_uniqueStorage()._issuer = newValue}
  }
  /// Returns true if `issuer` has been explicitly set.
  public var hasIssuer: Bool {return _storage._issuer != nil}
  /// Clears the value of `issuer`. Subsequent reads from it will return its default value.
  public mutating func clearIssuer() {_uniqueStorage()._issuer = nil}

  /// ocap won't touch this field. Only app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The factory owner can mint new assets without any cost
public struct Ocap_MintAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the asset factory
  public var factory: String {
    get {return _storage._factory}
    set {_uniqueStorage()._factory = newValue}
  }

  /// address of the minted asset
  /// must be calculated on client side to make things deterministic
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// assets to burn to mint new asset
  /// should be a list of specific asset (not factory)
  /// each asset will be checked for consumption before minting
  /// and marked as consumed when minting success
  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  /// template variables
  public var variables: [Ocap_FactoryInputVariable] {
    get {return _storage._variables}
    set {_uniqueStorage()._variables = newValue}
  }

  /// owner of the minted asset
  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  /// ocap won't touch this field. Only app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_AssetSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the generated asset. The sender shall apply the spec to the
  /// template to generate a structure of the asset, and then generate the
  /// CreateAssetTx, and then calculate the address. SDK could help to alleviate
  /// the process.
  public var address: String = String()

  /// json string that contains args for the asset factory template
  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: deprecated this
public struct Ocap_AcquireAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the address of the asset factory
  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  /// asset spec
  public var specs: [Ocap_AssetSpec] {
    get {return _storage._specs}
    set {_uniqueStorage()._specs = newValue}
  }

  /// forge won't touch this field. Only forge app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TODO: deprecated this
public struct Ocap_ConsumeAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `issuer` could be the same as `from`, or different, depending on use case.
  /// when this tx is being mutisigned by the asset holder, the wallet could
  /// check if the issuer is the issuer of the asset, otherwise wallet shall
  /// refuse signing it. when it goes into the chain, at verify state stage, we
  /// shall check `from` of this tx:
  ///  a. the same as the issuer
  ///  b. `from.issuer == issuer`
  /// For example, a museum issued a ticket and Alice bought it. At the
  /// door (doorman) of the meseum, Alice need to consume the asset, which she
  /// scan a QR code with a prepolulated ConsumeAssetTx. Most of the time, this
  /// prepopulated tx shall be signed by the account of the door (doorman) so
  /// that we can trace where and how Alice consumed this asset, however we don't
  /// want anyone to be able to create this tx to allure Alice to consume the
  /// asset, thus the door (doorman) shall be an account that issued by the
  /// museum. The chain will make sure only accounts that has this issuer would
  /// be able to successfully sign this tx.
  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  /// an asset might belong to another asset, for example a ticket belongs to a
  /// specific concert or movie asset. If this is provided, besides issuer we
  /// will verify if the parent address of the asset equals to this address.
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// ocap won't update data into state if app is interested in this tx.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_CreateAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  /// ocap won't update data into state if app is interested in this tx.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var readonly: Bool {
    get {return _storage._readonly}
    set {_uniqueStorage()._readonly = newValue}
  }

  public var transferrable: Bool {
    get {return _storage._transferrable}
    set {_uniqueStorage()._transferrable = newValue}
  }

  /// ttl for the asset after first consumption. 0 means unlimited.
  public var ttl: UInt32 {
    get {return _storage._ttl}
    set {_uniqueStorage()._ttl = newValue}
  }

  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_UpdateAssetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  /// ocap won't update data into state if app is interested in this tx.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_AssetFactory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name of the asset factory
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// description of the asset factory
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// If the input requires some tokens, how are they settled?
  /// Currently we only support instant settlement
  /// In future we may consider periodic settlement
  public var settlement: String {
    get {return _storage._settlement}
    set {_uniqueStorage()._settlement = newValue}
  }

  /// total assets can mint from this factory, set to 0 to allow infinite minting
  public var limit: UInt32 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  /// who can mint assets from this factory
  /// default to empty, which only the factory owner can mint assets from
  /// If set to ["*"], then anyone can mint from this factory
  public var trustedIssuers: [String] {
    get {return _storage._trustedIssuers}
    set {_uniqueStorage()._trustedIssuers = newValue}
  }

  /// input params to mint new asset, check out `AssetFactoryOutput` for sub fields
  public var input: Ocap_AssetFactoryInput {
    get {return _storage._input ?? Ocap_AssetFactoryInput()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  /// the template that asset factory will use to generate the asset
  /// the output must be the same structure as `CreateAssetTx`
  /// from which we can derive the asset address from
  /// the output object can contain template variable placeholders to populate
  public var output: Ocap_CreateAssetTx {
    get {return _storage._output ?? Ocap_CreateAssetTx()}
    set {_uniqueStorage()._output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return _storage._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {_uniqueStorage()._output = nil}

  /// how the nft factory will look like
  public var hooks: [Ocap_AssetFactoryHook] {
    get {return _storage._hooks}
    set {_uniqueStorage()._hooks = newValue}
  }

  /// extra content that can populate into the output object when minting
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_FactoryInputToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FactoryInputToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_FactoryInputToken, rhs: Ocap_FactoryInputToken) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_FactoryInputVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FactoryInputVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "description"),
    4: .same(proto: "required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeSingularBoolField(value: &self.required)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_FactoryInputVariable, rhs: Ocap_FactoryInputVariable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.required != rhs.required {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFactoryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFactoryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "tokens"),
    3: .same(proto: "assets"),
    4: .same(proto: "variables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.value)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.tokens)
      case 3: try decoder.decodeRepeatedStringField(value: &self.assets)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.variables)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 3)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFactoryInput, rhs: Ocap_AssetFactoryInput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetDisplay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.content)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetDisplay, rhs: Ocap_AssetDisplay) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetIssuer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetIssuer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "pk"),
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.pk)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.pk.isEmpty {
      try visitor.visitSingularStringField(value: self.pk, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetIssuer, rhs: Ocap_AssetIssuer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.pk != rhs.pk {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFactoryHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFactoryHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "hook"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.type)
      case 3: try decoder.decodeSingularStringField(value: &self.hook)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.hook.isEmpty {
      try visitor.visitSingularStringField(value: self.hook, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFactoryHook, rhs: Ocap_AssetFactoryHook) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.hook != rhs.hook {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AcquireAssetV2Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcquireAssetV2Tx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "factory"),
    2: .same(proto: "address"),
    3: .same(proto: "assets"),
    4: .same(proto: "variables"),
    5: .same(proto: "issuer"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _factory: String = String()
    var _address: String = String()
    var _assets: [String] = []
    var _variables: [Ocap_FactoryInputVariable] = []
    var _issuer: Ocap_AssetIssuer? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _factory = source._factory
      _address = source._address
      _assets = source._assets
      _variables = source._variables
      _issuer = source._issuer
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._factory)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._variables)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._issuer)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._factory.isEmpty {
        try visitor.visitSingularStringField(value: _storage._factory, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 3)
      }
      if !_storage._variables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._variables, fieldNumber: 4)
      }
      if let v = _storage._issuer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AcquireAssetV2Tx, rhs: Ocap_AcquireAssetV2Tx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._factory != rhs_storage._factory {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._variables != rhs_storage._variables {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_MintAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MintAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "factory"),
    2: .same(proto: "address"),
    3: .same(proto: "assets"),
    4: .same(proto: "variables"),
    5: .same(proto: "owner"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _factory: String = String()
    var _address: String = String()
    var _assets: [String] = []
    var _variables: [Ocap_FactoryInputVariable] = []
    var _owner: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _factory = source._factory
      _address = source._address
      _assets = source._assets
      _variables = source._variables
      _owner = source._owner
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._factory)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._variables)
        case 5: try decoder.decodeSingularStringField(value: &_storage._owner)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._factory.isEmpty {
        try visitor.visitSingularStringField(value: _storage._factory, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 3)
      }
      if !_storage._variables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._variables, fieldNumber: 4)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 5)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_MintAssetTx, rhs: Ocap_MintAssetTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._factory != rhs_storage._factory {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._variables != rhs_storage._variables {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularStringField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetSpec, rhs: Ocap_AssetSpec) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AcquireAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcquireAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "specs"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _to: String = String()
    var _specs: [Ocap_AssetSpec] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _to = source._to
      _specs = source._specs
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._to)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._specs)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 1)
      }
      if !_storage._specs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._specs, fieldNumber: 2)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AcquireAssetTx, rhs: Ocap_AcquireAssetTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._to != rhs_storage._to {return false}
        if _storage._specs != rhs_storage._specs {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ConsumeAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsumeAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .same(proto: "address"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _issuer: String = String()
    var _address: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _issuer = source._issuer
      _address = source._address
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ConsumeAssetTx, rhs: Ocap_ConsumeAssetTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_CreateAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moniker"),
    2: .same(proto: "data"),
    3: .same(proto: "readonly"),
    4: .same(proto: "transferrable"),
    5: .same(proto: "ttl"),
    6: .same(proto: "parent"),
    7: .same(proto: "address"),
    8: .same(proto: "issuer"),
  ]

  fileprivate class _StorageClass {
    var _moniker: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _readonly: Bool = false
    var _transferrable: Bool = false
    var _ttl: UInt32 = 0
    var _parent: String = String()
    var _address: String = String()
    var _issuer: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _moniker = source._moniker
      _data = source._data
      _readonly = source._readonly
      _transferrable = source._transferrable
      _ttl = source._ttl
      _parent = source._parent
      _address = source._address
      _issuer = source._issuer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._readonly)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._transferrable)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._ttl)
        case 6: try decoder.decodeSingularStringField(value: &_storage._parent)
        case 7: try decoder.decodeSingularStringField(value: &_storage._address)
        case 8: try decoder.decodeSingularStringField(value: &_storage._issuer)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._readonly != false {
        try visitor.visitSingularBoolField(value: _storage._readonly, fieldNumber: 3)
      }
      if _storage._transferrable != false {
        try visitor.visitSingularBoolField(value: _storage._transferrable, fieldNumber: 4)
      }
      if _storage._ttl != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ttl, fieldNumber: 5)
      }
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 6)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 7)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_CreateAssetTx, rhs: Ocap_CreateAssetTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._readonly != rhs_storage._readonly {return false}
        if _storage._transferrable != rhs_storage._transferrable {return false}
        if _storage._ttl != rhs_storage._ttl {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UpdateAssetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAssetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "moniker"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _moniker: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _moniker = source._moniker
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 2)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UpdateAssetTx, rhs: Ocap_UpdateAssetTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFactory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFactory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "settlement"),
    4: .same(proto: "limit"),
    5: .standard(proto: "trusted_issuers"),
    6: .same(proto: "input"),
    7: .same(proto: "output"),
    8: .same(proto: "hooks"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _settlement: String = String()
    var _limit: UInt32 = 0
    var _trustedIssuers: [String] = []
    var _input: Ocap_AssetFactoryInput? = nil
    var _output: Ocap_CreateAssetTx? = nil
    var _hooks: [Ocap_AssetFactoryHook] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _settlement = source._settlement
      _limit = source._limit
      _trustedIssuers = source._trustedIssuers
      _input = source._input
      _output = source._output
      _hooks = source._hooks
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 3: try decoder.decodeSingularStringField(value: &_storage._settlement)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._limit)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._trustedIssuers)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._input)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._output)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._hooks)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._settlement.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlement, fieldNumber: 3)
      }
      if _storage._limit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._limit, fieldNumber: 4)
      }
      if !_storage._trustedIssuers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._trustedIssuers, fieldNumber: 5)
      }
      if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._output {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._hooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hooks, fieldNumber: 8)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFactory, rhs: Ocap_AssetFactory) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._settlement != rhs_storage._settlement {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._trustedIssuers != rhs_storage._trustedIssuers {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._hooks != rhs_storage._hooks {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
