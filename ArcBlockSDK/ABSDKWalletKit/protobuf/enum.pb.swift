// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: enum.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Ocap_StatusCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ok // = 0

  /// COMMON CODE
  /// 1 - 15
  case invalidNonce // = 1
  case invalidSignature // = 2
  case invalidSenderState // = 3
  case invalidReceiverState // = 4
  case insufficientData // = 5
  case insufficientFund // = 6
  case invalidOwner // = 7
  case invalidTx // = 8
  case unsupportedTx // = 9
  case expiredTx // = 10
  case tooManyTxs // = 11
  case invalidLockStatus // = 12
  case invalidRequest // = 13

  /// 16 - 2047 VARIOUS ERRORS
  case invalidMoniker // = 16
  case invalidPassphrase // = 17
  case invalidMultisig // = 20
  case invalidWallet // = 21
  case invalidChainID // = 22
  case consensusRpcError // = 24
  case storageRpcError // = 25
  case noent // = 26
  case accountMigrated // = 27
  case rpcConnectionError // = 28
  case unsupportedStake // = 30
  case insufficientStake // = 31
  case invalidStakeState // = 32
  case expiredWalletToken // = 33
  case bannedUnstake // = 34
  case invalidAsset // = 35
  case invalidTxSize // = 36
  case invalidSignerState // = 37
  case invalidForgeState // = 38
  case expiredAsset // = 39
  case untransferrableAsset // = 40
  case readonlyAsset // = 41
  case consumedAsset // = 42
  case invalidDepositValue // = 43
  case exceedDepositCap // = 44
  case invalidDepositTarget // = 45
  case invalidDepositor // = 46
  case invalidWithdrawer // = 47

  /// DUPLICATE_TETHER = 48;
  case invalidExpiryDate // = 49

  /// INVALID_DEPOSIT = 50;
  case invalidCustodian // = 51
  case insufficientGas // = 52
  case invalidSwap // = 53
  case invalidHashkey // = 54
  case invalidDelegation // = 55
  case insufficientDelegation // = 56
  case invalidDelegationRule // = 57
  case invalidDelegationTypeURL // = 58
  case senderNotAuthorized // = 59
  case protocolNotRunning // = 60
  case protocolNotPaused // = 61
  case protocolNotActivated // = 62
  case invalidDeactivation // = 63
  case senderWithdrawItemsFull // = 64
  case withdrawItemMissing // = 65
  case invalidWithdrawTx // = 66
  case invalidChainType // = 67
  case invalidTime // = 68
  case invalidSubscribe // = 69
  case invalidDidType // = 70
  case invalidCandidateState // = 71
  case validatorNotFound // = 72
  case validatorNotChanged // = 73
  case invalidFactoryState // = 74
  case invalidFactoryProps // = 75
  case invalidFactoryInput // = 76
  case invalidToken // = 77
  case forbidden // = 403
  case `internal` // = 500
  case timeout // = 504
  case UNRECOGNIZED(Int)

  public init() {
    self = .ok
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .invalidNonce
    case 2: self = .invalidSignature
    case 3: self = .invalidSenderState
    case 4: self = .invalidReceiverState
    case 5: self = .insufficientData
    case 6: self = .insufficientFund
    case 7: self = .invalidOwner
    case 8: self = .invalidTx
    case 9: self = .unsupportedTx
    case 10: self = .expiredTx
    case 11: self = .tooManyTxs
    case 12: self = .invalidLockStatus
    case 13: self = .invalidRequest
    case 16: self = .invalidMoniker
    case 17: self = .invalidPassphrase
    case 20: self = .invalidMultisig
    case 21: self = .invalidWallet
    case 22: self = .invalidChainID
    case 24: self = .consensusRpcError
    case 25: self = .storageRpcError
    case 26: self = .noent
    case 27: self = .accountMigrated
    case 28: self = .rpcConnectionError
    case 30: self = .unsupportedStake
    case 31: self = .insufficientStake
    case 32: self = .invalidStakeState
    case 33: self = .expiredWalletToken
    case 34: self = .bannedUnstake
    case 35: self = .invalidAsset
    case 36: self = .invalidTxSize
    case 37: self = .invalidSignerState
    case 38: self = .invalidForgeState
    case 39: self = .expiredAsset
    case 40: self = .untransferrableAsset
    case 41: self = .readonlyAsset
    case 42: self = .consumedAsset
    case 43: self = .invalidDepositValue
    case 44: self = .exceedDepositCap
    case 45: self = .invalidDepositTarget
    case 46: self = .invalidDepositor
    case 47: self = .invalidWithdrawer
    case 49: self = .invalidExpiryDate
    case 51: self = .invalidCustodian
    case 52: self = .insufficientGas
    case 53: self = .invalidSwap
    case 54: self = .invalidHashkey
    case 55: self = .invalidDelegation
    case 56: self = .insufficientDelegation
    case 57: self = .invalidDelegationRule
    case 58: self = .invalidDelegationTypeURL
    case 59: self = .senderNotAuthorized
    case 60: self = .protocolNotRunning
    case 61: self = .protocolNotPaused
    case 62: self = .protocolNotActivated
    case 63: self = .invalidDeactivation
    case 64: self = .senderWithdrawItemsFull
    case 65: self = .withdrawItemMissing
    case 66: self = .invalidWithdrawTx
    case 67: self = .invalidChainType
    case 68: self = .invalidTime
    case 69: self = .invalidSubscribe
    case 70: self = .invalidDidType
    case 71: self = .invalidCandidateState
    case 72: self = .validatorNotFound
    case 73: self = .validatorNotChanged
    case 74: self = .invalidFactoryState
    case 75: self = .invalidFactoryProps
    case 76: self = .invalidFactoryInput
    case 77: self = .invalidToken
    case 403: self = .forbidden
    case 500: self = .internal
    case 504: self = .timeout
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ok: return 0
    case .invalidNonce: return 1
    case .invalidSignature: return 2
    case .invalidSenderState: return 3
    case .invalidReceiverState: return 4
    case .insufficientData: return 5
    case .insufficientFund: return 6
    case .invalidOwner: return 7
    case .invalidTx: return 8
    case .unsupportedTx: return 9
    case .expiredTx: return 10
    case .tooManyTxs: return 11
    case .invalidLockStatus: return 12
    case .invalidRequest: return 13
    case .invalidMoniker: return 16
    case .invalidPassphrase: return 17
    case .invalidMultisig: return 20
    case .invalidWallet: return 21
    case .invalidChainID: return 22
    case .consensusRpcError: return 24
    case .storageRpcError: return 25
    case .noent: return 26
    case .accountMigrated: return 27
    case .rpcConnectionError: return 28
    case .unsupportedStake: return 30
    case .insufficientStake: return 31
    case .invalidStakeState: return 32
    case .expiredWalletToken: return 33
    case .bannedUnstake: return 34
    case .invalidAsset: return 35
    case .invalidTxSize: return 36
    case .invalidSignerState: return 37
    case .invalidForgeState: return 38
    case .expiredAsset: return 39
    case .untransferrableAsset: return 40
    case .readonlyAsset: return 41
    case .consumedAsset: return 42
    case .invalidDepositValue: return 43
    case .exceedDepositCap: return 44
    case .invalidDepositTarget: return 45
    case .invalidDepositor: return 46
    case .invalidWithdrawer: return 47
    case .invalidExpiryDate: return 49
    case .invalidCustodian: return 51
    case .insufficientGas: return 52
    case .invalidSwap: return 53
    case .invalidHashkey: return 54
    case .invalidDelegation: return 55
    case .insufficientDelegation: return 56
    case .invalidDelegationRule: return 57
    case .invalidDelegationTypeURL: return 58
    case .senderNotAuthorized: return 59
    case .protocolNotRunning: return 60
    case .protocolNotPaused: return 61
    case .protocolNotActivated: return 62
    case .invalidDeactivation: return 63
    case .senderWithdrawItemsFull: return 64
    case .withdrawItemMissing: return 65
    case .invalidWithdrawTx: return 66
    case .invalidChainType: return 67
    case .invalidTime: return 68
    case .invalidSubscribe: return 69
    case .invalidDidType: return 70
    case .invalidCandidateState: return 71
    case .validatorNotFound: return 72
    case .validatorNotChanged: return 73
    case .invalidFactoryState: return 74
    case .invalidFactoryProps: return 75
    case .invalidFactoryInput: return 76
    case .invalidToken: return 77
    case .forbidden: return 403
    case .internal: return 500
    case .timeout: return 504
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_StatusCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_StatusCode] = [
    .ok,
    .invalidNonce,
    .invalidSignature,
    .invalidSenderState,
    .invalidReceiverState,
    .insufficientData,
    .insufficientFund,
    .invalidOwner,
    .invalidTx,
    .unsupportedTx,
    .expiredTx,
    .tooManyTxs,
    .invalidLockStatus,
    .invalidRequest,
    .invalidMoniker,
    .invalidPassphrase,
    .invalidMultisig,
    .invalidWallet,
    .invalidChainID,
    .consensusRpcError,
    .storageRpcError,
    .noent,
    .accountMigrated,
    .rpcConnectionError,
    .unsupportedStake,
    .insufficientStake,
    .invalidStakeState,
    .expiredWalletToken,
    .bannedUnstake,
    .invalidAsset,
    .invalidTxSize,
    .invalidSignerState,
    .invalidForgeState,
    .expiredAsset,
    .untransferrableAsset,
    .readonlyAsset,
    .consumedAsset,
    .invalidDepositValue,
    .exceedDepositCap,
    .invalidDepositTarget,
    .invalidDepositor,
    .invalidWithdrawer,
    .invalidExpiryDate,
    .invalidCustodian,
    .insufficientGas,
    .invalidSwap,
    .invalidHashkey,
    .invalidDelegation,
    .insufficientDelegation,
    .invalidDelegationRule,
    .invalidDelegationTypeURL,
    .senderNotAuthorized,
    .protocolNotRunning,
    .protocolNotPaused,
    .protocolNotActivated,
    .invalidDeactivation,
    .senderWithdrawItemsFull,
    .withdrawItemMissing,
    .invalidWithdrawTx,
    .invalidChainType,
    .invalidTime,
    .invalidSubscribe,
    .invalidDidType,
    .invalidCandidateState,
    .validatorNotFound,
    .validatorNotChanged,
    .invalidFactoryState,
    .invalidFactoryProps,
    .invalidFactoryInput,
    .invalidToken,
    .forbidden,
    .internal,
    .timeout,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_KeyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ed25519 // = 0
  case secp256K1 // = 1
  case ethereum // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .ed25519
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ed25519
    case 1: self = .secp256K1
    case 2: self = .ethereum
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ed25519: return 0
    case .secp256K1: return 1
    case .ethereum: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_KeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_KeyType] = [
    .ed25519,
    .secp256K1,
    .ethereum,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_HashType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case keccak // = 0
  case sha3 // = 1
  case sha2 // = 2
  case keccak384 // = 6
  case sha3384 // = 7
  case keccak512 // = 13
  case sha3512 // = 14
  case UNRECOGNIZED(Int)

  public init() {
    self = .keccak
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .keccak
    case 1: self = .sha3
    case 2: self = .sha2
    case 6: self = .keccak384
    case 7: self = .sha3384
    case 13: self = .keccak512
    case 14: self = .sha3512
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .keccak: return 0
    case .sha3: return 1
    case .sha2: return 2
    case .keccak384: return 6
    case .sha3384: return 7
    case .keccak512: return 13
    case .sha3512: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_HashType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_HashType] = [
    .keccak,
    .sha3,
    .sha2,
    .keccak384,
    .sha3384,
    .keccak512,
    .sha3512,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_EncodingType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case base16 // = 0
  case base58 // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .base16
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .base16
    case 1: self = .base58
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .base16: return 0
    case .base58: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_EncodingType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_EncodingType] = [
    .base16,
    .base58,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_RoleType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case roleAccount // = 0
  case roleNode // = 1
  case roleDevice // = 2
  case roleApplication // = 3
  case roleSmartContract // = 4
  case roleBot // = 5
  case roleAsset // = 6
  case roleStake // = 7
  case roleValidator // = 8
  case roleGroup // = 9
  case roleTx // = 10
  case roleTether // = 11
  case roleSwap // = 12
  case roleDelegation // = 13
  case roleVc // = 14
  case roleBlocklet // = 15
  case roleRegistry // = 16
  case roleAny // = 63
  case UNRECOGNIZED(Int)

  public init() {
    self = .roleAccount
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .roleAccount
    case 1: self = .roleNode
    case 2: self = .roleDevice
    case 3: self = .roleApplication
    case 4: self = .roleSmartContract
    case 5: self = .roleBot
    case 6: self = .roleAsset
    case 7: self = .roleStake
    case 8: self = .roleValidator
    case 9: self = .roleGroup
    case 10: self = .roleTx
    case 11: self = .roleTether
    case 12: self = .roleSwap
    case 13: self = .roleDelegation
    case 14: self = .roleVc
    case 15: self = .roleBlocklet
    case 16: self = .roleRegistry
    case 63: self = .roleAny
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .roleAccount: return 0
    case .roleNode: return 1
    case .roleDevice: return 2
    case .roleApplication: return 3
    case .roleSmartContract: return 4
    case .roleBot: return 5
    case .roleAsset: return 6
    case .roleStake: return 7
    case .roleValidator: return 8
    case .roleGroup: return 9
    case .roleTx: return 10
    case .roleTether: return 11
    case .roleSwap: return 12
    case .roleDelegation: return 13
    case .roleVc: return 14
    case .roleBlocklet: return 15
    case .roleRegistry: return 16
    case .roleAny: return 63
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_RoleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_RoleType] = [
    .roleAccount,
    .roleNode,
    .roleDevice,
    .roleApplication,
    .roleSmartContract,
    .roleBot,
    .roleAsset,
    .roleStake,
    .roleValidator,
    .roleGroup,
    .roleTx,
    .roleTether,
    .roleSwap,
    .roleDelegation,
    .roleVc,
    .roleBlocklet,
    .roleRegistry,
    .roleAny,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_UpgradeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// CONFIGURATION
  case configApp // = 0
  case configForge // = 1
  case configDfs // = 2
  case configConsensus // = 3
  case configP2P // = 4

  /// EXECUTABLE
  case exeApp // = 10
  case exeForge // = 11
  case exeDfs // = 12
  case exeConsensus // = 13
  case exeP2P // = 14
  case UNRECOGNIZED(Int)

  public init() {
    self = .configApp
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .configApp
    case 1: self = .configForge
    case 2: self = .configDfs
    case 3: self = .configConsensus
    case 4: self = .configP2P
    case 10: self = .exeApp
    case 11: self = .exeForge
    case 12: self = .exeDfs
    case 13: self = .exeConsensus
    case 14: self = .exeP2P
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .configApp: return 0
    case .configForge: return 1
    case .configDfs: return 2
    case .configConsensus: return 3
    case .configP2P: return 4
    case .exeApp: return 10
    case .exeForge: return 11
    case .exeDfs: return 12
    case .exeConsensus: return 13
    case .exeP2P: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_UpgradeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_UpgradeType] = [
    .configApp,
    .configForge,
    .configDfs,
    .configConsensus,
    .configP2P,
    .exeApp,
    .exeForge,
    .exeDfs,
    .exeConsensus,
    .exeP2P,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_UpgradeAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case verify // = 0
  case backup // = 1
  case replace // = 2

  /// RESTART DIFFERENT PART OF THE SYSTEM
  case restartApp // = 10
  case restartDfs // = 11
  case restartConsensus // = 12
  case restartP2P // = 13

  /// RESTART FORGE WILL INDIRECTLY RESTART ALL COMPONENT IN A GRACEFUL MANNER
  case restartForge // = 14

  /// DEPEND ON DEPLOYMENT, THE MONITOR APP (E.G. SYSTEMD) SHALL BRING THE
  /// PROCESS BACK
  case rollbackIfFail // = 30
  case restartAllIfFail // = 31
  case crashIfFail // = 33

  /// DROP DIFFERENT INTERMEDIATE FILES
  case dropAddressBook // = 50
  case UNRECOGNIZED(Int)

  public init() {
    self = .verify
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .verify
    case 1: self = .backup
    case 2: self = .replace
    case 10: self = .restartApp
    case 11: self = .restartDfs
    case 12: self = .restartConsensus
    case 13: self = .restartP2P
    case 14: self = .restartForge
    case 30: self = .rollbackIfFail
    case 31: self = .restartAllIfFail
    case 33: self = .crashIfFail
    case 50: self = .dropAddressBook
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .verify: return 0
    case .backup: return 1
    case .replace: return 2
    case .restartApp: return 10
    case .restartDfs: return 11
    case .restartConsensus: return 12
    case .restartP2P: return 13
    case .restartForge: return 14
    case .rollbackIfFail: return 30
    case .restartAllIfFail: return 31
    case .crashIfFail: return 33
    case .dropAddressBook: return 50
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_UpgradeAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_UpgradeAction] = [
    .verify,
    .backup,
    .replace,
    .restartApp,
    .restartDfs,
    .restartConsensus,
    .restartP2P,
    .restartForge,
    .rollbackIfFail,
    .restartAllIfFail,
    .crashIfFail,
    .dropAddressBook,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_StateType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case stateAccount // = 0
  case stateAsset // = 1
  case stateChannel // = 2
  case stateForge // = 3
  case stateStake // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .stateAccount
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stateAccount
    case 1: self = .stateAsset
    case 2: self = .stateChannel
    case 3: self = .stateForge
    case 4: self = .stateStake
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .stateAccount: return 0
    case .stateAsset: return 1
    case .stateChannel: return 2
    case .stateForge: return 3
    case .stateStake: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_StateType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_StateType] = [
    .stateAccount,
    .stateAsset,
    .stateChannel,
    .stateForge,
    .stateStake,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_StakeType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case stakeNode // = 0
  case stakeUser // = 1
  case stakeAsset // = 2
  case stakeChain // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .stakeNode
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stakeNode
    case 1: self = .stakeUser
    case 2: self = .stakeAsset
    case 3: self = .stakeChain
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .stakeNode: return 0
    case .stakeUser: return 1
    case .stakeAsset: return 2
    case .stakeChain: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_StakeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_StakeType] = [
    .stakeNode,
    .stakeUser,
    .stakeAsset,
    .stakeChain,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_ProtocolStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case running // = 0
  case paused // = 1
  case terminated // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .running
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .running
    case 1: self = .paused
    case 2: self = .terminated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .running: return 0
    case .paused: return 1
    case .terminated: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_ProtocolStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_ProtocolStatus] = [
    .running,
    .paused,
    .terminated,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Ocap_StatusCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_NONCE"),
    2: .same(proto: "INVALID_SIGNATURE"),
    3: .same(proto: "INVALID_SENDER_STATE"),
    4: .same(proto: "INVALID_RECEIVER_STATE"),
    5: .same(proto: "INSUFFICIENT_DATA"),
    6: .same(proto: "INSUFFICIENT_FUND"),
    7: .same(proto: "INVALID_OWNER"),
    8: .same(proto: "INVALID_TX"),
    9: .same(proto: "UNSUPPORTED_TX"),
    10: .same(proto: "EXPIRED_TX"),
    11: .same(proto: "TOO_MANY_TXS"),
    12: .same(proto: "INVALID_LOCK_STATUS"),
    13: .same(proto: "INVALID_REQUEST"),
    16: .same(proto: "INVALID_MONIKER"),
    17: .same(proto: "INVALID_PASSPHRASE"),
    20: .same(proto: "INVALID_MULTISIG"),
    21: .same(proto: "INVALID_WALLET"),
    22: .same(proto: "INVALID_CHAIN_ID"),
    24: .same(proto: "CONSENSUS_RPC_ERROR"),
    25: .same(proto: "STORAGE_RPC_ERROR"),
    26: .same(proto: "NOENT"),
    27: .same(proto: "ACCOUNT_MIGRATED"),
    28: .same(proto: "RPC_CONNECTION_ERROR"),
    30: .same(proto: "UNSUPPORTED_STAKE"),
    31: .same(proto: "INSUFFICIENT_STAKE"),
    32: .same(proto: "INVALID_STAKE_STATE"),
    33: .same(proto: "EXPIRED_WALLET_TOKEN"),
    34: .same(proto: "BANNED_UNSTAKE"),
    35: .same(proto: "INVALID_ASSET"),
    36: .same(proto: "INVALID_TX_SIZE"),
    37: .same(proto: "INVALID_SIGNER_STATE"),
    38: .same(proto: "INVALID_FORGE_STATE"),
    39: .same(proto: "EXPIRED_ASSET"),
    40: .same(proto: "UNTRANSFERRABLE_ASSET"),
    41: .same(proto: "READONLY_ASSET"),
    42: .same(proto: "CONSUMED_ASSET"),
    43: .same(proto: "INVALID_DEPOSIT_VALUE"),
    44: .same(proto: "EXCEED_DEPOSIT_CAP"),
    45: .same(proto: "INVALID_DEPOSIT_TARGET"),
    46: .same(proto: "INVALID_DEPOSITOR"),
    47: .same(proto: "INVALID_WITHDRAWER"),
    49: .same(proto: "INVALID_EXPIRY_DATE"),
    51: .same(proto: "INVALID_CUSTODIAN"),
    52: .same(proto: "INSUFFICIENT_GAS"),
    53: .same(proto: "INVALID_SWAP"),
    54: .same(proto: "INVALID_HASHKEY"),
    55: .same(proto: "INVALID_DELEGATION"),
    56: .same(proto: "INSUFFICIENT_DELEGATION"),
    57: .same(proto: "INVALID_DELEGATION_RULE"),
    58: .same(proto: "INVALID_DELEGATION_TYPE_URL"),
    59: .same(proto: "SENDER_NOT_AUTHORIZED"),
    60: .same(proto: "PROTOCOL_NOT_RUNNING"),
    61: .same(proto: "PROTOCOL_NOT_PAUSED"),
    62: .same(proto: "PROTOCOL_NOT_ACTIVATED"),
    63: .same(proto: "INVALID_DEACTIVATION"),
    64: .same(proto: "SENDER_WITHDRAW_ITEMS_FULL"),
    65: .same(proto: "WITHDRAW_ITEM_MISSING"),
    66: .same(proto: "INVALID_WITHDRAW_TX"),
    67: .same(proto: "INVALID_CHAIN_TYPE"),
    68: .same(proto: "INVALID_TIME"),
    69: .same(proto: "INVALID_SUBSCRIBE"),
    70: .same(proto: "INVALID_DID_TYPE"),
    71: .same(proto: "INVALID_CANDIDATE_STATE"),
    72: .same(proto: "VALIDATOR_NOT_FOUND"),
    73: .same(proto: "VALIDATOR_NOT_CHANGED"),
    74: .same(proto: "INVALID_FACTORY_STATE"),
    75: .same(proto: "INVALID_FACTORY_PROPS"),
    76: .same(proto: "INVALID_FACTORY_INPUT"),
    77: .same(proto: "INVALID_TOKEN"),
    403: .same(proto: "FORBIDDEN"),
    500: .same(proto: "INTERNAL"),
    504: .same(proto: "TIMEOUT"),
  ]
}

extension Ocap_KeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ED25519"),
    1: .same(proto: "SECP256K1"),
    2: .same(proto: "ETHEREUM"),
  ]
}

extension Ocap_HashType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KECCAK"),
    1: .same(proto: "SHA3"),
    2: .same(proto: "SHA2"),
    6: .same(proto: "KECCAK_384"),
    7: .same(proto: "SHA3_384"),
    13: .same(proto: "KECCAK_512"),
    14: .same(proto: "SHA3_512"),
  ]
}

extension Ocap_EncodingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BASE16"),
    1: .same(proto: "BASE58"),
  ]
}

extension Ocap_RoleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROLE_ACCOUNT"),
    1: .same(proto: "ROLE_NODE"),
    2: .same(proto: "ROLE_DEVICE"),
    3: .same(proto: "ROLE_APPLICATION"),
    4: .same(proto: "ROLE_SMART_CONTRACT"),
    5: .same(proto: "ROLE_BOT"),
    6: .same(proto: "ROLE_ASSET"),
    7: .same(proto: "ROLE_STAKE"),
    8: .same(proto: "ROLE_VALIDATOR"),
    9: .same(proto: "ROLE_GROUP"),
    10: .same(proto: "ROLE_TX"),
    11: .same(proto: "ROLE_TETHER"),
    12: .same(proto: "ROLE_SWAP"),
    13: .same(proto: "ROLE_DELEGATION"),
    14: .same(proto: "ROLE_VC"),
    15: .same(proto: "ROLE_BLOCKLET"),
    16: .same(proto: "ROLE_REGISTRY"),
    63: .same(proto: "ROLE_ANY"),
  ]
}

extension Ocap_UpgradeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONFIG_APP"),
    1: .same(proto: "CONFIG_FORGE"),
    2: .same(proto: "CONFIG_DFS"),
    3: .same(proto: "CONFIG_CONSENSUS"),
    4: .same(proto: "CONFIG_P2P"),
    10: .same(proto: "EXE_APP"),
    11: .same(proto: "EXE_FORGE"),
    12: .same(proto: "EXE_DFS"),
    13: .same(proto: "EXE_CONSENSUS"),
    14: .same(proto: "EXE_P2P"),
  ]
}

extension Ocap_UpgradeAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERIFY"),
    1: .same(proto: "BACKUP"),
    2: .same(proto: "REPLACE"),
    10: .same(proto: "RESTART_APP"),
    11: .same(proto: "RESTART_DFS"),
    12: .same(proto: "RESTART_CONSENSUS"),
    13: .same(proto: "RESTART_P2P"),
    14: .same(proto: "RESTART_FORGE"),
    30: .same(proto: "ROLLBACK_IF_FAIL"),
    31: .same(proto: "RESTART_ALL_IF_FAIL"),
    33: .same(proto: "CRASH_IF_FAIL"),
    50: .same(proto: "DROP_ADDRESS_BOOK"),
  ]
}

extension Ocap_StateType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_ACCOUNT"),
    1: .same(proto: "STATE_ASSET"),
    2: .same(proto: "STATE_CHANNEL"),
    3: .same(proto: "STATE_FORGE"),
    4: .same(proto: "STATE_STAKE"),
  ]
}

extension Ocap_StakeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STAKE_NODE"),
    1: .same(proto: "STAKE_USER"),
    2: .same(proto: "STAKE_ASSET"),
    3: .same(proto: "STAKE_CHAIN"),
  ]
}

extension Ocap_ProtocolStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUNNING"),
    1: .same(proto: "PAUSED"),
    2: .same(proto: "TERMINATED"),
  ]
}
