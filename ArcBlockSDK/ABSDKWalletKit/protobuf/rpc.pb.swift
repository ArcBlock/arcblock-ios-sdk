// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// send_tx(tx, wallet, token, commit \\ false)
public struct Ocap_RequestSendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: String {
    get {return _storage._tx}
    set {_uniqueStorage()._tx = newValue}
  }

  public var wallet: Ocap_WalletInfo {
    get {return _storage._wallet ?? Ocap_WalletInfo()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var commit: Bool {
    get {return _storage._commit}
    set {_uniqueStorage()._commit = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseSendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// get_tx(hash)
public struct Ocap_RequestGetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var info: Ocap_TransactionInfo {
    get {return _storage._info ?? Ocap_TransactionInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_block(height)
public struct Ocap_RequestGetBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var block: Ocap_BlockInfo {
    get {return _storage._block ?? Ocap_BlockInfo()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {_uniqueStorage()._block = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestGetBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var heightFilter: Ocap_RangeFilter {
    get {return _storage._heightFilter ?? Ocap_RangeFilter()}
    set {_uniqueStorage()._heightFilter = newValue}
  }
  /// Returns true if `heightFilter` has been explicitly set.
  public var hasHeightFilter: Bool {return _storage._heightFilter != nil}
  /// Clears the value of `heightFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHeightFilter() {_uniqueStorage()._heightFilter = nil}

  public var emptyExcluded: Bool {
    get {return _storage._emptyExcluded}
    set {_uniqueStorage()._emptyExcluded = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseGetBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var blocks: [Ocap_BlockInfoSimple] {
    get {return _storage._blocks}
    set {_uniqueStorage()._blocks = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_account_state(address, key): retrieve the current state from a list of
/// wallet addresses, return the value of the key. If key is omitted, return
/// entire account states
public struct Ocap_RequestGetAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: Ocap_AccountState {
    get {return _storage._state ?? Ocap_AccountState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestGetAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: Ocap_AssetState {
    get {return _storage._state ?? Ocap_AssetState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_forge_state(key): retrieve Forge state by key. If key is omitted, return
/// entire Forge state
public struct Ocap_RequestGetForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: Ocap_ForgeState {
    get {return _storage._state ?? Ocap_ForgeState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestGetSwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetSwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: Ocap_SwapState {
    get {return _storage._state ?? Ocap_SwapState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestGetDelegateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetDelegateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: Ocap_DelegateState {
    get {return _storage._state ?? Ocap_DelegateState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_chain_info(): retrieve the current chain information
public struct Ocap_RequestGetChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var info: Ocap_ChainInfo {
    get {return _storage._info ?? Ocap_ChainInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_node_info(): retrieve the current node information
public struct Ocap_RequestGetNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var info: Ocap_NodeInfo {
    get {return _storage._info ?? Ocap_NodeInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// search(term): retrieve related transactions by a search term (prefix match)
public struct Ocap_RequestSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var txs: [Ocap_TransactionInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RequestGetUnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseGetUnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var unconfirmedTxs: Ocap_UnconfirmedTxs {
    get {return _storage._unconfirmedTxs ?? Ocap_UnconfirmedTxs()}
    set {_uniqueStorage()._unconfirmedTxs = newValue}
  }
  /// Returns true if `unconfirmedTxs` has been explicitly set.
  public var hasUnconfirmedTxs: Bool {return _storage._unconfirmedTxs != nil}
  /// Clears the value of `unconfirmedTxs`. Subsequent reads from it will return its default value.
  public mutating func clearUnconfirmedTxs() {_uniqueStorage()._unconfirmedTxs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestGetNetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetNetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var netInfo: Ocap_NetInfo {
    get {return _storage._netInfo ?? Ocap_NetInfo()}
    set {_uniqueStorage()._netInfo = newValue}
  }
  /// Returns true if `netInfo` has been explicitly set.
  public var hasNetInfo: Bool {return _storage._netInfo != nil}
  /// Clears the value of `netInfo`. Subsequent reads from it will return its default value.
  public mutating func clearNetInfo() {_uniqueStorage()._netInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestGetValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var validatorsInfo: Ocap_ValidatorsInfo {
    get {return _storage._validatorsInfo ?? Ocap_ValidatorsInfo()}
    set {_uniqueStorage()._validatorsInfo = newValue}
  }
  /// Returns true if `validatorsInfo` has been explicitly set.
  public var hasValidatorsInfo: Bool {return _storage._validatorsInfo != nil}
  /// Clears the value of `validatorsInfo`. Subsequent reads from it will return its default value.
  public mutating func clearValidatorsInfo() {_uniqueStorage()._validatorsInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// filter could be: value.header.height > 10086 and value.byzantine_validators
/// != []
public struct Ocap_RequestSubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseSubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var topic: String {
    get {
      if case .topic(let v)? = _storage._value {return v}
      return String()
    }
    set {_uniqueStorage()._value = .topic(newValue)}
  }

  public var transfer: Ocap_Transaction {
    get {
      if case .transfer(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .transfer(newValue)}
  }

  public var accountMigrate: Ocap_Transaction {
    get {
      if case .accountMigrate(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .accountMigrate(newValue)}
  }

  public var confirm: Ocap_Transaction {
    get {
      if case .confirm(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .confirm(newValue)}
  }

  public var createAsset: Ocap_Transaction {
    get {
      if case .createAsset(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .createAsset(newValue)}
  }

  /// Transaction revoke = 8 [ deprecated = true ];
  public var exchange: Ocap_Transaction {
    get {
      if case .exchange(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .exchange(newValue)}
  }

  public var beginBlock: Vendor_RequestBeginBlock {
    get {
      if case .beginBlock(let v)? = _storage._value {return v}
      return Vendor_RequestBeginBlock()
    }
    set {_uniqueStorage()._value = .beginBlock(newValue)}
  }

  public var endBlock: Vendor_RequestEndBlock {
    get {
      if case .endBlock(let v)? = _storage._value {return v}
      return Vendor_RequestEndBlock()
    }
    set {_uniqueStorage()._value = .endBlock(newValue)}
  }

  public var declare: Ocap_Transaction {
    get {
      if case .declare(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .declare(newValue)}
  }

  public var updateAsset: Ocap_Transaction {
    get {
      if case .updateAsset(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .updateAsset(newValue)}
  }

  public var consensusUpgrade: Ocap_Transaction {
    get {
      if case .consensusUpgrade(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .consensusUpgrade(newValue)}
  }

  /// Transaction declare_file = 22 [ deprecated = true ];
  public var sysUpgrade: Ocap_Transaction {
    get {
      if case .sysUpgrade(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .sysUpgrade(newValue)}
  }

  public var stake: Ocap_Transaction {
    get {
      if case .stake(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .stake(newValue)}
  }

  public var delegate: Ocap_Transaction {
    get {
      if case .delegate(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .delegate(newValue)}
  }

  /// Transaction activate_protocol = 26 [ deprecated = true ];
  /// Transaction deactivate_protocol = 27 [ deprecated = true ];
  public var revokeDelegate: Ocap_Transaction {
    get {
      if case .revokeDelegate(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .revokeDelegate(newValue)}
  }

  public var depositToken: Ocap_Transaction {
    get {
      if case .depositToken(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .depositToken(newValue)}
  }

  public var withdrawToken: Ocap_Transaction {
    get {
      if case .withdrawToken(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .withdrawToken(newValue)}
  }

  public var approveWithdraw: Ocap_Transaction {
    get {
      if case .approveWithdraw(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .approveWithdraw(newValue)}
  }

  public var revokeWithdraw: Ocap_Transaction {
    get {
      if case .revokeWithdraw(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .revokeWithdraw(newValue)}
  }

  public var setupSwap: Ocap_Transaction {
    get {
      if case .setupSwap(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .setupSwap(newValue)}
  }

  public var revokeSwap: Ocap_Transaction {
    get {
      if case .revokeSwap(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .revokeSwap(newValue)}
  }

  public var retrieveSwap: Ocap_Transaction {
    get {
      if case .retrieveSwap(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .retrieveSwap(newValue)}
  }

  public var poke: Ocap_Transaction {
    get {
      if case .poke(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .poke(newValue)}
  }

  /// Transaction deploy_protocol = 37 [ deprecated = true ];
  public var consumeAsset: Ocap_Transaction {
    get {
      if case .consumeAsset(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .consumeAsset(newValue)}
  }

  public var acquireAsset: Ocap_Transaction {
    get {
      if case .acquireAsset(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .acquireAsset(newValue)}
  }

  public var upgradeNode: Ocap_Transaction {
    get {
      if case .upgradeNode(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .upgradeNode(newValue)}
  }

  public var updateValidator: Ocap_Transaction {
    get {
      if case .updateValidator(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .updateValidator(newValue)}
  }

  public var updateConsensusParams: Ocap_Transaction {
    get {
      if case .updateConsensusParams(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .updateConsensusParams(newValue)}
  }

  public var accountState: Ocap_AccountState {
    get {
      if case .accountState(let v)? = _storage._value {return v}
      return Ocap_AccountState()
    }
    set {_uniqueStorage()._value = .accountState(newValue)}
  }

  public var assetState: Ocap_AssetState {
    get {
      if case .assetState(let v)? = _storage._value {return v}
      return Ocap_AssetState()
    }
    set {_uniqueStorage()._value = .assetState(newValue)}
  }

  public var forgeState: Ocap_ForgeState {
    get {
      if case .forgeState(let v)? = _storage._value {return v}
      return Ocap_ForgeState()
    }
    set {_uniqueStorage()._value = .forgeState(newValue)}
  }

  /// StakeState stake_state = 132 [ deprecated = true ];
  /// ProtocolState protocol_state = 133 [ deprecated = true ];
  public var delegateState: Ocap_DelegateState {
    get {
      if case .delegateState(let v)? = _storage._value {return v}
      return Ocap_DelegateState()
    }
    set {_uniqueStorage()._value = .delegateState(newValue)}
  }

  public var swapState: Ocap_SwapState {
    get {
      if case .swapState(let v)? = _storage._value {return v}
      return Ocap_SwapState()
    }
    set {_uniqueStorage()._value = .swapState(newValue)}
  }

  public var createToken: Ocap_Transaction {
    get {
      if case .createToken(let v)? = _storage._value {return v}
      return Ocap_Transaction()
    }
    set {_uniqueStorage()._value = .createToken(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case topic(String)
    case transfer(Ocap_Transaction)
    case accountMigrate(Ocap_Transaction)
    case confirm(Ocap_Transaction)
    case createAsset(Ocap_Transaction)
    /// Transaction revoke = 8 [ deprecated = true ];
    case exchange(Ocap_Transaction)
    case beginBlock(Vendor_RequestBeginBlock)
    case endBlock(Vendor_RequestEndBlock)
    case declare(Ocap_Transaction)
    case updateAsset(Ocap_Transaction)
    case consensusUpgrade(Ocap_Transaction)
    /// Transaction declare_file = 22 [ deprecated = true ];
    case sysUpgrade(Ocap_Transaction)
    case stake(Ocap_Transaction)
    case delegate(Ocap_Transaction)
    /// Transaction activate_protocol = 26 [ deprecated = true ];
    /// Transaction deactivate_protocol = 27 [ deprecated = true ];
    case revokeDelegate(Ocap_Transaction)
    case depositToken(Ocap_Transaction)
    case withdrawToken(Ocap_Transaction)
    case approveWithdraw(Ocap_Transaction)
    case revokeWithdraw(Ocap_Transaction)
    case setupSwap(Ocap_Transaction)
    case revokeSwap(Ocap_Transaction)
    case retrieveSwap(Ocap_Transaction)
    case poke(Ocap_Transaction)
    /// Transaction deploy_protocol = 37 [ deprecated = true ];
    case consumeAsset(Ocap_Transaction)
    case acquireAsset(Ocap_Transaction)
    case upgradeNode(Ocap_Transaction)
    case updateValidator(Ocap_Transaction)
    case updateConsensusParams(Ocap_Transaction)
    case accountState(Ocap_AccountState)
    case assetState(Ocap_AssetState)
    case forgeState(Ocap_ForgeState)
    /// StakeState stake_state = 132 [ deprecated = true ];
    /// ProtocolState protocol_state = 133 [ deprecated = true ];
    case delegateState(Ocap_DelegateState)
    case swapState(Ocap_SwapState)
    case createToken(Ocap_Transaction)

  #if !swift(>=4.1)
    public static func ==(lhs: Ocap_ResponseSubscribe.OneOf_Value, rhs: Ocap_ResponseSubscribe.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.topic(let l), .topic(let r)): return l == r
      case (.transfer(let l), .transfer(let r)): return l == r
      case (.accountMigrate(let l), .accountMigrate(let r)): return l == r
      case (.confirm(let l), .confirm(let r)): return l == r
      case (.createAsset(let l), .createAsset(let r)): return l == r
      case (.exchange(let l), .exchange(let r)): return l == r
      case (.beginBlock(let l), .beginBlock(let r)): return l == r
      case (.endBlock(let l), .endBlock(let r)): return l == r
      case (.declare(let l), .declare(let r)): return l == r
      case (.updateAsset(let l), .updateAsset(let r)): return l == r
      case (.consensusUpgrade(let l), .consensusUpgrade(let r)): return l == r
      case (.sysUpgrade(let l), .sysUpgrade(let r)): return l == r
      case (.stake(let l), .stake(let r)): return l == r
      case (.delegate(let l), .delegate(let r)): return l == r
      case (.revokeDelegate(let l), .revokeDelegate(let r)): return l == r
      case (.depositToken(let l), .depositToken(let r)): return l == r
      case (.withdrawToken(let l), .withdrawToken(let r)): return l == r
      case (.approveWithdraw(let l), .approveWithdraw(let r)): return l == r
      case (.revokeWithdraw(let l), .revokeWithdraw(let r)): return l == r
      case (.setupSwap(let l), .setupSwap(let r)): return l == r
      case (.revokeSwap(let l), .revokeSwap(let r)): return l == r
      case (.retrieveSwap(let l), .retrieveSwap(let r)): return l == r
      case (.poke(let l), .poke(let r)): return l == r
      case (.consumeAsset(let l), .consumeAsset(let r)): return l == r
      case (.acquireAsset(let l), .acquireAsset(let r)): return l == r
      case (.upgradeNode(let l), .upgradeNode(let r)): return l == r
      case (.updateValidator(let l), .updateValidator(let r)): return l == r
      case (.updateConsensusParams(let l), .updateConsensusParams(let r)): return l == r
      case (.accountState(let l), .accountState(let r)): return l == r
      case (.assetState(let l), .assetState(let r)): return l == r
      case (.forgeState(let l), .forgeState(let r)): return l == r
      case (.delegateState(let l), .delegateState(let r)): return l == r
      case (.swapState(let l), .swapState(let r)): return l == r
      case (.createToken(let l), .createToken(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestUnsubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseUnsubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// get config
public struct Ocap_RequestGetConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parsed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var config: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ByDay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startDate: String = String()

  public var endDate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ByHour {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RequestGetForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var dayInfo: Ocap_ByDay {
    get {
      if case .dayInfo(let v)? = _storage._value {return v}
      return Ocap_ByDay()
    }
    set {_uniqueStorage()._value = .dayInfo(newValue)}
  }

  public var date: Ocap_ByHour {
    get {
      if case .date(let v)? = _storage._value {return v}
      return Ocap_ByHour()
    }
    set {_uniqueStorage()._value = .date(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case dayInfo(Ocap_ByDay)
    case date(Ocap_ByHour)

  #if !swift(>=4.1)
    public static func ==(lhs: Ocap_RequestGetForgeStats.OneOf_Value, rhs: Ocap_RequestGetForgeStats.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.dayInfo(let l), .dayInfo(let r)): return l == r
      case (.date(let l), .date(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseGetForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var forgeStats: Ocap_ForgeStats {
    get {return _storage._forgeStats ?? Ocap_ForgeStats()}
    set {_uniqueStorage()._forgeStats = newValue}
  }
  /// Returns true if `forgeStats` has been explicitly set.
  public var hasForgeStats: Bool {return _storage._forgeStats != nil}
  /// Clears the value of `forgeStats`. Subsequent reads from it will return its default value.
  public mutating func clearForgeStats() {_uniqueStorage()._forgeStats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var timeFilter: Ocap_TimeFilter {
    get {return _storage._timeFilter ?? Ocap_TimeFilter()}
    set {_uniqueStorage()._timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return _storage._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {_uniqueStorage()._timeFilter = nil}

  public var addressFilter: Ocap_AddressFilter {
    get {return _storage._addressFilter ?? Ocap_AddressFilter()}
    set {_uniqueStorage()._addressFilter = newValue}
  }
  /// Returns true if `addressFilter` has been explicitly set.
  public var hasAddressFilter: Bool {return _storage._addressFilter != nil}
  /// Clears the value of `addressFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAddressFilter() {_uniqueStorage()._addressFilter = nil}

  public var typeFilter: Ocap_TypeFilter {
    get {return _storage._typeFilter ?? Ocap_TypeFilter()}
    set {_uniqueStorage()._typeFilter = newValue}
  }
  /// Returns true if `typeFilter` has been explicitly set.
  public var hasTypeFilter: Bool {return _storage._typeFilter != nil}
  /// Clears the value of `typeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTypeFilter() {_uniqueStorage()._typeFilter = nil}

  public var validityFilter: Ocap_ValidityFilter {
    get {return _storage._validityFilter ?? Ocap_ValidityFilter()}
    set {_uniqueStorage()._validityFilter = newValue}
  }
  /// Returns true if `validityFilter` has been explicitly set.
  public var hasValidityFilter: Bool {return _storage._validityFilter != nil}
  /// Clears the value of `validityFilter`. Subsequent reads from it will return its default value.
  public mutating func clearValidityFilter() {_uniqueStorage()._validityFilter = nil}

  public var factoryFilter: Ocap_FactoryFilter {
    get {return _storage._factoryFilter ?? Ocap_FactoryFilter()}
    set {_uniqueStorage()._factoryFilter = newValue}
  }
  /// Returns true if `factoryFilter` has been explicitly set.
  public var hasFactoryFilter: Bool {return _storage._factoryFilter != nil}
  /// Clears the value of `factoryFilter`. Subsequent reads from it will return its default value.
  public mutating func clearFactoryFilter() {_uniqueStorage()._factoryFilter = nil}

  public var tokenFilter: Ocap_TokenFilter {
    get {return _storage._tokenFilter ?? Ocap_TokenFilter()}
    set {_uniqueStorage()._tokenFilter = newValue}
  }
  /// Returns true if `tokenFilter` has been explicitly set.
  public var hasTokenFilter: Bool {return _storage._tokenFilter != nil}
  /// Clears the value of `tokenFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTokenFilter() {_uniqueStorage()._tokenFilter = nil}

  public var assetFilter: Ocap_AssetFilter {
    get {return _storage._assetFilter ?? Ocap_AssetFilter()}
    set {_uniqueStorage()._assetFilter = newValue}
  }
  /// Returns true if `assetFilter` has been explicitly set.
  public var hasAssetFilter: Bool {return _storage._assetFilter != nil}
  /// Clears the value of `assetFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAssetFilter() {_uniqueStorage()._assetFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var transactions: [Ocap_IndexedTransaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var ownerAddress: String {
    get {return _storage._ownerAddress}
    set {_uniqueStorage()._ownerAddress = newValue}
  }

  public var factoryAddress: String {
    get {return _storage._factoryAddress}
    set {_uniqueStorage()._factoryAddress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var assets: [Ocap_IndexedAssetState] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListStakes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var addressFilter: Ocap_AddressFilter {
    get {return _storage._addressFilter ?? Ocap_AddressFilter()}
    set {_uniqueStorage()._addressFilter = newValue}
  }
  /// Returns true if `addressFilter` has been explicitly set.
  public var hasAddressFilter: Bool {return _storage._addressFilter != nil}
  /// Clears the value of `addressFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAddressFilter() {_uniqueStorage()._addressFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListStakes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var stakes: [Ocap_IndexedStakeState] {
    get {return _storage._stakes}
    set {_uniqueStorage()._stakes = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ownerAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseListAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var account: Ocap_IndexedAccountState {
    get {return _storage._account ?? Ocap_IndexedAccountState()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListTopAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var tokenAddress: String {
    get {return _storage._tokenAddress}
    set {_uniqueStorage()._tokenAddress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListTopAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var accounts: [Ocap_IndexedAccountState] {
    get {return _storage._accounts}
    set {_uniqueStorage()._accounts = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListAssetTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListAssetTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var transactions: [Ocap_IndexedTransaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var proposer: String {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  public var timeFilter: Ocap_TimeFilter {
    get {return _storage._timeFilter ?? Ocap_TimeFilter()}
    set {_uniqueStorage()._timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return _storage._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {_uniqueStorage()._timeFilter = nil}

  public var heightFilter: Ocap_RangeFilter {
    get {return _storage._heightFilter ?? Ocap_RangeFilter()}
    set {_uniqueStorage()._heightFilter = newValue}
  }
  /// Returns true if `heightFilter` has been explicitly set.
  public var hasHeightFilter: Bool {return _storage._heightFilter != nil}
  /// Clears the value of `heightFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHeightFilter() {_uniqueStorage()._heightFilter = nil}

  public var numTxsFilter: Ocap_RangeFilter {
    get {return _storage._numTxsFilter ?? Ocap_RangeFilter()}
    set {_uniqueStorage()._numTxsFilter = newValue}
  }
  /// Returns true if `numTxsFilter` has been explicitly set.
  public var hasNumTxsFilter: Bool {return _storage._numTxsFilter != nil}
  /// Clears the value of `numTxsFilter`. Subsequent reads from it will return its default value.
  public mutating func clearNumTxsFilter() {_uniqueStorage()._numTxsFilter = nil}

  public var numInvalidTxsFilter: Ocap_RangeFilter {
    get {return _storage._numInvalidTxsFilter ?? Ocap_RangeFilter()}
    set {_uniqueStorage()._numInvalidTxsFilter = newValue}
  }
  /// Returns true if `numInvalidTxsFilter` has been explicitly set.
  public var hasNumInvalidTxsFilter: Bool {return _storage._numInvalidTxsFilter != nil}
  /// Clears the value of `numInvalidTxsFilter`. Subsequent reads from it will return its default value.
  public mutating func clearNumInvalidTxsFilter() {_uniqueStorage()._numInvalidTxsFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var blocks: [Ocap_IndexedBlock] {
    get {return _storage._blocks}
    set {_uniqueStorage()._blocks = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  public var available: Bool {
    get {return _storage._available}
    set {_uniqueStorage()._available = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var swap: [Ocap_SwapState] {
    get {return _storage._swap}
    set {_uniqueStorage()._swap = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestGetSwapStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetSwapStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var statistics: Ocap_SwapStatistics {
    get {return _storage._statistics ?? Ocap_SwapStatistics()}
    set {_uniqueStorage()._statistics = newValue}
  }
  /// Returns true if `statistics` has been explicitly set.
  public var hasStatistics: Bool {return _storage._statistics != nil}
  /// Clears the value of `statistics`. Subsequent reads from it will return its default value.
  public mutating func clearStatistics() {_uniqueStorage()._statistics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestGetHealthStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetHealthStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var healthStatus: Ocap_HealthStatus {
    get {return _storage._healthStatus ?? Ocap_HealthStatus()}
    set {_uniqueStorage()._healthStatus = newValue}
  }
  /// Returns true if `healthStatus` has been explicitly set.
  public var hasHealthStatus: Bool {return _storage._healthStatus != nil}
  /// Clears the value of `healthStatus`. Subsequent reads from it will return its default value.
  public mutating func clearHealthStatus() {_uniqueStorage()._healthStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// token related
public struct Ocap_RequestGetTokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetTokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: Ocap_TokenState {
    get {return _storage._state ?? Ocap_TokenState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var issuerAddress: String {
    get {return _storage._issuerAddress}
    set {_uniqueStorage()._issuerAddress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var tokens: [Ocap_IndexedTokenState] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// asset factory related apis
public struct Ocap_RequestGetFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: Ocap_AssetFactoryState {
    get {return _storage._state ?? Ocap_AssetFactoryState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RequestListFactories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _storage._paging ?? Ocap_Page()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var ownerAddress: String {
    get {return _storage._ownerAddress}
    set {_uniqueStorage()._ownerAddress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ResponseListFactories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: Ocap_PageInfo {
    get {return _storage._page ?? Ocap_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var factories: [Ocap_IndexedFactoryState] {
    get {return _storage._factories}
    set {_uniqueStorage()._factories = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// account/factory tokens
public struct Ocap_RequestGetAccountTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be account of factory address
  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetAccountTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var tokens: [Ocap_AccountToken] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_RequestSendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSendTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "wallet"),
    3: .same(proto: "token"),
    4: .same(proto: "commit"),
  ]

  fileprivate class _StorageClass {
    var _tx: String = String()
    var _wallet: Ocap_WalletInfo? = nil
    var _token: String = String()
    var _commit: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tx = source._tx
      _wallet = source._wallet
      _token = source._token
      _commit = source._commit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._tx)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._wallet)
        case 3: try decoder.decodeSingularStringField(value: &_storage._token)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._commit)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._tx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tx, fieldNumber: 1)
      }
      if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 3)
      }
      if _storage._commit != false {
        try visitor.visitSingularBoolField(value: _storage._commit, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestSendTx, rhs: Ocap_RequestSendTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tx != rhs_storage._tx {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._commit != rhs_storage._commit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseSendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSendTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseSendTx, rhs: Ocap_ResponseSendTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetTx, rhs: Ocap_RequestGetTx) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _info: Ocap_TransactionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetTx, rhs: Ocap_ResponseGetTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetBlock, rhs: Ocap_RequestGetBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "block"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _block: Ocap_BlockInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _block = source._block
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._block)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetBlock, rhs: Ocap_ResponseGetBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._block != rhs_storage._block {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "height_filter"),
    3: .standard(proto: "empty_excluded"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _heightFilter: Ocap_RangeFilter? = nil
    var _emptyExcluded: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _heightFilter = source._heightFilter
      _emptyExcluded = source._emptyExcluded
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._heightFilter)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._emptyExcluded)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._heightFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._emptyExcluded != false {
        try visitor.visitSingularBoolField(value: _storage._emptyExcluded, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetBlocks, rhs: Ocap_RequestGetBlocks) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._heightFilter != rhs_storage._heightFilter {return false}
        if _storage._emptyExcluded != rhs_storage._emptyExcluded {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _blocks: [Ocap_BlockInfoSimple] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _blocks = source._blocks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._blocks)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._blocks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blocks, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetBlocks, rhs: Ocap_ResponseGetBlocks) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._blocks != rhs_storage._blocks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetAccountState, rhs: Ocap_RequestGetAccountState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _state: Ocap_AccountState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAccountState, rhs: Ocap_ResponseGetAccountState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetAssetState, rhs: Ocap_RequestGetAssetState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _state: Ocap_AssetState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAssetState, rhs: Ocap_ResponseGetAssetState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetForgeState, rhs: Ocap_RequestGetForgeState) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _state: Ocap_ForgeState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetForgeState, rhs: Ocap_ResponseGetForgeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetSwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetSwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetSwapState, rhs: Ocap_RequestGetSwapState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetSwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetSwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _state: Ocap_SwapState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetSwapState, rhs: Ocap_ResponseGetSwapState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetDelegateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetDelegateState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetDelegateState, rhs: Ocap_RequestGetDelegateState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetDelegateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetDelegateState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _state: Ocap_DelegateState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetDelegateState, rhs: Ocap_ResponseGetDelegateState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetChainInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetChainInfo, rhs: Ocap_RequestGetChainInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetChainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _info: Ocap_ChainInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetChainInfo, rhs: Ocap_ResponseGetChainInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetNodeInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetNodeInfo, rhs: Ocap_RequestGetNodeInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetNodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _info: Ocap_NodeInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetNodeInfo, rhs: Ocap_ResponseGetNodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSearch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestSearch, rhs: Ocap_RequestSearch) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSearch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.txs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseSearch, rhs: Ocap_ResponseSearch) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetUnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetUnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetUnconfirmedTxs, rhs: Ocap_RequestGetUnconfirmedTxs) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetUnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetUnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .standard(proto: "unconfirmed_txs"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _unconfirmedTxs: Ocap_UnconfirmedTxs? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _unconfirmedTxs = source._unconfirmedTxs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._unconfirmedTxs)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._unconfirmedTxs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetUnconfirmedTxs, rhs: Ocap_ResponseGetUnconfirmedTxs) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._unconfirmedTxs != rhs_storage._unconfirmedTxs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetNetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetNetInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetNetInfo, rhs: Ocap_RequestGetNetInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetNetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetNetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "net_info"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _netInfo: Ocap_NetInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _netInfo = source._netInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._netInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._netInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetNetInfo, rhs: Ocap_ResponseGetNetInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._netInfo != rhs_storage._netInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetValidatorsInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetValidatorsInfo, rhs: Ocap_RequestGetValidatorsInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetValidatorsInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "validators_info"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _validatorsInfo: Ocap_ValidatorsInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _validatorsInfo = source._validatorsInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._validatorsInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._validatorsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetValidatorsInfo, rhs: Ocap_ResponseGetValidatorsInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._validatorsInfo != rhs_storage._validatorsInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestSubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.topic)
      case 2: try decoder.decodeSingularStringField(value: &self.filter)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestSubscribe, rhs: Ocap_RequestSubscribe) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseSubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "topic"),
    3: .same(proto: "transfer"),
    4: .standard(proto: "account_migrate"),
    5: .same(proto: "confirm"),
    6: .standard(proto: "create_asset"),
    7: .same(proto: "exchange"),
    16: .standard(proto: "begin_block"),
    17: .standard(proto: "end_block"),
    19: .same(proto: "declare"),
    20: .standard(proto: "update_asset"),
    21: .standard(proto: "consensus_upgrade"),
    23: .standard(proto: "sys_upgrade"),
    24: .same(proto: "stake"),
    25: .same(proto: "delegate"),
    28: .standard(proto: "revoke_delegate"),
    29: .standard(proto: "deposit_token"),
    30: .standard(proto: "withdraw_token"),
    31: .standard(proto: "approve_withdraw"),
    32: .standard(proto: "revoke_withdraw"),
    33: .standard(proto: "setup_swap"),
    34: .standard(proto: "revoke_swap"),
    35: .standard(proto: "retrieve_swap"),
    36: .same(proto: "poke"),
    38: .standard(proto: "consume_asset"),
    39: .standard(proto: "acquire_asset"),
    40: .standard(proto: "upgrade_node"),
    41: .standard(proto: "update_validator"),
    42: .standard(proto: "update_consensus_params"),
    129: .standard(proto: "account_state"),
    130: .standard(proto: "asset_state"),
    131: .standard(proto: "forge_state"),
    134: .standard(proto: "delegate_state"),
    135: .standard(proto: "swap_state"),
    136: .standard(proto: "create_token"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _value: Ocap_ResponseSubscribe.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._value = .topic(v)}
        case 3:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .transfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .transfer(v)}
        case 4:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .accountMigrate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .accountMigrate(v)}
        case 5:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .confirm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .confirm(v)}
        case 6:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .createAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .createAsset(v)}
        case 7:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .exchange(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .exchange(v)}
        case 16:
          var v: Vendor_RequestBeginBlock?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .beginBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .beginBlock(v)}
        case 17:
          var v: Vendor_RequestEndBlock?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .endBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .endBlock(v)}
        case 19:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .declare(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .declare(v)}
        case 20:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .updateAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .updateAsset(v)}
        case 21:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .consensusUpgrade(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .consensusUpgrade(v)}
        case 23:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .sysUpgrade(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .sysUpgrade(v)}
        case 24:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .stake(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .stake(v)}
        case 25:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .delegate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .delegate(v)}
        case 28:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .revokeDelegate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .revokeDelegate(v)}
        case 29:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .depositToken(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .depositToken(v)}
        case 30:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .withdrawToken(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .withdrawToken(v)}
        case 31:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .approveWithdraw(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .approveWithdraw(v)}
        case 32:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .revokeWithdraw(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .revokeWithdraw(v)}
        case 33:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .setupSwap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .setupSwap(v)}
        case 34:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .revokeSwap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .revokeSwap(v)}
        case 35:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .retrieveSwap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .retrieveSwap(v)}
        case 36:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .poke(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .poke(v)}
        case 38:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .consumeAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .consumeAsset(v)}
        case 39:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .acquireAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .acquireAsset(v)}
        case 40:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .upgradeNode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .upgradeNode(v)}
        case 41:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .updateValidator(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .updateValidator(v)}
        case 42:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .updateConsensusParams(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .updateConsensusParams(v)}
        case 129:
          var v: Ocap_AccountState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .accountState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .accountState(v)}
        case 130:
          var v: Ocap_AssetState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .assetState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .assetState(v)}
        case 131:
          var v: Ocap_ForgeState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .forgeState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .forgeState(v)}
        case 134:
          var v: Ocap_DelegateState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .delegateState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .delegateState(v)}
        case 135:
          var v: Ocap_SwapState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .swapState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .swapState(v)}
        case 136:
          var v: Ocap_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .createToken(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .createToken(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      switch _storage._value {
      case .topic(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .transfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .accountMigrate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .confirm(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .createAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .exchange(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .beginBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .endBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .declare(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .updateAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .consensusUpgrade(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .sysUpgrade(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .stake(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .delegate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .revokeDelegate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case .depositToken(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      case .withdrawToken(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .approveWithdraw(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .revokeWithdraw(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      case .setupSwap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      case .revokeSwap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      case .retrieveSwap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      case .poke(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      case .consumeAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      case .acquireAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      case .upgradeNode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      case .updateValidator(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      case .updateConsensusParams(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      case .accountState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
      case .assetState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
      case .forgeState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
      case .delegateState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 134)
      case .swapState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 135)
      case .createToken(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 136)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseSubscribe, rhs: Ocap_ResponseSubscribe) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestUnsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestUnsubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.topic)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestUnsubscribe, rhs: Ocap_RequestUnsubscribe) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseUnsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseUnsubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseUnsubscribe, rhs: Ocap_ResponseUnsubscribe) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parsed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.parsed)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parsed != false {
      try visitor.visitSingularBoolField(value: self.parsed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetConfig, rhs: Ocap_RequestGetConfig) -> Bool {
    if lhs.parsed != rhs.parsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.config)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.config.isEmpty {
      try visitor.visitSingularStringField(value: self.config, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetConfig, rhs: Ocap_ResponseGetConfig) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ByDay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByDay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_date"),
    2: .standard(proto: "end_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.startDate)
      case 2: try decoder.decodeSingularStringField(value: &self.endDate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 1)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ByDay, rhs: Ocap_ByDay) -> Bool {
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ByHour: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByHour"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.date)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ByHour, rhs: Ocap_ByHour) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "day_info"),
    2: .same(proto: "date"),
  ]

  fileprivate class _StorageClass {
    var _value: Ocap_RequestGetForgeStats.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Ocap_ByDay?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .dayInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .dayInfo(v)}
        case 2:
          var v: Ocap_ByHour?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .date(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .date(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._value {
      case .dayInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .date(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetForgeStats, rhs: Ocap_RequestGetForgeStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "forge_stats"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _forgeStats: Ocap_ForgeStats? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _forgeStats = source._forgeStats
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._forgeStats)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._forgeStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetForgeStats, rhs: Ocap_ResponseGetForgeStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._forgeStats != rhs_storage._forgeStats {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "time_filter"),
    3: .standard(proto: "address_filter"),
    4: .standard(proto: "type_filter"),
    5: .standard(proto: "validity_filter"),
    6: .standard(proto: "factory_filter"),
    7: .standard(proto: "token_filter"),
    8: .standard(proto: "asset_filter"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _timeFilter: Ocap_TimeFilter? = nil
    var _addressFilter: Ocap_AddressFilter? = nil
    var _typeFilter: Ocap_TypeFilter? = nil
    var _validityFilter: Ocap_ValidityFilter? = nil
    var _factoryFilter: Ocap_FactoryFilter? = nil
    var _tokenFilter: Ocap_TokenFilter? = nil
    var _assetFilter: Ocap_AssetFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _timeFilter = source._timeFilter
      _addressFilter = source._addressFilter
      _typeFilter = source._typeFilter
      _validityFilter = source._validityFilter
      _factoryFilter = source._factoryFilter
      _tokenFilter = source._tokenFilter
      _assetFilter = source._assetFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._timeFilter)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._addressFilter)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._typeFilter)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._validityFilter)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._factoryFilter)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._tokenFilter)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._assetFilter)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._timeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._addressFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._typeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._validityFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._factoryFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._tokenFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._assetFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTransactions, rhs: Ocap_RequestListTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._timeFilter != rhs_storage._timeFilter {return false}
        if _storage._addressFilter != rhs_storage._addressFilter {return false}
        if _storage._typeFilter != rhs_storage._typeFilter {return false}
        if _storage._validityFilter != rhs_storage._validityFilter {return false}
        if _storage._factoryFilter != rhs_storage._factoryFilter {return false}
        if _storage._tokenFilter != rhs_storage._tokenFilter {return false}
        if _storage._assetFilter != rhs_storage._assetFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "transactions"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _transactions: [Ocap_IndexedTransaction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _transactions = source._transactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTransactions, rhs: Ocap_ResponseListTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._transactions != rhs_storage._transactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "factory_address"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _ownerAddress: String = String()
    var _factoryAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _ownerAddress = source._ownerAddress
      _factoryAddress = source._factoryAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._ownerAddress)
        case 3: try decoder.decodeSingularStringField(value: &_storage._factoryAddress)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._ownerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerAddress, fieldNumber: 2)
      }
      if !_storage._factoryAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._factoryAddress, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListAssets, rhs: Ocap_RequestListAssets) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._ownerAddress != rhs_storage._ownerAddress {return false}
        if _storage._factoryAddress != rhs_storage._factoryAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "assets"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _assets: [Ocap_IndexedAssetState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _assets = source._assets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._assets)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._assets, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListAssets, rhs: Ocap_ResponseListAssets) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._assets != rhs_storage._assets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListStakes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListStakes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "address_filter"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _addressFilter: Ocap_AddressFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _addressFilter = source._addressFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._addressFilter)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._addressFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListStakes, rhs: Ocap_RequestListStakes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._addressFilter != rhs_storage._addressFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListStakes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListStakes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "stakes"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _stakes: [Ocap_IndexedStakeState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _stakes = source._stakes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._stakes)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._stakes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stakes, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListStakes, rhs: Ocap_ResponseListStakes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._stakes != rhs_storage._stakes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.ownerAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListAccount, rhs: Ocap_RequestListAccount) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "account"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _account: Ocap_IndexedAccountState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _account = source._account
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._account)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListAccount, rhs: Ocap_ResponseListAccount) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._account != rhs_storage._account {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTopAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTopAccounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "tokenAddress"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _tokenAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _tokenAddress = source._tokenAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._tokenAddress)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._tokenAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tokenAddress, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTopAccounts, rhs: Ocap_RequestListTopAccounts) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._tokenAddress != rhs_storage._tokenAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTopAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTopAccounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "accounts"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _accounts: [Ocap_IndexedAccountState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _accounts = source._accounts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._accounts)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._accounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._accounts, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTopAccounts, rhs: Ocap_ResponseListTopAccounts) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._accounts != rhs_storage._accounts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListAssetTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAssetTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "address"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _address: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _address = source._address
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListAssetTransactions, rhs: Ocap_RequestListAssetTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._address != rhs_storage._address {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListAssetTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAssetTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "transactions"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _transactions: [Ocap_IndexedTransaction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _transactions = source._transactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListAssetTransactions, rhs: Ocap_ResponseListAssetTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._transactions != rhs_storage._transactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "proposer"),
    3: .standard(proto: "time_filter"),
    4: .standard(proto: "height_filter"),
    5: .standard(proto: "num_txs_filter"),
    6: .standard(proto: "num_invalid_txs_filter"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _proposer: String = String()
    var _timeFilter: Ocap_TimeFilter? = nil
    var _heightFilter: Ocap_RangeFilter? = nil
    var _numTxsFilter: Ocap_RangeFilter? = nil
    var _numInvalidTxsFilter: Ocap_RangeFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _proposer = source._proposer
      _timeFilter = source._timeFilter
      _heightFilter = source._heightFilter
      _numTxsFilter = source._numTxsFilter
      _numInvalidTxsFilter = source._numInvalidTxsFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._proposer)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._timeFilter)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._heightFilter)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._numTxsFilter)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._numInvalidTxsFilter)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proposer, fieldNumber: 2)
      }
      if let v = _storage._timeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._heightFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._numTxsFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._numInvalidTxsFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListBlocks, rhs: Ocap_RequestListBlocks) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._timeFilter != rhs_storage._timeFilter {return false}
        if _storage._heightFilter != rhs_storage._heightFilter {return false}
        if _storage._numTxsFilter != rhs_storage._numTxsFilter {return false}
        if _storage._numInvalidTxsFilter != rhs_storage._numInvalidTxsFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _blocks: [Ocap_IndexedBlock] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _blocks = source._blocks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._blocks)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._blocks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blocks, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListBlocks, rhs: Ocap_ResponseListBlocks) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._blocks != rhs_storage._blocks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListSwap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .same(proto: "available"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _sender: String = String()
    var _receiver: String = String()
    var _available: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _sender = source._sender
      _receiver = source._receiver
      _available = source._available
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._sender)
        case 3: try decoder.decodeSingularStringField(value: &_storage._receiver)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._available)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 2)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 3)
      }
      if _storage._available != false {
        try visitor.visitSingularBoolField(value: _storage._available, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListSwap, rhs: Ocap_RequestListSwap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._available != rhs_storage._available {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListSwap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "swap"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _swap: [Ocap_SwapState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _swap = source._swap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._swap)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._swap.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._swap, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListSwap, rhs: Ocap_ResponseListSwap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._swap != rhs_storage._swap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetSwapStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetSwapStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetSwapStatistics, rhs: Ocap_RequestGetSwapStatistics) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetSwapStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetSwapStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "statistics"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _statistics: Ocap_SwapStatistics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _statistics = source._statistics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._statistics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._statistics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetSwapStatistics, rhs: Ocap_ResponseGetSwapStatistics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._statistics != rhs_storage._statistics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetHealthStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetHealthStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetHealthStatus, rhs: Ocap_RequestGetHealthStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetHealthStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetHealthStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "health_status"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _healthStatus: Ocap_HealthStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _healthStatus = source._healthStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._healthStatus)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._healthStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetHealthStatus, rhs: Ocap_ResponseGetHealthStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._healthStatus != rhs_storage._healthStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetTokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetTokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetTokenState, rhs: Ocap_RequestGetTokenState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetTokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetTokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _state: Ocap_TokenState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetTokenState, rhs: Ocap_ResponseGetTokenState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "issuer_address"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _issuerAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _issuerAddress = source._issuerAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._issuerAddress)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._issuerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuerAddress, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTokens, rhs: Ocap_RequestListTokens) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._issuerAddress != rhs_storage._issuerAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "tokens"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _tokens: [Ocap_IndexedTokenState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _tokens = source._tokens
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._tokens)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTokens, rhs: Ocap_ResponseListTokens) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetFactoryState, rhs: Ocap_RequestGetFactoryState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _state: Ocap_AssetFactoryState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetFactoryState, rhs: Ocap_ResponseGetFactoryState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListFactories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListFactories"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "owner_address"),
  ]

  fileprivate class _StorageClass {
    var _paging: Ocap_Page? = nil
    var _ownerAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _ownerAddress = source._ownerAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._ownerAddress)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._ownerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerAddress, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListFactories, rhs: Ocap_RequestListFactories) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._ownerAddress != rhs_storage._ownerAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListFactories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListFactories"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "factories"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _page: Ocap_PageInfo? = nil
    var _factories: [Ocap_IndexedFactoryState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _factories = source._factories
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._factories)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._factories.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._factories, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListFactories, rhs: Ocap_ResponseListFactories) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._factories != rhs_storage._factories {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetAccountTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAccountTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetAccountTokens, rhs: Ocap_RequestGetAccountTokens) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAccountTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAccountTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.tokens)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAccountTokens, rhs: Ocap_ResponseGetAccountTokens) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
