// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// create_tx(itx, wallet, token)
public struct ForgeAbi_RequestCreateTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itx: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._itx ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._itx = newValue}
  }
  /// Returns true if `itx` has been explicitly set.
  public var hasItx: Bool {return _storage._itx != nil}
  /// Clears the value of `itx`. Subsequent reads from it will return its default value.
  public mutating func clearItx() {_uniqueStorage()._itx = nil}

  public var from: String {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  public var nonce: UInt64 {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var wallet: ForgeAbi_WalletInfo {
    get {return _storage._wallet ?? ForgeAbi_WalletInfo()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseCreateTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var tx: ForgeAbi_Transaction {
    get {return _storage._tx ?? ForgeAbi_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  public var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  public mutating func clearTx() {_uniqueStorage()._tx = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// multisig(tx, wallet, token)
public struct ForgeAbi_RequestMultisig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: ForgeAbi_Transaction {
    get {return _storage._tx ?? ForgeAbi_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  public var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  public mutating func clearTx() {_uniqueStorage()._tx = nil}

  /// extra data for multisig
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var wallet: ForgeAbi_WalletInfo {
    get {return _storage._wallet ?? ForgeAbi_WalletInfo()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseMultisig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var tx: ForgeAbi_Transaction {
    get {return _storage._tx ?? ForgeAbi_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  public var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  public mutating func clearTx() {_uniqueStorage()._tx = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// send_tx(tx, wallet, token, commit \\ false)
public struct ForgeAbi_RequestSendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: ForgeAbi_Transaction {
    get {return _storage._tx ?? ForgeAbi_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  public var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  public mutating func clearTx() {_uniqueStorage()._tx = nil}

  public var wallet: ForgeAbi_WalletInfo {
    get {return _storage._wallet ?? ForgeAbi_WalletInfo()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var commit: Bool {
    get {return _storage._commit}
    set {_uniqueStorage()._commit = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseSendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// get_tx(hash)
public struct ForgeAbi_RequestGetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var info: ForgeAbi_TransactionInfo {
    get {return _storage._info ?? ForgeAbi_TransactionInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_block(height)
public struct ForgeAbi_RequestGetBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var block: ForgeAbi_BlockInfo {
    get {return _storage._block ?? ForgeAbi_BlockInfo()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {_uniqueStorage()._block = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var heightFilter: ForgeAbi_RangeFilter {
    get {return _storage._heightFilter ?? ForgeAbi_RangeFilter()}
    set {_uniqueStorage()._heightFilter = newValue}
  }
  /// Returns true if `heightFilter` has been explicitly set.
  public var hasHeightFilter: Bool {return _storage._heightFilter != nil}
  /// Clears the value of `heightFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHeightFilter() {_uniqueStorage()._heightFilter = nil}

  public var emptyExcluded: Bool {
    get {return _storage._emptyExcluded}
    set {_uniqueStorage()._emptyExcluded = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseGetBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var blocks: [ForgeAbi_BlockInfoSimple] {
    get {return _storage._blocks}
    set {_uniqueStorage()._blocks = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// create_wallet(moniker, passphrase): create an account locally
public struct ForgeAbi_RequestCreateWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var passphrase: String {
    get {return _storage._passphrase}
    set {_uniqueStorage()._passphrase = newValue}
  }

  public var type: ForgeAbi_WalletType {
    get {return _storage._type ?? ForgeAbi_WalletType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseCreateWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var wallet: ForgeAbi_WalletInfo {
    get {return _storage._wallet ?? ForgeAbi_WalletInfo()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// load_wallet(address, passphrase): load account to memory with given
/// passphrase
public struct ForgeAbi_RequestLoadWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var passphrase: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseLoadWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var wallet: ForgeAbi_WalletInfo {
    get {return _storage._wallet ?? ForgeAbi_WalletInfo()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// recover_wallet(data, passphrase): recover to a keystore with given
/// passphrase. data could be seed words or bytes of secret key.
public struct ForgeAbi_RequestRecoverWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  public var type: ForgeAbi_WalletType {
    get {return _storage._type ?? ForgeAbi_WalletType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var passphrase: String {
    get {return _storage._passphrase}
    set {_uniqueStorage()._passphrase = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseRecoverWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  public var wallet: ForgeAbi_WalletInfo {
    get {return _storage._wallet ?? ForgeAbi_WalletInfo()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// list_wallet(): list accounts stored in this node
public struct ForgeAbi_RequestListWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseListWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// remove_wallet(hash): remove account by hash for this node
public struct ForgeAbi_RequestRemoveWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseRemoveWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_RequestDeclareNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validator: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseDeclareNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var wallet: ForgeAbi_WalletInfo {
    get {return _storage._wallet ?? ForgeAbi_WalletInfo()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_account_state(address, key): retrieve the current state from a list of
/// wallet addresses, return the value of the key. If key is omitted, return
/// entire account states
public struct ForgeAbi_RequestGetAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: ForgeAbi_AccountState {
    get {return _storage._state ?? ForgeAbi_AccountState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: ForgeAbi_AssetState {
    get {return _storage._state ?? ForgeAbi_AssetState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetProtocolState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetProtocolState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: ForgeAbi_ProtocolState {
    get {return _storage._state ?? ForgeAbi_ProtocolState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetStakeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetStakeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: ForgeAbi_StakeState {
    get {return _storage._state ?? ForgeAbi_StakeState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_forge_state(key): retrieve Forge state by key. If key is omitted, return
/// entire Forge state
public struct ForgeAbi_RequestGetForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: ForgeAbi_ForgeState {
    get {return _storage._state ?? ForgeAbi_ForgeState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetTetherState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetTetherState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: ForgeAbi_TetherState {
    get {return _storage._state ?? ForgeAbi_TetherState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetSwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetSwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var state: ForgeAbi_SwapState {
    get {return _storage._state ?? ForgeAbi_SwapState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// store_file(chunk): store a piece of data into ipfs, return its hash address
public struct ForgeAbi_RequestStoreFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chunk: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseStoreFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// load_file(hash): load a hash address from ipfs and return the file content
public struct ForgeAbi_RequestLoadFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseLoadFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var chunk: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// pin_file(hash): pin a hash address into ipfs, return ok if success
public struct ForgeAbi_RequestPinFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponsePinFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// get_chain_info(): retrieve the current chain information
public struct ForgeAbi_RequestGetChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var info: ForgeAbi_ChainInfo {
    get {return _storage._info ?? ForgeAbi_ChainInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_node_info(): retrieve the current node information
public struct ForgeAbi_RequestGetNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var info: ForgeAbi_NodeInfo {
    get {return _storage._info ?? ForgeAbi_NodeInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// search(term): retrieve related transactions by a search term (prefix match)
public struct ForgeAbi_RequestSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var txs: [ForgeAbi_TransactionInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_RequestGetUnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseGetUnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var unconfirmedTxs: ForgeAbi_UnconfirmedTxs {
    get {return _storage._unconfirmedTxs ?? ForgeAbi_UnconfirmedTxs()}
    set {_uniqueStorage()._unconfirmedTxs = newValue}
  }
  /// Returns true if `unconfirmedTxs` has been explicitly set.
  public var hasUnconfirmedTxs: Bool {return _storage._unconfirmedTxs != nil}
  /// Clears the value of `unconfirmedTxs`. Subsequent reads from it will return its default value.
  public mutating func clearUnconfirmedTxs() {_uniqueStorage()._unconfirmedTxs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetNetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetNetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var netInfo: ForgeAbi_NetInfo {
    get {return _storage._netInfo ?? ForgeAbi_NetInfo()}
    set {_uniqueStorage()._netInfo = newValue}
  }
  /// Returns true if `netInfo` has been explicitly set.
  public var hasNetInfo: Bool {return _storage._netInfo != nil}
  /// Clears the value of `netInfo`. Subsequent reads from it will return its default value.
  public mutating func clearNetInfo() {_uniqueStorage()._netInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var validatorsInfo: ForgeAbi_ValidatorsInfo {
    get {return _storage._validatorsInfo ?? ForgeAbi_ValidatorsInfo()}
    set {_uniqueStorage()._validatorsInfo = newValue}
  }
  /// Returns true if `validatorsInfo` has been explicitly set.
  public var hasValidatorsInfo: Bool {return _storage._validatorsInfo != nil}
  /// Clears the value of `validatorsInfo`. Subsequent reads from it will return its default value.
  public mutating func clearValidatorsInfo() {_uniqueStorage()._validatorsInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// filter could be: value.header.height > 10086 and value.byzantine_validators
/// != []
public struct ForgeAbi_RequestSubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseSubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var topic: String {
    get {
      if case .topic(let v)? = _storage._value {return v}
      return String()
    }
    set {_uniqueStorage()._value = .topic(newValue)}
  }

  public var transfer: ForgeAbi_Transaction {
    get {
      if case .transfer(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .transfer(newValue)}
  }

  public var accountMigrate: ForgeAbi_Transaction {
    get {
      if case .accountMigrate(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .accountMigrate(newValue)}
  }

  public var confirm: ForgeAbi_Transaction {
    get {
      if case .confirm(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .confirm(newValue)}
  }

  public var createAsset: ForgeAbi_Transaction {
    get {
      if case .createAsset(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .createAsset(newValue)}
  }

  public var exchange: ForgeAbi_Transaction {
    get {
      if case .exchange(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .exchange(newValue)}
  }

  public var revoke: ForgeAbi_Transaction {
    get {
      if case .revoke(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .revoke(newValue)}
  }

  public var beginBlock: AbciVendor_RequestBeginBlock {
    get {
      if case .beginBlock(let v)? = _storage._value {return v}
      return AbciVendor_RequestBeginBlock()
    }
    set {_uniqueStorage()._value = .beginBlock(newValue)}
  }

  public var endBlock: AbciVendor_RequestEndBlock {
    get {
      if case .endBlock(let v)? = _storage._value {return v}
      return AbciVendor_RequestEndBlock()
    }
    set {_uniqueStorage()._value = .endBlock(newValue)}
  }

  public var declare: ForgeAbi_Transaction {
    get {
      if case .declare(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .declare(newValue)}
  }

  public var updateAsset: ForgeAbi_Transaction {
    get {
      if case .updateAsset(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .updateAsset(newValue)}
  }

  public var consensusUpgrade: ForgeAbi_Transaction {
    get {
      if case .consensusUpgrade(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .consensusUpgrade(newValue)}
  }

  public var declareFile: ForgeAbi_Transaction {
    get {
      if case .declareFile(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .declareFile(newValue)}
  }

  public var sysUpgrade: ForgeAbi_Transaction {
    get {
      if case .sysUpgrade(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .sysUpgrade(newValue)}
  }

  public var stake: ForgeAbi_Transaction {
    get {
      if case .stake(let v)? = _storage._value {return v}
      return ForgeAbi_Transaction()
    }
    set {_uniqueStorage()._value = .stake(newValue)}
  }

  public var accountState: ForgeAbi_AccountState {
    get {
      if case .accountState(let v)? = _storage._value {return v}
      return ForgeAbi_AccountState()
    }
    set {_uniqueStorage()._value = .accountState(newValue)}
  }

  public var assetState: ForgeAbi_AssetState {
    get {
      if case .assetState(let v)? = _storage._value {return v}
      return ForgeAbi_AssetState()
    }
    set {_uniqueStorage()._value = .assetState(newValue)}
  }

  public var forgeState: ForgeAbi_ForgeState {
    get {
      if case .forgeState(let v)? = _storage._value {return v}
      return ForgeAbi_ForgeState()
    }
    set {_uniqueStorage()._value = .forgeState(newValue)}
  }

  public var stakeState: ForgeAbi_StakeState {
    get {
      if case .stakeState(let v)? = _storage._value {return v}
      return ForgeAbi_StakeState()
    }
    set {_uniqueStorage()._value = .stakeState(newValue)}
  }

  public var protocolState: ForgeAbi_ProtocolState {
    get {
      if case .protocolState(let v)? = _storage._value {return v}
      return ForgeAbi_ProtocolState()
    }
    set {_uniqueStorage()._value = .protocolState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case topic(String)
    case transfer(ForgeAbi_Transaction)
    case accountMigrate(ForgeAbi_Transaction)
    case confirm(ForgeAbi_Transaction)
    case createAsset(ForgeAbi_Transaction)
    case exchange(ForgeAbi_Transaction)
    case revoke(ForgeAbi_Transaction)
    case beginBlock(AbciVendor_RequestBeginBlock)
    case endBlock(AbciVendor_RequestEndBlock)
    case declare(ForgeAbi_Transaction)
    case updateAsset(ForgeAbi_Transaction)
    case consensusUpgrade(ForgeAbi_Transaction)
    case declareFile(ForgeAbi_Transaction)
    case sysUpgrade(ForgeAbi_Transaction)
    case stake(ForgeAbi_Transaction)
    case accountState(ForgeAbi_AccountState)
    case assetState(ForgeAbi_AssetState)
    case forgeState(ForgeAbi_ForgeState)
    case stakeState(ForgeAbi_StakeState)
    case protocolState(ForgeAbi_ProtocolState)

  #if !swift(>=4.1)
    public static func ==(lhs: ForgeAbi_ResponseSubscribe.OneOf_Value, rhs: ForgeAbi_ResponseSubscribe.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.topic(let l), .topic(let r)): return l == r
      case (.transfer(let l), .transfer(let r)): return l == r
      case (.accountMigrate(let l), .accountMigrate(let r)): return l == r
      case (.confirm(let l), .confirm(let r)): return l == r
      case (.createAsset(let l), .createAsset(let r)): return l == r
      case (.exchange(let l), .exchange(let r)): return l == r
      case (.revoke(let l), .revoke(let r)): return l == r
      case (.beginBlock(let l), .beginBlock(let r)): return l == r
      case (.endBlock(let l), .endBlock(let r)): return l == r
      case (.declare(let l), .declare(let r)): return l == r
      case (.updateAsset(let l), .updateAsset(let r)): return l == r
      case (.consensusUpgrade(let l), .consensusUpgrade(let r)): return l == r
      case (.declareFile(let l), .declareFile(let r)): return l == r
      case (.sysUpgrade(let l), .sysUpgrade(let r)): return l == r
      case (.stake(let l), .stake(let r)): return l == r
      case (.accountState(let l), .accountState(let r)): return l == r
      case (.assetState(let l), .assetState(let r)): return l == r
      case (.forgeState(let l), .forgeState(let r)): return l == r
      case (.stakeState(let l), .stakeState(let r)): return l == r
      case (.protocolState(let l), .protocolState(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestUnsubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseUnsubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// get config
public struct ForgeAbi_RequestGetConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parsed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var config: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ByDay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startDate: String = String()

  public var endDate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ByHour {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_RequestGetForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var dayInfo: ForgeAbi_ByDay {
    get {
      if case .dayInfo(let v)? = _storage._value {return v}
      return ForgeAbi_ByDay()
    }
    set {_uniqueStorage()._value = .dayInfo(newValue)}
  }

  public var date: ForgeAbi_ByHour {
    get {
      if case .date(let v)? = _storage._value {return v}
      return ForgeAbi_ByHour()
    }
    set {_uniqueStorage()._value = .date(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case dayInfo(ForgeAbi_ByDay)
    case date(ForgeAbi_ByHour)

  #if !swift(>=4.1)
    public static func ==(lhs: ForgeAbi_RequestGetForgeStats.OneOf_Value, rhs: ForgeAbi_RequestGetForgeStats.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.dayInfo(let l), .dayInfo(let r)): return l == r
      case (.date(let l), .date(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseGetForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var forgeStats: ForgeAbi_ForgeStats {
    get {return _storage._forgeStats ?? ForgeAbi_ForgeStats()}
    set {_uniqueStorage()._forgeStats = newValue}
  }
  /// Returns true if `forgeStats` has been explicitly set.
  public var hasForgeStats: Bool {return _storage._forgeStats != nil}
  /// Clears the value of `forgeStats`. Subsequent reads from it will return its default value.
  public mutating func clearForgeStats() {_uniqueStorage()._forgeStats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var timeFilter: ForgeAbi_TimeFilter {
    get {return _storage._timeFilter ?? ForgeAbi_TimeFilter()}
    set {_uniqueStorage()._timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return _storage._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {_uniqueStorage()._timeFilter = nil}

  public var addressFilter: ForgeAbi_AddressFilter {
    get {return _storage._addressFilter ?? ForgeAbi_AddressFilter()}
    set {_uniqueStorage()._addressFilter = newValue}
  }
  /// Returns true if `addressFilter` has been explicitly set.
  public var hasAddressFilter: Bool {return _storage._addressFilter != nil}
  /// Clears the value of `addressFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAddressFilter() {_uniqueStorage()._addressFilter = nil}

  public var typeFilter: ForgeAbi_TypeFilter {
    get {return _storage._typeFilter ?? ForgeAbi_TypeFilter()}
    set {_uniqueStorage()._typeFilter = newValue}
  }
  /// Returns true if `typeFilter` has been explicitly set.
  public var hasTypeFilter: Bool {return _storage._typeFilter != nil}
  /// Clears the value of `typeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTypeFilter() {_uniqueStorage()._typeFilter = nil}

  public var validityFilter: ForgeAbi_ValidityFilter {
    get {return _storage._validityFilter ?? ForgeAbi_ValidityFilter()}
    set {_uniqueStorage()._validityFilter = newValue}
  }
  /// Returns true if `validityFilter` has been explicitly set.
  public var hasValidityFilter: Bool {return _storage._validityFilter != nil}
  /// Clears the value of `validityFilter`. Subsequent reads from it will return its default value.
  public mutating func clearValidityFilter() {_uniqueStorage()._validityFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseListTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var transactions: [ForgeAbi_IndexedTransaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var ownerAddress: String {
    get {return _storage._ownerAddress}
    set {_uniqueStorage()._ownerAddress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseListAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var assets: [ForgeAbi_IndexedAssetState] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListStakes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var addressFilter: ForgeAbi_AddressFilter {
    get {return _storage._addressFilter ?? ForgeAbi_AddressFilter()}
    set {_uniqueStorage()._addressFilter = newValue}
  }
  /// Returns true if `addressFilter` has been explicitly set.
  public var hasAddressFilter: Bool {return _storage._addressFilter != nil}
  /// Clears the value of `addressFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAddressFilter() {_uniqueStorage()._addressFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseListStakes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var stakes: [ForgeAbi_IndexedStakeState] {
    get {return _storage._stakes}
    set {_uniqueStorage()._stakes = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ownerAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseListAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var account: ForgeAbi_IndexedAccountState {
    get {return _storage._account ?? ForgeAbi_IndexedAccountState()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListTopAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseListTopAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var accounts: [ForgeAbi_IndexedAccountState] {
    get {return _storage._accounts}
    set {_uniqueStorage()._accounts = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListAssetTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseListAssetTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var transactions: [ForgeAbi_IndexedTransaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var proposer: String {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  public var timeFilter: ForgeAbi_TimeFilter {
    get {return _storage._timeFilter ?? ForgeAbi_TimeFilter()}
    set {_uniqueStorage()._timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return _storage._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {_uniqueStorage()._timeFilter = nil}

  public var heightFilter: ForgeAbi_RangeFilter {
    get {return _storage._heightFilter ?? ForgeAbi_RangeFilter()}
    set {_uniqueStorage()._heightFilter = newValue}
  }
  /// Returns true if `heightFilter` has been explicitly set.
  public var hasHeightFilter: Bool {return _storage._heightFilter != nil}
  /// Clears the value of `heightFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHeightFilter() {_uniqueStorage()._heightFilter = nil}

  public var numTxsFilter: ForgeAbi_RangeFilter {
    get {return _storage._numTxsFilter ?? ForgeAbi_RangeFilter()}
    set {_uniqueStorage()._numTxsFilter = newValue}
  }
  /// Returns true if `numTxsFilter` has been explicitly set.
  public var hasNumTxsFilter: Bool {return _storage._numTxsFilter != nil}
  /// Clears the value of `numTxsFilter`. Subsequent reads from it will return its default value.
  public mutating func clearNumTxsFilter() {_uniqueStorage()._numTxsFilter = nil}

  public var numInvalidTxsFilter: ForgeAbi_RangeFilter {
    get {return _storage._numInvalidTxsFilter ?? ForgeAbi_RangeFilter()}
    set {_uniqueStorage()._numInvalidTxsFilter = newValue}
  }
  /// Returns true if `numInvalidTxsFilter` has been explicitly set.
  public var hasNumInvalidTxsFilter: Bool {return _storage._numInvalidTxsFilter != nil}
  /// Clears the value of `numInvalidTxsFilter`. Subsequent reads from it will return its default value.
  public mutating func clearNumInvalidTxsFilter() {_uniqueStorage()._numInvalidTxsFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseListBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var blocks: [ForgeAbi_IndexedBlock] {
    get {return _storage._blocks}
    set {_uniqueStorage()._blocks = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListTethers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var depositor: String {
    get {return _storage._depositor}
    set {_uniqueStorage()._depositor = newValue}
  }

  public var withdrawer: String {
    get {return _storage._withdrawer}
    set {_uniqueStorage()._withdrawer = newValue}
  }

  public var custodian: String {
    get {return _storage._custodian}
    set {_uniqueStorage()._custodian = newValue}
  }

  public var available: Bool {
    get {return _storage._available}
    set {_uniqueStorage()._available = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseListTethers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var tethers: [ForgeAbi_TetherState] {
    get {return _storage._tethers}
    set {_uniqueStorage()._tethers = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestListSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: ForgeAbi_PageInput {
    get {return _storage._paging ?? ForgeAbi_PageInput()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  public var available: Bool {
    get {return _storage._available}
    set {_uniqueStorage()._available = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ResponseListSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var page: ForgeAbi_PageInfo {
    get {return _storage._page ?? ForgeAbi_PageInfo()}
    set {_uniqueStorage()._page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return _storage._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {_uniqueStorage()._page = nil}

  public var swap: [ForgeAbi_SwapState] {
    get {return _storage._swap}
    set {_uniqueStorage()._swap = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_RequestGetHealthStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ResponseGetHealthStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var healthStatus: ForgeAbi_HealthStatus {
    get {return _storage._healthStatus ?? ForgeAbi_HealthStatus()}
    set {_uniqueStorage()._healthStatus = newValue}
  }
  /// Returns true if `healthStatus` has been explicitly set.
  public var hasHealthStatus: Bool {return _storage._healthStatus != nil}
  /// Clears the value of `healthStatus`. Subsequent reads from it will return its default value.
  public mutating func clearHealthStatus() {_uniqueStorage()._healthStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "forge_abi"

extension ForgeAbi_RequestCreateTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestCreateTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itx"),
    2: .same(proto: "from"),
    3: .same(proto: "nonce"),
    4: .same(proto: "wallet"),
    5: .same(proto: "token"),
  ]

  fileprivate class _StorageClass {
    var _itx: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _from: String = String()
    var _nonce: UInt64 = 0
    var _wallet: ForgeAbi_WalletInfo? = nil
    var _token: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _itx = source._itx
      _from = source._from
      _nonce = source._nonce
      _wallet = source._wallet
      _token = source._token
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._itx)
        case 2: try decoder.decodeSingularStringField(value: &_storage._from)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._nonce)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._wallet)
        case 5: try decoder.decodeSingularStringField(value: &_storage._token)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._itx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._from.isEmpty {
        try visitor.visitSingularStringField(value: _storage._from, fieldNumber: 2)
      }
      if _storage._nonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nonce, fieldNumber: 3)
      }
      if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestCreateTx, rhs: ForgeAbi_RequestCreateTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._itx != rhs_storage._itx {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        if _storage._token != rhs_storage._token {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseCreateTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseCreateTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "tx"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _tx: ForgeAbi_Transaction? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _tx = source._tx
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._tx)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseCreateTx, rhs: ForgeAbi_ResponseCreateTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._tx != rhs_storage._tx {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestMultisig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestMultisig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "data"),
    3: .same(proto: "wallet"),
    4: .same(proto: "token"),
  ]

  fileprivate class _StorageClass {
    var _tx: ForgeAbi_Transaction? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _wallet: ForgeAbi_WalletInfo? = nil
    var _token: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tx = source._tx
      _data = source._data
      _wallet = source._wallet
      _token = source._token
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._tx)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._wallet)
        case 4: try decoder.decodeSingularStringField(value: &_storage._token)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestMultisig, rhs: ForgeAbi_RequestMultisig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tx != rhs_storage._tx {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        if _storage._token != rhs_storage._token {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseMultisig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseMultisig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "tx"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _tx: ForgeAbi_Transaction? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _tx = source._tx
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._tx)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseMultisig, rhs: ForgeAbi_ResponseMultisig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._tx != rhs_storage._tx {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestSendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSendTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "wallet"),
    3: .same(proto: "token"),
    4: .same(proto: "commit"),
  ]

  fileprivate class _StorageClass {
    var _tx: ForgeAbi_Transaction? = nil
    var _wallet: ForgeAbi_WalletInfo? = nil
    var _token: String = String()
    var _commit: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tx = source._tx
      _wallet = source._wallet
      _token = source._token
      _commit = source._commit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._tx)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._wallet)
        case 3: try decoder.decodeSingularStringField(value: &_storage._token)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._commit)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 3)
      }
      if _storage._commit != false {
        try visitor.visitSingularBoolField(value: _storage._commit, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestSendTx, rhs: ForgeAbi_RequestSendTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tx != rhs_storage._tx {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._commit != rhs_storage._commit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseSendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSendTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseSendTx, rhs: ForgeAbi_ResponseSendTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetTx, rhs: ForgeAbi_RequestGetTx) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _info: ForgeAbi_TransactionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetTx, rhs: ForgeAbi_ResponseGetTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetBlock, rhs: ForgeAbi_RequestGetBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "block"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _block: ForgeAbi_BlockInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _block = source._block
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._block)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetBlock, rhs: ForgeAbi_ResponseGetBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._block != rhs_storage._block {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "height_filter"),
    3: .standard(proto: "empty_excluded"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil
    var _heightFilter: ForgeAbi_RangeFilter? = nil
    var _emptyExcluded: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _heightFilter = source._heightFilter
      _emptyExcluded = source._emptyExcluded
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._heightFilter)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._emptyExcluded)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._heightFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._emptyExcluded != false {
        try visitor.visitSingularBoolField(value: _storage._emptyExcluded, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetBlocks, rhs: ForgeAbi_RequestGetBlocks) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._heightFilter != rhs_storage._heightFilter {return false}
        if _storage._emptyExcluded != rhs_storage._emptyExcluded {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _blocks: [ForgeAbi_BlockInfoSimple] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _blocks = source._blocks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._blocks)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._blocks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blocks, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetBlocks, rhs: ForgeAbi_ResponseGetBlocks) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._blocks != rhs_storage._blocks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestCreateWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestCreateWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "passphrase"),
    2: .same(proto: "type"),
    3: .same(proto: "moniker"),
  ]

  fileprivate class _StorageClass {
    var _passphrase: String = String()
    var _type: ForgeAbi_WalletType? = nil
    var _moniker: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _passphrase = source._passphrase
      _type = source._type
      _moniker = source._moniker
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._passphrase)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 3: try decoder.decodeSingularStringField(value: &_storage._moniker)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._passphrase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._passphrase, fieldNumber: 1)
      }
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestCreateWallet, rhs: ForgeAbi_RequestCreateWallet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._passphrase != rhs_storage._passphrase {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseCreateWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseCreateWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "token"),
    3: .same(proto: "wallet"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _token: String = String()
    var _wallet: ForgeAbi_WalletInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _token = source._token
      _wallet = source._wallet
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularStringField(value: &_storage._token)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._wallet)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 2)
      }
      if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseCreateWallet, rhs: ForgeAbi_ResponseCreateWallet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestLoadWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestLoadWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "passphrase"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularStringField(value: &self.passphrase)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.passphrase.isEmpty {
      try visitor.visitSingularStringField(value: self.passphrase, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestLoadWallet, rhs: ForgeAbi_RequestLoadWallet) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.passphrase != rhs.passphrase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseLoadWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseLoadWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "token"),
    3: .same(proto: "wallet"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _token: String = String()
    var _wallet: ForgeAbi_WalletInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _token = source._token
      _wallet = source._wallet
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularStringField(value: &_storage._token)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._wallet)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 2)
      }
      if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseLoadWallet, rhs: ForgeAbi_ResponseLoadWallet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestRecoverWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestRecoverWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "type"),
    3: .same(proto: "passphrase"),
    4: .same(proto: "moniker"),
  ]

  fileprivate class _StorageClass {
    var _data: Data = SwiftProtobuf.Internal.emptyData
    var _type: ForgeAbi_WalletType? = nil
    var _passphrase: String = String()
    var _moniker: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
      _type = source._type
      _passphrase = source._passphrase
      _moniker = source._moniker
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._data)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 3: try decoder.decodeSingularStringField(value: &_storage._passphrase)
        case 4: try decoder.decodeSingularStringField(value: &_storage._moniker)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._data.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._data, fieldNumber: 1)
      }
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._passphrase.isEmpty {
        try visitor.visitSingularStringField(value: _storage._passphrase, fieldNumber: 3)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestRecoverWallet, rhs: ForgeAbi_RequestRecoverWallet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._passphrase != rhs_storage._passphrase {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseRecoverWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseRecoverWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "token"),
    3: .same(proto: "wallet"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _token: String = String()
    var _wallet: ForgeAbi_WalletInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _token = source._token
      _wallet = source._wallet
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularStringField(value: &_storage._token)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._wallet)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 2)
      }
      if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseRecoverWallet, rhs: ForgeAbi_ResponseRecoverWallet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListWallet"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListWallet, rhs: ForgeAbi_RequestListWallet) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListWallet, rhs: ForgeAbi_ResponseListWallet) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestRemoveWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestRemoveWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestRemoveWallet, rhs: ForgeAbi_RequestRemoveWallet) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseRemoveWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseRemoveWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseRemoveWallet, rhs: ForgeAbi_ResponseRemoveWallet) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestDeclareNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestDeclareNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.validator)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.validator != false {
      try visitor.visitSingularBoolField(value: self.validator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestDeclareNode, rhs: ForgeAbi_RequestDeclareNode) -> Bool {
    if lhs.validator != rhs.validator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseDeclareNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseDeclareNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .same(proto: "wallet"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _wallet: ForgeAbi_WalletInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _wallet = source._wallet
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._wallet)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseDeclareNode, rhs: ForgeAbi_ResponseDeclareNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetAccountState, rhs: ForgeAbi_RequestGetAccountState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _state: ForgeAbi_AccountState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetAccountState, rhs: ForgeAbi_ResponseGetAccountState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetAssetState, rhs: ForgeAbi_RequestGetAssetState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _state: ForgeAbi_AssetState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetAssetState, rhs: ForgeAbi_ResponseGetAssetState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetProtocolState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetProtocolState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetProtocolState, rhs: ForgeAbi_RequestGetProtocolState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetProtocolState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetProtocolState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _state: ForgeAbi_ProtocolState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetProtocolState, rhs: ForgeAbi_ResponseGetProtocolState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetStakeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetStakeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetStakeState, rhs: ForgeAbi_RequestGetStakeState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetStakeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetStakeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _state: ForgeAbi_StakeState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetStakeState, rhs: ForgeAbi_ResponseGetStakeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetForgeState, rhs: ForgeAbi_RequestGetForgeState) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _state: ForgeAbi_ForgeState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetForgeState, rhs: ForgeAbi_ResponseGetForgeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetTetherState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetTetherState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetTetherState, rhs: ForgeAbi_RequestGetTetherState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetTetherState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetTetherState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _state: ForgeAbi_TetherState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetTetherState, rhs: ForgeAbi_ResponseGetTetherState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetSwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetSwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.height)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetSwapState, rhs: ForgeAbi_RequestGetSwapState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetSwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetSwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _state: ForgeAbi_SwapState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._state)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetSwapState, rhs: ForgeAbi_ResponseGetSwapState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestStoreFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestStoreFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chunk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.chunk)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunk, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestStoreFile, rhs: ForgeAbi_RequestStoreFile) -> Bool {
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseStoreFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseStoreFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseStoreFile, rhs: ForgeAbi_ResponseStoreFile) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestLoadFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestLoadFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestLoadFile, rhs: ForgeAbi_RequestLoadFile) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseLoadFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseLoadFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "chunk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularBytesField(value: &self.chunk)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.chunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunk, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseLoadFile, rhs: ForgeAbi_ResponseLoadFile) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestPinFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestPinFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestPinFile, rhs: ForgeAbi_RequestPinFile) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponsePinFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponsePinFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponsePinFile, rhs: ForgeAbi_ResponsePinFile) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetChainInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetChainInfo, rhs: ForgeAbi_RequestGetChainInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetChainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _info: ForgeAbi_ChainInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetChainInfo, rhs: ForgeAbi_ResponseGetChainInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetNodeInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetNodeInfo, rhs: ForgeAbi_RequestGetNodeInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetNodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _info: ForgeAbi_NodeInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._info)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetNodeInfo, rhs: ForgeAbi_ResponseGetNodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSearch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestSearch, rhs: ForgeAbi_RequestSearch) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSearch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.txs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseSearch, rhs: ForgeAbi_ResponseSearch) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetUnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetUnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetUnconfirmedTxs, rhs: ForgeAbi_RequestGetUnconfirmedTxs) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetUnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetUnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .standard(proto: "unconfirmed_txs"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _unconfirmedTxs: ForgeAbi_UnconfirmedTxs? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _unconfirmedTxs = source._unconfirmedTxs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._unconfirmedTxs)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._unconfirmedTxs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetUnconfirmedTxs, rhs: ForgeAbi_ResponseGetUnconfirmedTxs) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._unconfirmedTxs != rhs_storage._unconfirmedTxs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetNetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetNetInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetNetInfo, rhs: ForgeAbi_RequestGetNetInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetNetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetNetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "net_info"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _netInfo: ForgeAbi_NetInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _netInfo = source._netInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._netInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._netInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetNetInfo, rhs: ForgeAbi_ResponseGetNetInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._netInfo != rhs_storage._netInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetValidatorsInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetValidatorsInfo, rhs: ForgeAbi_RequestGetValidatorsInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetValidatorsInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "validators_info"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _validatorsInfo: ForgeAbi_ValidatorsInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _validatorsInfo = source._validatorsInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._validatorsInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._validatorsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetValidatorsInfo, rhs: ForgeAbi_ResponseGetValidatorsInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._validatorsInfo != rhs_storage._validatorsInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestSubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.topic)
      case 2: try decoder.decodeSingularStringField(value: &self.filter)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestSubscribe, rhs: ForgeAbi_RequestSubscribe) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseSubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "topic"),
    3: .same(proto: "transfer"),
    4: .standard(proto: "account_migrate"),
    5: .same(proto: "confirm"),
    6: .standard(proto: "create_asset"),
    7: .same(proto: "exchange"),
    8: .same(proto: "revoke"),
    16: .standard(proto: "begin_block"),
    17: .standard(proto: "end_block"),
    19: .same(proto: "declare"),
    20: .standard(proto: "update_asset"),
    21: .standard(proto: "consensus_upgrade"),
    22: .standard(proto: "declare_file"),
    23: .standard(proto: "sys_upgrade"),
    24: .same(proto: "stake"),
    129: .standard(proto: "account_state"),
    130: .standard(proto: "asset_state"),
    131: .standard(proto: "forge_state"),
    132: .standard(proto: "stake_state"),
    133: .standard(proto: "protocol_state"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _value: ForgeAbi_ResponseSubscribe.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._value = .topic(v)}
        case 3:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .transfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .transfer(v)}
        case 4:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .accountMigrate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .accountMigrate(v)}
        case 5:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .confirm(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .confirm(v)}
        case 6:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .createAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .createAsset(v)}
        case 7:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .exchange(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .exchange(v)}
        case 8:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .revoke(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .revoke(v)}
        case 16:
          var v: AbciVendor_RequestBeginBlock?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .beginBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .beginBlock(v)}
        case 17:
          var v: AbciVendor_RequestEndBlock?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .endBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .endBlock(v)}
        case 19:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .declare(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .declare(v)}
        case 20:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .updateAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .updateAsset(v)}
        case 21:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .consensusUpgrade(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .consensusUpgrade(v)}
        case 22:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .declareFile(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .declareFile(v)}
        case 23:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .sysUpgrade(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .sysUpgrade(v)}
        case 24:
          var v: ForgeAbi_Transaction?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .stake(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .stake(v)}
        case 129:
          var v: ForgeAbi_AccountState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .accountState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .accountState(v)}
        case 130:
          var v: ForgeAbi_AssetState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .assetState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .assetState(v)}
        case 131:
          var v: ForgeAbi_ForgeState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .forgeState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .forgeState(v)}
        case 132:
          var v: ForgeAbi_StakeState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .stakeState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .stakeState(v)}
        case 133:
          var v: ForgeAbi_ProtocolState?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .protocolState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .protocolState(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      switch _storage._value {
      case .topic(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .transfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .accountMigrate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .confirm(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .createAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .exchange(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .revoke(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .beginBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .endBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .declare(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .updateAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .consensusUpgrade(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .declareFile(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .sysUpgrade(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .stake(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .accountState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
      case .assetState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
      case .forgeState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
      case .stakeState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
      case .protocolState(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 133)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseSubscribe, rhs: ForgeAbi_ResponseSubscribe) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestUnsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestUnsubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.topic)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestUnsubscribe, rhs: ForgeAbi_RequestUnsubscribe) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseUnsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseUnsubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseUnsubscribe, rhs: ForgeAbi_ResponseUnsubscribe) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parsed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.parsed)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parsed != false {
      try visitor.visitSingularBoolField(value: self.parsed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetConfig, rhs: ForgeAbi_RequestGetConfig) -> Bool {
    if lhs.parsed != rhs.parsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.config)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.config.isEmpty {
      try visitor.visitSingularStringField(value: self.config, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetConfig, rhs: ForgeAbi_ResponseGetConfig) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ByDay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByDay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_date"),
    2: .standard(proto: "end_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.startDate)
      case 2: try decoder.decodeSingularStringField(value: &self.endDate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 1)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ByDay, rhs: ForgeAbi_ByDay) -> Bool {
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ByHour: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByHour"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.date)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ByHour, rhs: ForgeAbi_ByHour) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "day_info"),
    2: .same(proto: "date"),
  ]

  fileprivate class _StorageClass {
    var _value: ForgeAbi_RequestGetForgeStats.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: ForgeAbi_ByDay?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .dayInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .dayInfo(v)}
        case 2:
          var v: ForgeAbi_ByHour?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .date(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .date(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._value {
      case .dayInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .date(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetForgeStats, rhs: ForgeAbi_RequestGetForgeStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "forge_stats"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _forgeStats: ForgeAbi_ForgeStats? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _forgeStats = source._forgeStats
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._forgeStats)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._forgeStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetForgeStats, rhs: ForgeAbi_ResponseGetForgeStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._forgeStats != rhs_storage._forgeStats {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "time_filter"),
    3: .standard(proto: "address_filter"),
    4: .standard(proto: "type_filter"),
    5: .standard(proto: "validity_filter"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil
    var _timeFilter: ForgeAbi_TimeFilter? = nil
    var _addressFilter: ForgeAbi_AddressFilter? = nil
    var _typeFilter: ForgeAbi_TypeFilter? = nil
    var _validityFilter: ForgeAbi_ValidityFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _timeFilter = source._timeFilter
      _addressFilter = source._addressFilter
      _typeFilter = source._typeFilter
      _validityFilter = source._validityFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._timeFilter)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._addressFilter)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._typeFilter)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._validityFilter)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._timeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._addressFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._typeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._validityFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListTransactions, rhs: ForgeAbi_RequestListTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._timeFilter != rhs_storage._timeFilter {return false}
        if _storage._addressFilter != rhs_storage._addressFilter {return false}
        if _storage._typeFilter != rhs_storage._typeFilter {return false}
        if _storage._validityFilter != rhs_storage._validityFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "transactions"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _transactions: [ForgeAbi_IndexedTransaction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _transactions = source._transactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListTransactions, rhs: ForgeAbi_ResponseListTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._transactions != rhs_storage._transactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "owner_address"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil
    var _ownerAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _ownerAddress = source._ownerAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._ownerAddress)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._ownerAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerAddress, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListAssets, rhs: ForgeAbi_RequestListAssets) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._ownerAddress != rhs_storage._ownerAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "assets"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _assets: [ForgeAbi_IndexedAssetState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _assets = source._assets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._assets)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._assets, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListAssets, rhs: ForgeAbi_ResponseListAssets) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._assets != rhs_storage._assets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListStakes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListStakes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "address_filter"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil
    var _addressFilter: ForgeAbi_AddressFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _addressFilter = source._addressFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._addressFilter)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._addressFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListStakes, rhs: ForgeAbi_RequestListStakes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._addressFilter != rhs_storage._addressFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListStakes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListStakes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "stakes"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _stakes: [ForgeAbi_IndexedStakeState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _stakes = source._stakes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._stakes)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._stakes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stakes, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListStakes, rhs: ForgeAbi_ResponseListStakes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._stakes != rhs_storage._stakes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.ownerAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListAccount, rhs: ForgeAbi_RequestListAccount) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "account"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _account: ForgeAbi_IndexedAccountState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _account = source._account
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._account)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListAccount, rhs: ForgeAbi_ResponseListAccount) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._account != rhs_storage._account {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListTopAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTopAccounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListTopAccounts, rhs: ForgeAbi_RequestListTopAccounts) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListTopAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTopAccounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "accounts"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _accounts: [ForgeAbi_IndexedAccountState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _accounts = source._accounts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._accounts)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._accounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._accounts, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListTopAccounts, rhs: ForgeAbi_ResponseListTopAccounts) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._accounts != rhs_storage._accounts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListAssetTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAssetTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "address"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil
    var _address: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _address = source._address
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListAssetTransactions, rhs: ForgeAbi_RequestListAssetTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._address != rhs_storage._address {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListAssetTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAssetTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "transactions"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _transactions: [ForgeAbi_IndexedTransaction] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _transactions = source._transactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListAssetTransactions, rhs: ForgeAbi_ResponseListAssetTransactions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._transactions != rhs_storage._transactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "proposer"),
    3: .standard(proto: "time_filter"),
    4: .standard(proto: "height_filter"),
    5: .standard(proto: "num_txs_filter"),
    6: .standard(proto: "num_invalid_txs_filter"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil
    var _proposer: String = String()
    var _timeFilter: ForgeAbi_TimeFilter? = nil
    var _heightFilter: ForgeAbi_RangeFilter? = nil
    var _numTxsFilter: ForgeAbi_RangeFilter? = nil
    var _numInvalidTxsFilter: ForgeAbi_RangeFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _proposer = source._proposer
      _timeFilter = source._timeFilter
      _heightFilter = source._heightFilter
      _numTxsFilter = source._numTxsFilter
      _numInvalidTxsFilter = source._numInvalidTxsFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._proposer)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._timeFilter)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._heightFilter)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._numTxsFilter)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._numInvalidTxsFilter)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proposer, fieldNumber: 2)
      }
      if let v = _storage._timeFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._heightFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._numTxsFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._numInvalidTxsFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListBlocks, rhs: ForgeAbi_RequestListBlocks) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._timeFilter != rhs_storage._timeFilter {return false}
        if _storage._heightFilter != rhs_storage._heightFilter {return false}
        if _storage._numTxsFilter != rhs_storage._numTxsFilter {return false}
        if _storage._numInvalidTxsFilter != rhs_storage._numInvalidTxsFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _blocks: [ForgeAbi_IndexedBlock] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _blocks = source._blocks
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._blocks)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._blocks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blocks, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListBlocks, rhs: ForgeAbi_ResponseListBlocks) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._blocks != rhs_storage._blocks {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListTethers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTethers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "depositor"),
    3: .same(proto: "withdrawer"),
    4: .same(proto: "custodian"),
    5: .same(proto: "available"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil
    var _depositor: String = String()
    var _withdrawer: String = String()
    var _custodian: String = String()
    var _available: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _depositor = source._depositor
      _withdrawer = source._withdrawer
      _custodian = source._custodian
      _available = source._available
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._depositor)
        case 3: try decoder.decodeSingularStringField(value: &_storage._withdrawer)
        case 4: try decoder.decodeSingularStringField(value: &_storage._custodian)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._available)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._depositor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._depositor, fieldNumber: 2)
      }
      if !_storage._withdrawer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._withdrawer, fieldNumber: 3)
      }
      if !_storage._custodian.isEmpty {
        try visitor.visitSingularStringField(value: _storage._custodian, fieldNumber: 4)
      }
      if _storage._available != false {
        try visitor.visitSingularBoolField(value: _storage._available, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListTethers, rhs: ForgeAbi_RequestListTethers) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._depositor != rhs_storage._depositor {return false}
        if _storage._withdrawer != rhs_storage._withdrawer {return false}
        if _storage._custodian != rhs_storage._custodian {return false}
        if _storage._available != rhs_storage._available {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListTethers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTethers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "tethers"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _tethers: [ForgeAbi_TetherState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _tethers = source._tethers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._tethers)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._tethers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tethers, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListTethers, rhs: ForgeAbi_ResponseListTethers) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._tethers != rhs_storage._tethers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestListSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListSwap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .same(proto: "available"),
  ]

  fileprivate class _StorageClass {
    var _paging: ForgeAbi_PageInput? = nil
    var _sender: String = String()
    var _receiver: String = String()
    var _available: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paging = source._paging
      _sender = source._sender
      _receiver = source._receiver
      _available = source._available
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._paging)
        case 2: try decoder.decodeSingularStringField(value: &_storage._sender)
        case 3: try decoder.decodeSingularStringField(value: &_storage._receiver)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._available)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 2)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 3)
      }
      if _storage._available != false {
        try visitor.visitSingularBoolField(value: _storage._available, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestListSwap, rhs: ForgeAbi_RequestListSwap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._available != rhs_storage._available {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseListSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListSwap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "swap"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _page: ForgeAbi_PageInfo? = nil
    var _swap: [ForgeAbi_SwapState] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _page = source._page
      _swap = source._swap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._page)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._swap)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._page {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._swap.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._swap, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseListSwap, rhs: ForgeAbi_ResponseListSwap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._page != rhs_storage._page {return false}
        if _storage._swap != rhs_storage._swap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RequestGetHealthStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetHealthStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RequestGetHealthStatus, rhs: ForgeAbi_RequestGetHealthStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ResponseGetHealthStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetHealthStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "health_status"),
  ]

  fileprivate class _StorageClass {
    var _code: ForgeAbi_StatusCode = .ok
    var _healthStatus: ForgeAbi_HealthStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _healthStatus = source._healthStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._healthStatus)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._healthStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ResponseGetHealthStatus, rhs: ForgeAbi_ResponseGetHealthStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._healthStatus != rhs_storage._healthStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
