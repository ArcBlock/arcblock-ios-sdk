// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// send_tx(tx, wallet, token, commit \\ false)
public struct Ocap_RequestSendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: String = String()

  public var wallet: Ocap_WalletInfo {
    get {return _wallet ?? Ocap_WalletInfo()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  public var token: String = String()

  public var commit: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wallet: Ocap_WalletInfo? = nil
}

public struct Ocap_ResponseSendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// get_tx(hash)
public struct Ocap_RequestGetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var info: Ocap_TransactionInfo {
    get {return _info ?? Ocap_TransactionInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Ocap_TransactionInfo? = nil
}

/// get_block(height)
public struct Ocap_RequestGetBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var block: Ocap_BlockInfo {
    get {return _block ?? Ocap_BlockInfo()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  public var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  public mutating func clearBlock() {self._block = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _block: Ocap_BlockInfo? = nil
}

public struct Ocap_RequestGetBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var heightFilter: Ocap_RangeFilter {
    get {return _heightFilter ?? Ocap_RangeFilter()}
    set {_heightFilter = newValue}
  }
  /// Returns true if `heightFilter` has been explicitly set.
  public var hasHeightFilter: Bool {return self._heightFilter != nil}
  /// Clears the value of `heightFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHeightFilter() {self._heightFilter = nil}

  public var emptyExcluded: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _heightFilter: Ocap_RangeFilter? = nil
}

public struct Ocap_ResponseGetBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var blocks: [Ocap_BlockInfoSimple] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

/// get_account_state(address, key): retrieve the current state from a list of
/// wallet addresses, return the value of the key. If key is omitted, return
/// entire account states
public struct Ocap_RequestGetAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_AccountState {
    get {return _state ?? Ocap_AccountState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_AccountState? = nil
}

public struct Ocap_RequestGetAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_AssetState {
    get {return _state ?? Ocap_AssetState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_AssetState? = nil
}

/// get_forge_state(key): retrieve Forge state by key. If key is omitted, return
/// entire Forge state
public struct Ocap_RequestGetForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_ForgeState {
    get {return _state ?? Ocap_ForgeState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_ForgeState? = nil
}

public struct Ocap_RequestGetSwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetSwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_SwapState {
    get {return _state ?? Ocap_SwapState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_SwapState? = nil
}

public struct Ocap_RequestGetDelegateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var keys: [String] = []

  public var height: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetDelegateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_DelegateState {
    get {return _state ?? Ocap_DelegateState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_DelegateState? = nil
}

/// get_chain_info(): retrieve the current chain information
public struct Ocap_RequestGetChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var info: Ocap_ChainInfo {
    get {return _storage._info ?? Ocap_ChainInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {_uniqueStorage()._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// get_node_info(): retrieve the current node information
public struct Ocap_RequestGetNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var info: Ocap_NodeInfo {
    get {return _info ?? Ocap_NodeInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Ocap_NodeInfo? = nil
}

public struct Ocap_RequestGetUnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseGetUnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var unconfirmedTxs: Ocap_UnconfirmedTxs {
    get {return _unconfirmedTxs ?? Ocap_UnconfirmedTxs()}
    set {_unconfirmedTxs = newValue}
  }
  /// Returns true if `unconfirmedTxs` has been explicitly set.
  public var hasUnconfirmedTxs: Bool {return self._unconfirmedTxs != nil}
  /// Clears the value of `unconfirmedTxs`. Subsequent reads from it will return its default value.
  public mutating func clearUnconfirmedTxs() {self._unconfirmedTxs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
  fileprivate var _unconfirmedTxs: Ocap_UnconfirmedTxs? = nil
}

public struct Ocap_RequestGetNetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetNetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var netInfo: Ocap_NetInfo {
    get {return _netInfo ?? Ocap_NetInfo()}
    set {_netInfo = newValue}
  }
  /// Returns true if `netInfo` has been explicitly set.
  public var hasNetInfo: Bool {return self._netInfo != nil}
  /// Clears the value of `netInfo`. Subsequent reads from it will return its default value.
  public mutating func clearNetInfo() {self._netInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _netInfo: Ocap_NetInfo? = nil
}

public struct Ocap_RequestGetValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var validatorsInfo: Ocap_ValidatorsInfo {
    get {return _validatorsInfo ?? Ocap_ValidatorsInfo()}
    set {_validatorsInfo = newValue}
  }
  /// Returns true if `validatorsInfo` has been explicitly set.
  public var hasValidatorsInfo: Bool {return self._validatorsInfo != nil}
  /// Clears the value of `validatorsInfo`. Subsequent reads from it will return its default value.
  public mutating func clearValidatorsInfo() {self._validatorsInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validatorsInfo: Ocap_ValidatorsInfo? = nil
}

/// filter could be: value.header.height > 10086 and value.byzantine_validators
/// != []
public struct Ocap_RequestSubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseSubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var value: Ocap_ResponseSubscribe.OneOf_Value? = nil

  public var topic: String {
    get {
      if case .topic(let v)? = value {return v}
      return String()
    }
    set {value = .topic(newValue)}
  }

  public var transfer: Ocap_Transaction {
    get {
      if case .transfer(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .transfer(newValue)}
  }

  public var accountMigrate: Ocap_Transaction {
    get {
      if case .accountMigrate(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .accountMigrate(newValue)}
  }

  public var confirm: Ocap_Transaction {
    get {
      if case .confirm(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .confirm(newValue)}
  }

  public var createAsset: Ocap_Transaction {
    get {
      if case .createAsset(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .createAsset(newValue)}
  }

  /// Transaction revoke = 8 [ deprecated = true ];
  public var exchange: Ocap_Transaction {
    get {
      if case .exchange(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .exchange(newValue)}
  }

  public var beginBlock: Vendor_RequestBeginBlock {
    get {
      if case .beginBlock(let v)? = value {return v}
      return Vendor_RequestBeginBlock()
    }
    set {value = .beginBlock(newValue)}
  }

  public var endBlock: Vendor_RequestEndBlock {
    get {
      if case .endBlock(let v)? = value {return v}
      return Vendor_RequestEndBlock()
    }
    set {value = .endBlock(newValue)}
  }

  public var declare: Ocap_Transaction {
    get {
      if case .declare(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .declare(newValue)}
  }

  public var updateAsset: Ocap_Transaction {
    get {
      if case .updateAsset(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .updateAsset(newValue)}
  }

  public var consensusUpgrade: Ocap_Transaction {
    get {
      if case .consensusUpgrade(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .consensusUpgrade(newValue)}
  }

  /// Transaction declare_file = 22 [ deprecated = true ];
  public var sysUpgrade: Ocap_Transaction {
    get {
      if case .sysUpgrade(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .sysUpgrade(newValue)}
  }

  public var stake: Ocap_Transaction {
    get {
      if case .stake(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .stake(newValue)}
  }

  public var delegate: Ocap_Transaction {
    get {
      if case .delegate(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .delegate(newValue)}
  }

  /// Transaction activate_protocol = 26 [ deprecated = true ];
  /// Transaction deactivate_protocol = 27 [ deprecated = true ];
  public var revokeDelegate: Ocap_Transaction {
    get {
      if case .revokeDelegate(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .revokeDelegate(newValue)}
  }

  public var depositToken: Ocap_Transaction {
    get {
      if case .depositToken(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .depositToken(newValue)}
  }

  public var withdrawToken: Ocap_Transaction {
    get {
      if case .withdrawToken(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .withdrawToken(newValue)}
  }

  public var approveWithdraw: Ocap_Transaction {
    get {
      if case .approveWithdraw(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .approveWithdraw(newValue)}
  }

  public var revokeWithdraw: Ocap_Transaction {
    get {
      if case .revokeWithdraw(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .revokeWithdraw(newValue)}
  }

  public var setupSwap: Ocap_Transaction {
    get {
      if case .setupSwap(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .setupSwap(newValue)}
  }

  public var revokeSwap: Ocap_Transaction {
    get {
      if case .revokeSwap(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .revokeSwap(newValue)}
  }

  public var retrieveSwap: Ocap_Transaction {
    get {
      if case .retrieveSwap(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .retrieveSwap(newValue)}
  }

  /// Transaction poke = 36 [ deprecated = true ];
  /// Transaction deploy_protocol = 37 [ deprecated = true ];
  public var consumeAsset: Ocap_Transaction {
    get {
      if case .consumeAsset(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .consumeAsset(newValue)}
  }

  public var acquireAsset: Ocap_Transaction {
    get {
      if case .acquireAsset(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .acquireAsset(newValue)}
  }

  public var upgradeNode: Ocap_Transaction {
    get {
      if case .upgradeNode(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .upgradeNode(newValue)}
  }

  public var updateValidator: Ocap_Transaction {
    get {
      if case .updateValidator(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .updateValidator(newValue)}
  }

  public var updateConsensusParams: Ocap_Transaction {
    get {
      if case .updateConsensusParams(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .updateConsensusParams(newValue)}
  }

  public var accountState: Ocap_AccountState {
    get {
      if case .accountState(let v)? = value {return v}
      return Ocap_AccountState()
    }
    set {value = .accountState(newValue)}
  }

  public var assetState: Ocap_AssetState {
    get {
      if case .assetState(let v)? = value {return v}
      return Ocap_AssetState()
    }
    set {value = .assetState(newValue)}
  }

  public var forgeState: Ocap_ForgeState {
    get {
      if case .forgeState(let v)? = value {return v}
      return Ocap_ForgeState()
    }
    set {value = .forgeState(newValue)}
  }

  /// StakeState stake_state = 132 [ deprecated = true ];
  /// ProtocolState protocol_state = 133 [ deprecated = true ];
  public var delegateState: Ocap_DelegateState {
    get {
      if case .delegateState(let v)? = value {return v}
      return Ocap_DelegateState()
    }
    set {value = .delegateState(newValue)}
  }

  public var swapState: Ocap_SwapState {
    get {
      if case .swapState(let v)? = value {return v}
      return Ocap_SwapState()
    }
    set {value = .swapState(newValue)}
  }

  public var createToken: Ocap_Transaction {
    get {
      if case .createToken(let v)? = value {return v}
      return Ocap_Transaction()
    }
    set {value = .createToken(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case topic(String)
    case transfer(Ocap_Transaction)
    case accountMigrate(Ocap_Transaction)
    case confirm(Ocap_Transaction)
    case createAsset(Ocap_Transaction)
    /// Transaction revoke = 8 [ deprecated = true ];
    case exchange(Ocap_Transaction)
    case beginBlock(Vendor_RequestBeginBlock)
    case endBlock(Vendor_RequestEndBlock)
    case declare(Ocap_Transaction)
    case updateAsset(Ocap_Transaction)
    case consensusUpgrade(Ocap_Transaction)
    /// Transaction declare_file = 22 [ deprecated = true ];
    case sysUpgrade(Ocap_Transaction)
    case stake(Ocap_Transaction)
    case delegate(Ocap_Transaction)
    /// Transaction activate_protocol = 26 [ deprecated = true ];
    /// Transaction deactivate_protocol = 27 [ deprecated = true ];
    case revokeDelegate(Ocap_Transaction)
    case depositToken(Ocap_Transaction)
    case withdrawToken(Ocap_Transaction)
    case approveWithdraw(Ocap_Transaction)
    case revokeWithdraw(Ocap_Transaction)
    case setupSwap(Ocap_Transaction)
    case revokeSwap(Ocap_Transaction)
    case retrieveSwap(Ocap_Transaction)
    /// Transaction poke = 36 [ deprecated = true ];
    /// Transaction deploy_protocol = 37 [ deprecated = true ];
    case consumeAsset(Ocap_Transaction)
    case acquireAsset(Ocap_Transaction)
    case upgradeNode(Ocap_Transaction)
    case updateValidator(Ocap_Transaction)
    case updateConsensusParams(Ocap_Transaction)
    case accountState(Ocap_AccountState)
    case assetState(Ocap_AssetState)
    case forgeState(Ocap_ForgeState)
    /// StakeState stake_state = 132 [ deprecated = true ];
    /// ProtocolState protocol_state = 133 [ deprecated = true ];
    case delegateState(Ocap_DelegateState)
    case swapState(Ocap_SwapState)
    case createToken(Ocap_Transaction)

  #if !swift(>=4.1)
    public static func ==(lhs: Ocap_ResponseSubscribe.OneOf_Value, rhs: Ocap_ResponseSubscribe.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.topic, .topic): return {
        guard case .topic(let l) = lhs, case .topic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transfer, .transfer): return {
        guard case .transfer(let l) = lhs, case .transfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accountMigrate, .accountMigrate): return {
        guard case .accountMigrate(let l) = lhs, case .accountMigrate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.confirm, .confirm): return {
        guard case .confirm(let l) = lhs, case .confirm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createAsset, .createAsset): return {
        guard case .createAsset(let l) = lhs, case .createAsset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exchange, .exchange): return {
        guard case .exchange(let l) = lhs, case .exchange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginBlock, .beginBlock): return {
        guard case .beginBlock(let l) = lhs, case .beginBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endBlock, .endBlock): return {
        guard case .endBlock(let l) = lhs, case .endBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.declare, .declare): return {
        guard case .declare(let l) = lhs, case .declare(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateAsset, .updateAsset): return {
        guard case .updateAsset(let l) = lhs, case .updateAsset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.consensusUpgrade, .consensusUpgrade): return {
        guard case .consensusUpgrade(let l) = lhs, case .consensusUpgrade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sysUpgrade, .sysUpgrade): return {
        guard case .sysUpgrade(let l) = lhs, case .sysUpgrade(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stake, .stake): return {
        guard case .stake(let l) = lhs, case .stake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delegate, .delegate): return {
        guard case .delegate(let l) = lhs, case .delegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.revokeDelegate, .revokeDelegate): return {
        guard case .revokeDelegate(let l) = lhs, case .revokeDelegate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.depositToken, .depositToken): return {
        guard case .depositToken(let l) = lhs, case .depositToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withdrawToken, .withdrawToken): return {
        guard case .withdrawToken(let l) = lhs, case .withdrawToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.approveWithdraw, .approveWithdraw): return {
        guard case .approveWithdraw(let l) = lhs, case .approveWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.revokeWithdraw, .revokeWithdraw): return {
        guard case .revokeWithdraw(let l) = lhs, case .revokeWithdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setupSwap, .setupSwap): return {
        guard case .setupSwap(let l) = lhs, case .setupSwap(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.revokeSwap, .revokeSwap): return {
        guard case .revokeSwap(let l) = lhs, case .revokeSwap(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.retrieveSwap, .retrieveSwap): return {
        guard case .retrieveSwap(let l) = lhs, case .retrieveSwap(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.consumeAsset, .consumeAsset): return {
        guard case .consumeAsset(let l) = lhs, case .consumeAsset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.acquireAsset, .acquireAsset): return {
        guard case .acquireAsset(let l) = lhs, case .acquireAsset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upgradeNode, .upgradeNode): return {
        guard case .upgradeNode(let l) = lhs, case .upgradeNode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateValidator, .updateValidator): return {
        guard case .updateValidator(let l) = lhs, case .updateValidator(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateConsensusParams, .updateConsensusParams): return {
        guard case .updateConsensusParams(let l) = lhs, case .updateConsensusParams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accountState, .accountState): return {
        guard case .accountState(let l) = lhs, case .accountState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.assetState, .assetState): return {
        guard case .assetState(let l) = lhs, case .assetState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.forgeState, .forgeState): return {
        guard case .forgeState(let l) = lhs, case .forgeState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delegateState, .delegateState): return {
        guard case .delegateState(let l) = lhs, case .delegateState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.swapState, .swapState): return {
        guard case .swapState(let l) = lhs, case .swapState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createToken, .createToken): return {
        guard case .createToken(let l) = lhs, case .createToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Ocap_RequestUnsubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseUnsubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// get config
public struct Ocap_RequestGetConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parsed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var config: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RequestGetForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Ocap_RequestGetForgeStats.OneOf_Value? = nil

  public var dayInfo: Ocap_ByDay {
    get {
      if case .dayInfo(let v)? = value {return v}
      return Ocap_ByDay()
    }
    set {value = .dayInfo(newValue)}
  }

  public var date: Ocap_ByHour {
    get {
      if case .date(let v)? = value {return v}
      return Ocap_ByHour()
    }
    set {value = .date(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case dayInfo(Ocap_ByDay)
    case date(Ocap_ByHour)

  #if !swift(>=4.1)
    public static func ==(lhs: Ocap_RequestGetForgeStats.OneOf_Value, rhs: Ocap_RequestGetForgeStats.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dayInfo, .dayInfo): return {
        guard case .dayInfo(let l) = lhs, case .dayInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.date, .date): return {
        guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Ocap_ResponseGetForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var forgeStats: Ocap_ForgeStats {
    get {return _forgeStats ?? Ocap_ForgeStats()}
    set {_forgeStats = newValue}
  }
  /// Returns true if `forgeStats` has been explicitly set.
  public var hasForgeStats: Bool {return self._forgeStats != nil}
  /// Clears the value of `forgeStats`. Subsequent reads from it will return its default value.
  public mutating func clearForgeStats() {self._forgeStats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _forgeStats: Ocap_ForgeStats? = nil
}

public struct Ocap_RequestListTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var addressFilter: Ocap_AddressFilter {
    get {return _addressFilter ?? Ocap_AddressFilter()}
    set {_addressFilter = newValue}
  }
  /// Returns true if `addressFilter` has been explicitly set.
  public var hasAddressFilter: Bool {return self._addressFilter != nil}
  /// Clears the value of `addressFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAddressFilter() {self._addressFilter = nil}

  public var typeFilter: Ocap_TypeFilter {
    get {return _typeFilter ?? Ocap_TypeFilter()}
    set {_typeFilter = newValue}
  }
  /// Returns true if `typeFilter` has been explicitly set.
  public var hasTypeFilter: Bool {return self._typeFilter != nil}
  /// Clears the value of `typeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTypeFilter() {self._typeFilter = nil}

  public var validityFilter: Ocap_ValidityFilter {
    get {return _validityFilter ?? Ocap_ValidityFilter()}
    set {_validityFilter = newValue}
  }
  /// Returns true if `validityFilter` has been explicitly set.
  public var hasValidityFilter: Bool {return self._validityFilter != nil}
  /// Clears the value of `validityFilter`. Subsequent reads from it will return its default value.
  public mutating func clearValidityFilter() {self._validityFilter = nil}

  public var factoryFilter: Ocap_FactoryFilter {
    get {return _factoryFilter ?? Ocap_FactoryFilter()}
    set {_factoryFilter = newValue}
  }
  /// Returns true if `factoryFilter` has been explicitly set.
  public var hasFactoryFilter: Bool {return self._factoryFilter != nil}
  /// Clears the value of `factoryFilter`. Subsequent reads from it will return its default value.
  public mutating func clearFactoryFilter() {self._factoryFilter = nil}

  public var tokenFilter: Ocap_TokenFilter {
    get {return _tokenFilter ?? Ocap_TokenFilter()}
    set {_tokenFilter = newValue}
  }
  /// Returns true if `tokenFilter` has been explicitly set.
  public var hasTokenFilter: Bool {return self._tokenFilter != nil}
  /// Clears the value of `tokenFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTokenFilter() {self._tokenFilter = nil}

  public var assetFilter: Ocap_AssetFilter {
    get {return _assetFilter ?? Ocap_AssetFilter()}
    set {_assetFilter = newValue}
  }
  /// Returns true if `assetFilter` has been explicitly set.
  public var hasAssetFilter: Bool {return self._assetFilter != nil}
  /// Clears the value of `assetFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAssetFilter() {self._assetFilter = nil}

  public var accountFilter: Ocap_AccountFilter {
    get {return _accountFilter ?? Ocap_AccountFilter()}
    set {_accountFilter = newValue}
  }
  /// Returns true if `accountFilter` has been explicitly set.
  public var hasAccountFilter: Bool {return self._accountFilter != nil}
  /// Clears the value of `accountFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAccountFilter() {self._accountFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
  fileprivate var _addressFilter: Ocap_AddressFilter? = nil
  fileprivate var _typeFilter: Ocap_TypeFilter? = nil
  fileprivate var _validityFilter: Ocap_ValidityFilter? = nil
  fileprivate var _factoryFilter: Ocap_FactoryFilter? = nil
  fileprivate var _tokenFilter: Ocap_TokenFilter? = nil
  fileprivate var _assetFilter: Ocap_AssetFilter? = nil
  fileprivate var _accountFilter: Ocap_AccountFilter? = nil
}

public struct Ocap_ResponseListTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var transactions: [Ocap_IndexedTransaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var ownerAddress: String = String()

  public var factoryAddress: String = String()

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
}

public struct Ocap_ResponseListAssets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var assets: [Ocap_IndexedAssetState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListStakes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var addressFilter: Ocap_AddressFilter {
    get {return _addressFilter ?? Ocap_AddressFilter()}
    set {_addressFilter = newValue}
  }
  /// Returns true if `addressFilter` has been explicitly set.
  public var hasAddressFilter: Bool {return self._addressFilter != nil}
  /// Clears the value of `addressFilter`. Subsequent reads from it will return its default value.
  public mutating func clearAddressFilter() {self._addressFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _addressFilter: Ocap_AddressFilter? = nil
}

public struct Ocap_ResponseListStakes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var stakes: [Ocap_IndexedStakeState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ownerAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseListAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var account: Ocap_IndexedAccountState {
    get {return _account ?? Ocap_IndexedAccountState()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Ocap_IndexedAccountState? = nil
}

public struct Ocap_RequestListTopAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var tokenAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseListTopAccounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var accounts: [Ocap_IndexedAccountState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListAssetTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseListAssetTransactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var transactions: [Ocap_IndexedTransaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var proposer: String = String()

  public var timeFilter: Ocap_TimeFilter {
    get {return _timeFilter ?? Ocap_TimeFilter()}
    set {_timeFilter = newValue}
  }
  /// Returns true if `timeFilter` has been explicitly set.
  public var hasTimeFilter: Bool {return self._timeFilter != nil}
  /// Clears the value of `timeFilter`. Subsequent reads from it will return its default value.
  public mutating func clearTimeFilter() {self._timeFilter = nil}

  public var heightFilter: Ocap_RangeFilter {
    get {return _heightFilter ?? Ocap_RangeFilter()}
    set {_heightFilter = newValue}
  }
  /// Returns true if `heightFilter` has been explicitly set.
  public var hasHeightFilter: Bool {return self._heightFilter != nil}
  /// Clears the value of `heightFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHeightFilter() {self._heightFilter = nil}

  public var numTxsFilter: Ocap_RangeFilter {
    get {return _numTxsFilter ?? Ocap_RangeFilter()}
    set {_numTxsFilter = newValue}
  }
  /// Returns true if `numTxsFilter` has been explicitly set.
  public var hasNumTxsFilter: Bool {return self._numTxsFilter != nil}
  /// Clears the value of `numTxsFilter`. Subsequent reads from it will return its default value.
  public mutating func clearNumTxsFilter() {self._numTxsFilter = nil}

  public var numInvalidTxsFilter: Ocap_RangeFilter {
    get {return _numInvalidTxsFilter ?? Ocap_RangeFilter()}
    set {_numInvalidTxsFilter = newValue}
  }
  /// Returns true if `numInvalidTxsFilter` has been explicitly set.
  public var hasNumInvalidTxsFilter: Bool {return self._numInvalidTxsFilter != nil}
  /// Clears the value of `numInvalidTxsFilter`. Subsequent reads from it will return its default value.
  public mutating func clearNumInvalidTxsFilter() {self._numInvalidTxsFilter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
  fileprivate var _timeFilter: Ocap_TimeFilter? = nil
  fileprivate var _heightFilter: Ocap_RangeFilter? = nil
  fileprivate var _numTxsFilter: Ocap_RangeFilter? = nil
  fileprivate var _numInvalidTxsFilter: Ocap_RangeFilter? = nil
}

public struct Ocap_ResponseListBlocks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var blocks: [Ocap_IndexedBlock] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestListSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var sender: String = String()

  public var receiver: String = String()

  public var available: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseListSwap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var swap: [Ocap_SwapState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

public struct Ocap_RequestGetSwapStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetSwapStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var statistics: Ocap_SwapStatistics {
    get {return _statistics ?? Ocap_SwapStatistics()}
    set {_statistics = newValue}
  }
  /// Returns true if `statistics` has been explicitly set.
  public var hasStatistics: Bool {return self._statistics != nil}
  /// Clears the value of `statistics`. Subsequent reads from it will return its default value.
  public mutating func clearStatistics() {self._statistics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _statistics: Ocap_SwapStatistics? = nil
}

public struct Ocap_RequestGetHealthStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetHealthStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var healthStatus: Ocap_HealthStatus {
    get {return _healthStatus ?? Ocap_HealthStatus()}
    set {_healthStatus = newValue}
  }
  /// Returns true if `healthStatus` has been explicitly set.
  public var hasHealthStatus: Bool {return self._healthStatus != nil}
  /// Clears the value of `healthStatus`. Subsequent reads from it will return its default value.
  public mutating func clearHealthStatus() {self._healthStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _healthStatus: Ocap_HealthStatus? = nil
}

/// token related
public struct Ocap_RequestGetTokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetTokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_TokenState {
    get {return _state ?? Ocap_TokenState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_TokenState? = nil
}

public struct Ocap_RequestListTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var issuerAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseListTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var tokens: [Ocap_IndexedTokenState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

/// asset factory related apis
public struct Ocap_RequestGetFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var state: Ocap_AssetFactoryState {
    get {return _state ?? Ocap_AssetFactoryState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: Ocap_AssetFactoryState? = nil
}

public struct Ocap_RequestListFactories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paging: Ocap_Page {
    get {return _paging ?? Ocap_Page()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var ownerAddress: String = String()

  public var addressList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _paging: Ocap_Page? = nil
}

public struct Ocap_ResponseListFactories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var page: Ocap_PageInfo {
    get {return _page ?? Ocap_PageInfo()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var factories: [Ocap_IndexedFactoryState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Ocap_PageInfo? = nil
}

/// account/factory tokens
public struct Ocap_RequestGetAccountTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// can be account of factory address
  public var address: String = String()

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ResponseGetAccountTokens {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Ocap_StatusCode = .ok

  public var tokens: [Ocap_AccountToken] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_RequestSendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSendTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "wallet"),
    3: .same(proto: "token"),
    4: .same(proto: "commit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.commit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tx.isEmpty {
      try visitor.visitSingularStringField(value: self.tx, fieldNumber: 1)
    }
    if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    if self.commit != false {
      try visitor.visitSingularBoolField(value: self.commit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestSendTx, rhs: Ocap_RequestSendTx) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs._wallet != rhs._wallet {return false}
    if lhs.token != rhs.token {return false}
    if lhs.commit != rhs.commit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseSendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSendTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseSendTx, rhs: Ocap_ResponseSendTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetTx, rhs: Ocap_RequestGetTx) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetTx, rhs: Ocap_ResponseGetTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetBlock, rhs: Ocap_RequestGetBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetBlock, rhs: Ocap_ResponseGetBlock) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._block != rhs._block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "height_filter"),
    3: .standard(proto: "empty_excluded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._heightFilter) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.emptyExcluded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._heightFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.emptyExcluded != false {
      try visitor.visitSingularBoolField(value: self.emptyExcluded, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetBlocks, rhs: Ocap_RequestGetBlocks) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs._heightFilter != rhs._heightFilter {return false}
    if lhs.emptyExcluded != rhs.emptyExcluded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetBlocks, rhs: Ocap_ResponseGetBlocks) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetAccountState, rhs: Ocap_RequestGetAccountState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAccountState, rhs: Ocap_ResponseGetAccountState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetAssetState, rhs: Ocap_RequestGetAssetState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAssetState, rhs: Ocap_ResponseGetAssetState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetForgeState, rhs: Ocap_RequestGetForgeState) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetForgeState, rhs: Ocap_ResponseGetForgeState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetSwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetSwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetSwapState, rhs: Ocap_RequestGetSwapState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetSwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetSwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetSwapState, rhs: Ocap_ResponseGetSwapState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetDelegateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetDelegateState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "keys"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetDelegateState, rhs: Ocap_RequestGetDelegateState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetDelegateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetDelegateState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetDelegateState, rhs: Ocap_ResponseGetDelegateState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetChainInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetChainInfo, rhs: Ocap_RequestGetChainInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetChainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  fileprivate class _StorageClass {
    var _code: Ocap_StatusCode = .ok
    var _info: Ocap_ChainInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _info = source._info
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._code) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._info) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 1)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetChainInfo, rhs: Ocap_ResponseGetChainInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._code != rhs_storage._code {return false}
        if _storage._info != rhs_storage._info {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetNodeInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetNodeInfo, rhs: Ocap_RequestGetNodeInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetNodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetNodeInfo, rhs: Ocap_ResponseGetNodeInfo) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetUnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetUnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetUnconfirmedTxs, rhs: Ocap_RequestGetUnconfirmedTxs) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetUnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetUnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .standard(proto: "unconfirmed_txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._unconfirmedTxs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._unconfirmedTxs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetUnconfirmedTxs, rhs: Ocap_ResponseGetUnconfirmedTxs) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs._unconfirmedTxs != rhs._unconfirmedTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetNetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetNetInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetNetInfo, rhs: Ocap_RequestGetNetInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetNetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetNetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "net_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._netInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._netInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetNetInfo, rhs: Ocap_ResponseGetNetInfo) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._netInfo != rhs._netInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetValidatorsInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetValidatorsInfo, rhs: Ocap_RequestGetValidatorsInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetValidatorsInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "validators_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validatorsInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._validatorsInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetValidatorsInfo, rhs: Ocap_ResponseGetValidatorsInfo) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._validatorsInfo != rhs._validatorsInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestSubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestSubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestSubscribe, rhs: Ocap_RequestSubscribe) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseSubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseSubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "topic"),
    3: .same(proto: "transfer"),
    4: .standard(proto: "account_migrate"),
    5: .same(proto: "confirm"),
    6: .standard(proto: "create_asset"),
    7: .same(proto: "exchange"),
    16: .standard(proto: "begin_block"),
    17: .standard(proto: "end_block"),
    19: .same(proto: "declare"),
    20: .standard(proto: "update_asset"),
    21: .standard(proto: "consensus_upgrade"),
    23: .standard(proto: "sys_upgrade"),
    24: .same(proto: "stake"),
    25: .same(proto: "delegate"),
    28: .standard(proto: "revoke_delegate"),
    29: .standard(proto: "deposit_token"),
    30: .standard(proto: "withdraw_token"),
    31: .standard(proto: "approve_withdraw"),
    32: .standard(proto: "revoke_withdraw"),
    33: .standard(proto: "setup_swap"),
    34: .standard(proto: "revoke_swap"),
    35: .standard(proto: "retrieve_swap"),
    38: .standard(proto: "consume_asset"),
    39: .standard(proto: "acquire_asset"),
    40: .standard(proto: "upgrade_node"),
    41: .standard(proto: "update_validator"),
    42: .standard(proto: "update_consensus_params"),
    129: .standard(proto: "account_state"),
    130: .standard(proto: "asset_state"),
    131: .standard(proto: "forge_state"),
    134: .standard(proto: "delegate_state"),
    135: .standard(proto: "swap_state"),
    136: .standard(proto: "create_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .topic(v)}
      }()
      case 3: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .transfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .transfer(v)}
      }()
      case 4: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .accountMigrate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .accountMigrate(v)}
      }()
      case 5: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .confirm(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .confirm(v)}
      }()
      case 6: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .createAsset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .createAsset(v)}
      }()
      case 7: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .exchange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .exchange(v)}
      }()
      case 16: try {
        var v: Vendor_RequestBeginBlock?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .beginBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .beginBlock(v)}
      }()
      case 17: try {
        var v: Vendor_RequestEndBlock?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .endBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .endBlock(v)}
      }()
      case 19: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .declare(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .declare(v)}
      }()
      case 20: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .updateAsset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .updateAsset(v)}
      }()
      case 21: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .consensusUpgrade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .consensusUpgrade(v)}
      }()
      case 23: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .sysUpgrade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .sysUpgrade(v)}
      }()
      case 24: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .stake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .stake(v)}
      }()
      case 25: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .delegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .delegate(v)}
      }()
      case 28: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .revokeDelegate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .revokeDelegate(v)}
      }()
      case 29: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .depositToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .depositToken(v)}
      }()
      case 30: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .withdrawToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .withdrawToken(v)}
      }()
      case 31: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .approveWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .approveWithdraw(v)}
      }()
      case 32: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .revokeWithdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .revokeWithdraw(v)}
      }()
      case 33: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .setupSwap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .setupSwap(v)}
      }()
      case 34: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .revokeSwap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .revokeSwap(v)}
      }()
      case 35: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .retrieveSwap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .retrieveSwap(v)}
      }()
      case 38: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .consumeAsset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .consumeAsset(v)}
      }()
      case 39: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .acquireAsset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .acquireAsset(v)}
      }()
      case 40: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .upgradeNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .upgradeNode(v)}
      }()
      case 41: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .updateValidator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .updateValidator(v)}
      }()
      case 42: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .updateConsensusParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .updateConsensusParams(v)}
      }()
      case 129: try {
        var v: Ocap_AccountState?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .accountState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .accountState(v)}
      }()
      case 130: try {
        var v: Ocap_AssetState?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .assetState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .assetState(v)}
      }()
      case 131: try {
        var v: Ocap_ForgeState?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .forgeState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .forgeState(v)}
      }()
      case 134: try {
        var v: Ocap_DelegateState?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .delegateState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .delegateState(v)}
      }()
      case 135: try {
        var v: Ocap_SwapState?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .swapState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .swapState(v)}
      }()
      case 136: try {
        var v: Ocap_Transaction?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .createToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .createToken(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .topic?: try {
      guard case .topic(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .transfer?: try {
      guard case .transfer(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .accountMigrate?: try {
      guard case .accountMigrate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .confirm?: try {
      guard case .confirm(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .createAsset?: try {
      guard case .createAsset(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .exchange?: try {
      guard case .exchange(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .beginBlock?: try {
      guard case .beginBlock(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .endBlock?: try {
      guard case .endBlock(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .declare?: try {
      guard case .declare(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .updateAsset?: try {
      guard case .updateAsset(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .consensusUpgrade?: try {
      guard case .consensusUpgrade(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .sysUpgrade?: try {
      guard case .sysUpgrade(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .stake?: try {
      guard case .stake(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .delegate?: try {
      guard case .delegate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .revokeDelegate?: try {
      guard case .revokeDelegate(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .depositToken?: try {
      guard case .depositToken(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .withdrawToken?: try {
      guard case .withdrawToken(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .approveWithdraw?: try {
      guard case .approveWithdraw(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .revokeWithdraw?: try {
      guard case .revokeWithdraw(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .setupSwap?: try {
      guard case .setupSwap(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .revokeSwap?: try {
      guard case .revokeSwap(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .retrieveSwap?: try {
      guard case .retrieveSwap(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .consumeAsset?: try {
      guard case .consumeAsset(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .acquireAsset?: try {
      guard case .acquireAsset(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .upgradeNode?: try {
      guard case .upgradeNode(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .updateValidator?: try {
      guard case .updateValidator(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .updateConsensusParams?: try {
      guard case .updateConsensusParams(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .accountState?: try {
      guard case .accountState(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
    }()
    case .assetState?: try {
      guard case .assetState(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
    }()
    case .forgeState?: try {
      guard case .forgeState(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
    }()
    case .delegateState?: try {
      guard case .delegateState(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 134)
    }()
    case .swapState?: try {
      guard case .swapState(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 135)
    }()
    case .createToken?: try {
      guard case .createToken(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 136)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseSubscribe, rhs: Ocap_ResponseSubscribe) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestUnsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestUnsubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestUnsubscribe, rhs: Ocap_RequestUnsubscribe) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseUnsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseUnsubscribe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseUnsubscribe, rhs: Ocap_ResponseUnsubscribe) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parsed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.parsed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parsed != false {
      try visitor.visitSingularBoolField(value: self.parsed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetConfig, rhs: Ocap_RequestGetConfig) -> Bool {
    if lhs.parsed != rhs.parsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.config.isEmpty {
      try visitor.visitSingularStringField(value: self.config, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetConfig, rhs: Ocap_ResponseGetConfig) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "day_info"),
    2: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ocap_ByDay?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .dayInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .dayInfo(v)}
      }()
      case 2: try {
        var v: Ocap_ByHour?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .date(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .dayInfo?: try {
      guard case .dayInfo(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .date?: try {
      guard case .date(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetForgeStats, rhs: Ocap_RequestGetForgeStats) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "forge_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._forgeStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._forgeStats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetForgeStats, rhs: Ocap_ResponseGetForgeStats) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._forgeStats != rhs._forgeStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "time_filter"),
    3: .standard(proto: "address_filter"),
    4: .standard(proto: "type_filter"),
    5: .standard(proto: "validity_filter"),
    6: .standard(proto: "factory_filter"),
    7: .standard(proto: "token_filter"),
    8: .standard(proto: "asset_filter"),
    9: .standard(proto: "account_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._addressFilter) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._typeFilter) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._validityFilter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._factoryFilter) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._tokenFilter) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._assetFilter) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._accountFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._addressFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._typeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._validityFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._factoryFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._tokenFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._assetFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._accountFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTransactions, rhs: Ocap_RequestListTransactions) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs._addressFilter != rhs._addressFilter {return false}
    if lhs._typeFilter != rhs._typeFilter {return false}
    if lhs._validityFilter != rhs._validityFilter {return false}
    if lhs._factoryFilter != rhs._factoryFilter {return false}
    if lhs._tokenFilter != rhs._tokenFilter {return false}
    if lhs._assetFilter != rhs._assetFilter {return false}
    if lhs._accountFilter != rhs._accountFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTransactions, rhs: Ocap_ResponseListTransactions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "factory_address"),
    4: .standard(proto: "time_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.factoryAddress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 2)
    }
    if !self.factoryAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.factoryAddress, fieldNumber: 3)
    }
    if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListAssets, rhs: Ocap_RequestListAssets) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.factoryAddress != rhs.factoryAddress {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListAssets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAssets"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListAssets, rhs: Ocap_ResponseListAssets) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListStakes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListStakes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "address_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._addressFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._addressFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListStakes, rhs: Ocap_RequestListStakes) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs._addressFilter != rhs._addressFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListStakes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListStakes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "stakes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.stakes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.stakes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stakes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListStakes, rhs: Ocap_ResponseListStakes) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.stakes != rhs.stakes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListAccount, rhs: Ocap_RequestListAccount) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListAccount, rhs: Ocap_ResponseListAccount) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTopAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTopAccounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "tokenAddress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.tokenAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTopAccounts, rhs: Ocap_RequestListTopAccounts) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.tokenAddress != rhs.tokenAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTopAccounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTopAccounts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTopAccounts, rhs: Ocap_ResponseListTopAccounts) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListAssetTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListAssetTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListAssetTransactions, rhs: Ocap_RequestListAssetTransactions) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListAssetTransactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListAssetTransactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListAssetTransactions, rhs: Ocap_ResponseListAssetTransactions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "proposer"),
    3: .standard(proto: "time_filter"),
    4: .standard(proto: "height_filter"),
    5: .standard(proto: "num_txs_filter"),
    6: .standard(proto: "num_invalid_txs_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.proposer) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeFilter) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._heightFilter) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._numTxsFilter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._numInvalidTxsFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.proposer.isEmpty {
      try visitor.visitSingularStringField(value: self.proposer, fieldNumber: 2)
    }
    if let v = self._timeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._heightFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._numTxsFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._numInvalidTxsFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListBlocks, rhs: Ocap_RequestListBlocks) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.proposer != rhs.proposer {return false}
    if lhs._timeFilter != rhs._timeFilter {return false}
    if lhs._heightFilter != rhs._heightFilter {return false}
    if lhs._numTxsFilter != rhs._numTxsFilter {return false}
    if lhs._numInvalidTxsFilter != rhs._numInvalidTxsFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListBlocks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListBlocks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListBlocks, rhs: Ocap_ResponseListBlocks) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListSwap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .same(proto: "available"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.available) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 3)
    }
    if self.available != false {
      try visitor.visitSingularBoolField(value: self.available, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListSwap, rhs: Ocap_RequestListSwap) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.available != rhs.available {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListSwap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListSwap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "swap"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.swap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.swap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.swap, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListSwap, rhs: Ocap_ResponseListSwap) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.swap != rhs.swap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetSwapStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetSwapStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetSwapStatistics, rhs: Ocap_RequestGetSwapStatistics) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetSwapStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetSwapStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "statistics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._statistics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._statistics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetSwapStatistics, rhs: Ocap_ResponseGetSwapStatistics) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._statistics != rhs._statistics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetHealthStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetHealthStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetHealthStatus, rhs: Ocap_RequestGetHealthStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetHealthStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetHealthStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "health_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._healthStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._healthStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetHealthStatus, rhs: Ocap_ResponseGetHealthStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._healthStatus != rhs._healthStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetTokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetTokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetTokenState, rhs: Ocap_RequestGetTokenState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetTokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetTokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetTokenState, rhs: Ocap_ResponseGetTokenState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "issuer_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.issuerAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.issuerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.issuerAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListTokens, rhs: Ocap_RequestListTokens) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.issuerAddress != rhs.issuerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListTokens, rhs: Ocap_ResponseListTokens) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetFactoryState, rhs: Ocap_RequestGetFactoryState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetFactoryState, rhs: Ocap_ResponseGetFactoryState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestListFactories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestListFactories"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paging"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "address_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerAddress) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.addressList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerAddress, fieldNumber: 2)
    }
    if !self.addressList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addressList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestListFactories, rhs: Ocap_RequestListFactories) -> Bool {
    if lhs._paging != rhs._paging {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.addressList != rhs.addressList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseListFactories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseListFactories"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "page"),
    3: .same(proto: "factories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.factories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.factories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.factories, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseListFactories, rhs: Ocap_ResponseListFactories) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._page != rhs._page {return false}
    if lhs.factories != rhs.factories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RequestGetAccountTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestGetAccountTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RequestGetAccountTokens, rhs: Ocap_RequestGetAccountTokens) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ResponseGetAccountTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseGetAccountTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ResponseGetAccountTokens, rhs: Ocap_ResponseGetAccountTokens) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
