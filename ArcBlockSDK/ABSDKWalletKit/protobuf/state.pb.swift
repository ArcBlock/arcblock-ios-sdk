// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Ocap_AccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  /// Used for anti-replay, updated whever this account sends a new transaction
  public var nonce: String {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  /// Deprecated: will not be updated in future
  public var numTxs: String {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var pk: Data {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  public var type: Ocap_WalletType {
    get {return _storage._type ?? Ocap_WalletType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var gasBalance: Ocap_BigUint {
    get {return _storage._gasBalance ?? Ocap_BigUint()}
    set {_uniqueStorage()._gasBalance = newValue}
  }
  /// Returns true if `gasBalance` has been explicitly set.
  public var hasGasBalance: Bool {return _storage._gasBalance != nil}
  /// Clears the value of `gasBalance`. Subsequent reads from it will return its default value.
  public mutating func clearGasBalance() {_uniqueStorage()._gasBalance = nil}

  /// the address that is being migrated. Once this is set this account state is
  /// read only. No further tx can alter this account state. And tx with "from"
  /// equal to the old address will be rejected by ocap
  public var migratedTo: [String] {
    get {return _storage._migratedTo}
    set {_uniqueStorage()._migratedTo = newValue}
  }

  public var migratedFrom: [String] {
    get {return _storage._migratedFrom}
    set {_uniqueStorage()._migratedFrom = newValue}
  }

  /// DEPRECATED: will not be updated in future
  public var numAssets: String {
    get {return _storage._numAssets}
    set {_uniqueStorage()._numAssets = newValue}
  }

  public var stake: Ocap_StakeContext {
    get {return _storage._stake ?? Ocap_StakeContext()}
    set {_uniqueStorage()._stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  public var hasStake: Bool {return _storage._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  public mutating func clearStake() {_uniqueStorage()._stake = nil}

  public var pinnedFiles: Ocap_CircularQueue {
    get {return _storage._pinnedFiles ?? Ocap_CircularQueue()}
    set {_uniqueStorage()._pinnedFiles = newValue}
  }
  /// Returns true if `pinnedFiles` has been explicitly set.
  public var hasPinnedFiles: Bool {return _storage._pinnedFiles != nil}
  /// Clears the value of `pinnedFiles`. Subsequent reads from it will return its default value.
  public mutating func clearPinnedFiles() {_uniqueStorage()._pinnedFiles = nil}

  /// PokeInfo poke = 18; // deprecated
  /// The current deposit this account has received. It cannot exceed the deposit cap.
  public var depositReceived: Ocap_BigUint {
    get {return _storage._depositReceived ?? Ocap_BigUint()}
    set {_uniqueStorage()._depositReceived = newValue}
  }
  /// Returns true if `depositReceived` has been explicitly set.
  public var hasDepositReceived: Bool {return _storage._depositReceived != nil}
  /// Clears the value of `depositReceived`. Subsequent reads from it will return its default value.
  public mutating func clearDepositReceived() {_uniqueStorage()._depositReceived = nil}

  /// 20-49 reserve for future
  public var withdrawItems: Ocap_CircularQueue {
    get {return _storage._withdrawItems ?? Ocap_CircularQueue()}
    set {_uniqueStorage()._withdrawItems = newValue}
  }
  /// Returns true if `withdrawItems` has been explicitly set.
  public var hasWithdrawItems: Bool {return _storage._withdrawItems != nil}
  /// Clears the value of `withdrawItems`. Subsequent reads from it will return its default value.
  public mutating func clearWithdrawItems() {_uniqueStorage()._withdrawItems = nil}

  public var tokens: [Ocap_IndexedTokenInput] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_AssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var readonly: Bool {
    get {return _storage._readonly}
    set {_uniqueStorage()._readonly = newValue}
  }

  public var transferrable: Bool {
    get {return _storage._transferrable}
    set {_uniqueStorage()._transferrable = newValue}
  }

  public var ttl: UInt32 {
    get {return _storage._ttl}
    set {_uniqueStorage()._ttl = newValue}
  }

  /// once it is consumed, it is untransferrable
  public var consumedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._consumedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._consumedTime = newValue}
  }
  /// Returns true if `consumedTime` has been explicitly set.
  public var hasConsumedTime: Bool {return _storage._consumedTime != nil}
  /// Clears the value of `consumedTime`. Subsequent reads from it will return its default value.
  public mutating func clearConsumedTime() {_uniqueStorage()._consumedTime = nil}

  /// who issued the asset
  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  /// parent address for the asset state, e.g. a ticket is inherited from an
  /// event
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  public var stake: Ocap_StakeContext {
    get {return _storage._stake ?? Ocap_StakeContext()}
    set {_uniqueStorage()._stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  public var hasStake: Bool {return _storage._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  public mutating func clearStake() {_uniqueStorage()._stake = nil}

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_CoreProtocol {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// consensus parameters, in future we shall be able to modify it
  public var consensus: Ocap_ConsensusParams {
    get {return _storage._consensus ?? Ocap_ConsensusParams()}
    set {_uniqueStorage()._consensus = newValue}
  }
  /// Returns true if `consensus` has been explicitly set.
  public var hasConsensus: Bool {return _storage._consensus != nil}
  /// Clears the value of `consensus`. Subsequent reads from it will return its default value.
  public mutating func clearConsensus() {_uniqueStorage()._consensus = nil}

  public var tasks: Dictionary<UInt64,Ocap_UpgradeTasks> {
    get {return _storage._tasks}
    set {_uniqueStorage()._tasks = newValue}
  }

  public var stakeSummary: Dictionary<UInt32,Ocap_StakeSummary> {
    get {return _storage._stakeSummary}
    set {_uniqueStorage()._stakeSummary = newValue}
  }

  /// string data_version = 6; current data version deprecated
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var token: Ocap_ForgeToken {
    get {return _storage._token ?? Ocap_ForgeToken()}
    set {_uniqueStorage()._token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return _storage._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {_uniqueStorage()._token = nil}

  public var txConfig: Ocap_TransactionConfig {
    get {return _storage._txConfig ?? Ocap_TransactionConfig()}
    set {_uniqueStorage()._txConfig = newValue}
  }
  /// Returns true if `txConfig` has been explicitly set.
  public var hasTxConfig: Bool {return _storage._txConfig != nil}
  /// Clears the value of `txConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTxConfig() {_uniqueStorage()._txConfig = nil}

  public var protocols: [Ocap_CoreProtocol] {
    get {return _storage._protocols}
    set {_uniqueStorage()._protocols = newValue}
  }

  public var gas: Dictionary<String,UInt32> {
    get {return _storage._gas}
    set {_uniqueStorage()._gas = newValue}
  }

  public var upgradeInfo: Ocap_UpgradeInfo {
    get {return _storage._upgradeInfo ?? Ocap_UpgradeInfo()}
    set {_uniqueStorage()._upgradeInfo = newValue}
  }
  /// Returns true if `upgradeInfo` has been explicitly set.
  public var hasUpgradeInfo: Bool {return _storage._upgradeInfo != nil}
  /// Clears the value of `upgradeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUpgradeInfo() {_uniqueStorage()._upgradeInfo = nil}

  public var accountConfig: Dictionary<String,Ocap_AccountConfig> {
    get {return _storage._accountConfig}
    set {_uniqueStorage()._accountConfig = newValue}
  }

  public var tokenSwapConfig: Ocap_TokenSwapConfig {
    get {return _storage._tokenSwapConfig ?? Ocap_TokenSwapConfig()}
    set {_uniqueStorage()._tokenSwapConfig = newValue}
  }
  /// Returns true if `tokenSwapConfig` has been explicitly set.
  public var hasTokenSwapConfig: Bool {return _storage._tokenSwapConfig != nil}
  /// Clears the value of `tokenSwapConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTokenSwapConfig() {_uniqueStorage()._tokenSwapConfig = nil}

  /// app can define their own app state
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// keep a list of state root for different dbs (column families).
/// RootState will be stored in the default column family, and we return the
/// root hash for default column family, thus our app_state would contain all
/// hashes from different column families.
public struct Ocap_RootState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var account: Data = Data()

  public var asset: Data = Data()

  public var receipt: Data = Data()

  public var `protocol`: Data = Data()

  public var governance: Data = Data()

  public var custom: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_StatisticsState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var numBlocks: UInt64 = 0

  public var numTxs: UInt64 = 0

  public var numStakes: Ocap_BigUint {
    get {return _numStakes ?? Ocap_BigUint()}
    set {_numStakes = newValue}
  }
  /// Returns true if `numStakes` has been explicitly set.
  public var hasNumStakes: Bool {return self._numStakes != nil}
  /// Clears the value of `numStakes`. Subsequent reads from it will return its default value.
  public mutating func clearNumStakes() {self._numStakes = nil}

  public var numValidators: UInt32 = 0

  public var txStatistics: Ocap_TxStatistics {
    get {return _txStatistics ?? Ocap_TxStatistics()}
    set {_txStatistics = newValue}
  }
  /// Returns true if `txStatistics` has been explicitly set.
  public var hasTxStatistics: Bool {return self._txStatistics != nil}
  /// Clears the value of `txStatistics`. Subsequent reads from it will return its default value.
  public mutating func clearTxStatistics() {self._txStatistics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _numStakes: Ocap_BigUint? = nil
  fileprivate var _txStatistics: Ocap_TxStatistics? = nil
}

/// TODO: [peiling] We have already defined this state in core protocols repo.
/// The only reason we define this state here again is because the protobuf
/// definition ResponseGetSwapState needs to reference to this SwapState.
public struct Ocap_SwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var address: String = String()

  public var hashkey: Data = Data()

  public var sender: String = String()

  public var receiver: String = String()

  public var value: Ocap_BigUint {
    get {return _value ?? Ocap_BigUint()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var assets: [String] = []

  public var locktime: UInt32 = 0

  public var hashlock: Data = Data()

  public var context: Ocap_StateContext {
    get {return _context ?? Ocap_StateContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Ocap_BigUint? = nil
  fileprivate var _context: Ocap_StateContext? = nil
}

/// TODO: [peiling] We have already defined this state in core protocols repo.
/// The only reason we define this state here again is because the protobuf
/// definition ResponseGetSwapStatistics needs to reference to this.
public struct Ocap_SwapStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var lockedValueOut: Ocap_BigUint {
    get {return _lockedValueOut ?? Ocap_BigUint()}
    set {_lockedValueOut = newValue}
  }
  /// Returns true if `lockedValueOut` has been explicitly set.
  public var hasLockedValueOut: Bool {return self._lockedValueOut != nil}
  /// Clears the value of `lockedValueOut`. Subsequent reads from it will return its default value.
  public mutating func clearLockedValueOut() {self._lockedValueOut = nil}

  public var lockedValueIn: Ocap_BigUint {
    get {return _lockedValueIn ?? Ocap_BigUint()}
    set {_lockedValueIn = newValue}
  }
  /// Returns true if `lockedValueIn` has been explicitly set.
  public var hasLockedValueIn: Bool {return self._lockedValueIn != nil}
  /// Clears the value of `lockedValueIn`. Subsequent reads from it will return its default value.
  public mutating func clearLockedValueIn() {self._lockedValueIn = nil}

  public var lockedAssetsOut: UInt32 = 0

  public var lockedAssetsIn: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lockedValueOut: Ocap_BigUint? = nil
  fileprivate var _lockedValueIn: Ocap_BigUint? = nil
}

/// a rule can check against the statistics values, e.g. state.num_txs < 10000,
/// state.balance_delta < 50000, delta is calculated based on the
/// configuration for interval.
public struct Ocap_DelegateOpState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// all the individual rules in DelegateTx will be concat into one per type_url
  /// by "AND"
  public var rule: String = String()

  public var numTxs: UInt64 = 0

  public var numTxsDelta: UInt64 = 0

  public var balance: Ocap_BigUint {
    get {return _balance ?? Ocap_BigUint()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {self._balance = nil}

  public var balanceDelta: Ocap_BigUint {
    get {return _balanceDelta ?? Ocap_BigUint()}
    set {_balanceDelta = newValue}
  }
  /// Returns true if `balanceDelta` has been explicitly set.
  public var hasBalanceDelta: Bool {return self._balanceDelta != nil}
  /// Clears the value of `balanceDelta`. Subsequent reads from it will return its default value.
  public mutating func clearBalanceDelta() {self._balanceDelta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _balance: Ocap_BigUint? = nil
  fileprivate var _balanceDelta: Ocap_BigUint? = nil
}

public struct Ocap_DelegateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var ops: Dictionary<String,Ocap_DelegateOpState> = [:]

  /// state context, replace exiting fields
  public var context: Ocap_StateContext {
    get {return _context ?? Ocap_StateContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// app can extend this
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Ocap_StateContext? = nil
  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
}

public struct Ocap_TokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  public var unit: String {
    get {return _storage._unit}
    set {_uniqueStorage()._unit = newValue}
  }

  public var decimal: UInt32 {
    get {return _storage._decimal}
    set {_uniqueStorage()._decimal = newValue}
  }

  public var icon: String {
    get {return _storage._icon}
    set {_uniqueStorage()._icon = newValue}
  }

  public var totalSupply: String {
    get {return _storage._totalSupply}
    set {_uniqueStorage()._totalSupply = newValue}
  }

  public var foreignToken: Ocap_ForeignToken {
    get {return _storage._foreignToken ?? Ocap_ForeignToken()}
    set {_uniqueStorage()._foreignToken = newValue}
  }
  /// Returns true if `foreignToken` has been explicitly set.
  public var hasForeignToken: Bool {return _storage._foreignToken != nil}
  /// Clears the value of `foreignToken`. Subsequent reads from it will return its default value.
  public mutating func clearForeignToken() {_uniqueStorage()._foreignToken = nil}

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Very similar to AssetFactory, appended some state vars
public struct Ocap_AssetFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var settlement: String {
    get {return _storage._settlement}
    set {_uniqueStorage()._settlement = newValue}
  }

  public var limit: UInt32 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  public var trustedIssuers: [String] {
    get {return _storage._trustedIssuers}
    set {_uniqueStorage()._trustedIssuers = newValue}
  }

  public var input: Ocap_IndexedFactoryInput {
    get {return _storage._input ?? Ocap_IndexedFactoryInput()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  public var output: Ocap_CreateAssetTx {
    get {return _storage._output ?? Ocap_CreateAssetTx()}
    set {_uniqueStorage()._output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return _storage._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {_uniqueStorage()._output = nil}

  public var hooks: [Ocap_AssetFactoryHook] {
    get {return _storage._hooks}
    set {_uniqueStorage()._hooks = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  /// mutable
  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var tokens: [Ocap_IndexedTokenInput] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var numMinted: UInt32 {
    get {return _storage._numMinted}
    set {_uniqueStorage()._numMinted = newValue}
  }

  public var display: Ocap_AssetDisplay {
    get {return _storage._display ?? Ocap_AssetDisplay()}
    set {_uniqueStorage()._display = newValue}
  }
  /// Returns true if `display` has been explicitly set.
  public var hasDisplay: Bool {return _storage._display != nil}
  /// Clears the value of `display`. Subsequent reads from it will return its default value.
  public mutating func clearDisplay() {_uniqueStorage()._display = nil}

  /// mutable
  public var lastSettlement: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastSettlement ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastSettlement = newValue}
  }
  /// Returns true if `lastSettlement` has been explicitly set.
  public var hasLastSettlement: Bool {return _storage._lastSettlement != nil}
  /// Clears the value of `lastSettlement`. Subsequent reads from it will return its default value.
  public mutating func clearLastSettlement() {_uniqueStorage()._lastSettlement = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_StakeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// Who can create/revoke this stake
  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  /// What is the stake for
  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  /// Balance for staking
  /// Actual Structure in statedb: map<tokenAddress, balance>
  /// Structure when returned from graphql endpoint
  public var tokens: [Ocap_IndexedTokenInput] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  /// Assets for staking
  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  /// Can user unstake from this stake asset
  /// Usually used to lock the stake to avoid unexpected unstake
  public var revocable: Bool {
    get {return _storage._revocable}
    set {_uniqueStorage()._revocable = newValue}
  }

  /// Human readable reason for staking
  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Period to wait before revoking can be claimed, in seconds
  public var revokeWaitingPeriod: UInt32 {
    get {return _storage._revokeWaitingPeriod}
    set {_uniqueStorage()._revokeWaitingPeriod = newValue}
  }

  /// Revoked stake that are pending for claim
  public var revokedTokens: [Ocap_IndexedTokenInput] {
    get {return _storage._revokedTokens}
    set {_uniqueStorage()._revokedTokens = newValue}
  }

  public var revokedAssets: [String] {
    get {return _storage._revokedAssets}
    set {_uniqueStorage()._revokedAssets = newValue}
  }

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RollupState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// FUTURE: how to handle 1 ocap token mapping to multiple foreign chains
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var tokenAddress: String {
    get {return _storage._tokenAddress}
    set {_uniqueStorage()._tokenAddress = newValue}
  }

  /// FUTURE: how to support main token on foreign chain: such as ETH and BNB
  public var contractAddress: String {
    get {return _storage._contractAddress}
    set {_uniqueStorage()._contractAddress = newValue}
  }

  /// Future mutation to rollup validators and blocks must be signed by this validator.
  public var seedValidators: [Ocap_RollupValidator] {
    get {return _storage._seedValidators}
    set {_uniqueStorage()._seedValidators = newValue}
  }

  /// List of verified validators that can handling rollup/rolludown traffic
  /// Can only be updated by JoinRollupTx and LeaveRollupTx
  public var validators: [Ocap_RollupValidator] {
    get {return _storage._validators}
    set {_uniqueStorage()._validators = newValue}
  }

  /// Mutable
  public var minStakeAmount: String {
    get {return _storage._minStakeAmount}
    set {_uniqueStorage()._minStakeAmount = newValue}
  }

  public var maxStakeAmount: String {
    get {return _storage._maxStakeAmount}
    set {_uniqueStorage()._maxStakeAmount = newValue}
  }

  /// Mutable
  public var minSignerCount: UInt32 {
    get {return _storage._minSignerCount}
    set {_uniqueStorage()._minSignerCount = newValue}
  }

  public var maxSignerCount: UInt32 {
    get {return _storage._maxSignerCount}
    set {_uniqueStorage()._maxSignerCount = newValue}
  }

  /// Mutable
  public var minBlockSize: UInt32 {
    get {return _storage._minBlockSize}
    set {_uniqueStorage()._minBlockSize = newValue}
  }

  /// default to 10, ideally cost < income
  public var maxBlockSize: UInt32 {
    get {return _storage._maxBlockSize}
    set {_uniqueStorage()._maxBlockSize = newValue}
  }

  /// Mutable
  public var minBlockInterval: UInt32 {
    get {return _storage._minBlockInterval}
    set {_uniqueStorage()._minBlockInterval = newValue}
  }

  /// Minimum confirmations for a tx on foreign chain before it can submit to ocap chain
  public var minBlockConfirmation: UInt32 {
    get {return _storage._minBlockConfirmation}
    set {_uniqueStorage()._minBlockConfirmation = newValue}
  }

  /// Immutable
  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  /// Mutable
  /// Following fields define the economic policy for the rollup
  /// All fee and share fields are devided by 10000, and then converted to percentage for later calculation
  /// Let's take following settings for example:
  /// - deposit_fee_rate = 100 / 10000 = 1%,
  /// - publisher_fee_share = 6000 / 10000 = 60%
  /// - proposer_fee_share = 3000 / 10000 = 30%
  /// When user deposit 10000 ABT, he will receive 9900 ABT after deposit, and pay 100 ABT as fee
  /// After the tx is included in a block and published to foreign chain, the fee can be claimed:
  /// - block publisher: 100 * 60% = 60 ABT, given to block publisher
  /// - proposer total: 100 * 30% = 30 ABT, shared between tx proposer and block proposer
  /// - validator total: 100 * 10% = 10 ABT, shared between all signers, including the proposer
  public var depositFeeRate: UInt32 {
    get {return _storage._depositFeeRate}
    set {_uniqueStorage()._depositFeeRate = newValue}
  }

  public var withdrawFeeRate: UInt32 {
    get {return _storage._withdrawFeeRate}
    set {_uniqueStorage()._withdrawFeeRate = newValue}
  }

  public var proposerFeeShare: UInt32 {
    get {return _storage._proposerFeeShare}
    set {_uniqueStorage()._proposerFeeShare = newValue}
  }

  public var publisherFeeShare: UInt32 {
    get {return _storage._publisherFeeShare}
    set {_uniqueStorage()._publisherFeeShare = newValue}
  }

  /// Mutable
  public var minDepositAmount: String {
    get {return _storage._minDepositAmount}
    set {_uniqueStorage()._minDepositAmount = newValue}
  }

  public var minWithdrawAmount: String {
    get {return _storage._minWithdrawAmount}
    set {_uniqueStorage()._minWithdrawAmount = newValue}
  }

  /// Mutable, updated on each new block
  public var blockHeight: UInt64 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  public var blockHash: String {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  public var tokenInfo: Ocap_IndexedTokenInput {
    get {return _storage._tokenInfo ?? Ocap_IndexedTokenInput()}
    set {_uniqueStorage()._tokenInfo = newValue}
  }
  /// Returns true if `tokenInfo` has been explicitly set.
  public var hasTokenInfo: Bool {return _storage._tokenInfo != nil}
  /// Clears the value of `tokenInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTokenInfo() {_uniqueStorage()._tokenInfo = nil}

  public var totalDepositAmount: String {
    get {return _storage._totalDepositAmount}
    set {_uniqueStorage()._totalDepositAmount = newValue}
  }

  public var totalWithdrawAmount: String {
    get {return _storage._totalWithdrawAmount}
    set {_uniqueStorage()._totalWithdrawAmount = newValue}
  }

  /// Added since v1.13.45
  public var maxDepositAmount: String {
    get {return _storage._maxDepositAmount}
    set {_uniqueStorage()._maxDepositAmount = newValue}
  }

  public var maxWithdrawAmount: String {
    get {return _storage._maxWithdrawAmount}
    set {_uniqueStorage()._maxWithdrawAmount = newValue}
  }

  public var minDepositFee: String {
    get {return _storage._minDepositFee}
    set {_uniqueStorage()._minDepositFee = newValue}
  }

  public var maxDepositFee: String {
    get {return _storage._maxDepositFee}
    set {_uniqueStorage()._maxDepositFee = newValue}
  }

  public var minWithdrawFee: String {
    get {return _storage._minWithdrawFee}
    set {_uniqueStorage()._minWithdrawFee = newValue}
  }

  public var maxWithdrawFee: String {
    get {return _storage._maxWithdrawFee}
    set {_uniqueStorage()._maxWithdrawFee = newValue}
  }

  public var paused: Bool {
    get {return _storage._paused}
    set {_uniqueStorage()._paused = newValue}
  }

  /// Added since v1.13.47
  public var foreignToken: Ocap_ForeignToken {
    get {return _storage._foreignToken ?? Ocap_ForeignToken()}
    set {_uniqueStorage()._foreignToken = newValue}
  }
  /// Returns true if `foreignToken` has been explicitly set.
  public var hasForeignToken: Bool {return _storage._foreignToken != nil}
  /// Clears the value of `foreignToken`. Subsequent reads from it will return its default value.
  public mutating func clearForeignToken() {_uniqueStorage()._foreignToken = nil}

  /// Added since v1.13.53
  /// How long the staking will be locked after the validator leave and revoke stake
  public var leaveWaitingPeriod: UInt32 {
    get {return _storage._leaveWaitingPeriod}
    set {_uniqueStorage()._leaveWaitingPeriod = newValue}
  }

  /// Added since v1.13.61
  /// How long have the non-producer publisher have to wait before he can publish the block
  /// If a block is published by a non-producer, the producer will get slashed
  public var publishWaitingPeriod: UInt32 {
    get {return _storage._publishWaitingPeriod}
    set {_uniqueStorage()._publishWaitingPeriod = newValue}
  }

  /// If set to 100, then 1% x min_stake_amount will be slashed from the producer
  public var publishSlashRate: UInt32 {
    get {return _storage._publishSlashRate}
    set {_uniqueStorage()._publishSlashRate = newValue}
  }

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RollupBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// = sha3(merkle_root + previous_hash + txs_hash)
  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  /// = merkle(txs.filter(x => x.type === withdraw))
  public var merkleRoot: String {
    get {return _storage._merkleRoot}
    set {_uniqueStorage()._merkleRoot = newValue}
  }

  /// = previous block hash
  public var previousHash: String {
    get {return _storage._previousHash}
    set {_uniqueStorage()._previousHash = newValue}
  }

  /// = sha3(sort(txs hash))
  public var txsHash: String {
    get {return _storage._txsHash}
    set {_uniqueStorage()._txsHash = newValue}
  }

  /// list of transaction hashes, can be used to recreate merkleRoot deterministicly
  /// must all be valid transactions (exist, succeed, not included in any block)
  /// must only contain deposit/withdraw transactions
  /// when a new block is accepted, tokens will be minted for deposit transactions and burn for withdraw transactions
  public var txs: [String] {
    get {return _storage._txs}
    set {_uniqueStorage()._txs = newValue}
  }

  /// Must refer to a known validator for this chain
  public var proposer: String {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  /// List of signatures by validators
  /// This signature is generated by signing the block hash
  public var signatures: [Ocap_Multisig] {
    get {return _storage._signatures}
    set {_uniqueStorage()._signatures = newValue}
  }

  public var rollup: String {
    get {return _storage._rollup}
    set {_uniqueStorage()._rollup = newValue}
  }

  /// token stats
  public var mintedAmount: String {
    get {return _storage._mintedAmount}
    set {_uniqueStorage()._mintedAmount = newValue}
  }

  public var burnedAmount: String {
    get {return _storage._burnedAmount}
    set {_uniqueStorage()._burnedAmount = newValue}
  }

  /// tatal reward amount for publisher, proposer and validator
  public var rewardAmount: String {
    get {return _storage._rewardAmount}
    set {_uniqueStorage()._rewardAmount = newValue}
  }

  /// Added since v1.13.61
  /// Used to calculate the actual reward for speedup txs
  /// The total reward from all txs should not be less than the min reward
  /// And the publisher share of total reward should cover the block sync cost
  public var minReward: String {
    get {return _storage._minReward}
    set {_uniqueStorage()._minReward = newValue}
  }

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_EvidenceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String = String()

  public var data: String = String()

  public var context: Ocap_StateContext {
    get {return _context ?? Ocap_StateContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Ocap_StateContext? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_AccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "num_txs"),
    4: .same(proto: "address"),
    5: .same(proto: "pk"),
    6: .same(proto: "type"),
    7: .same(proto: "moniker"),
    8: .same(proto: "context"),
    9: .same(proto: "issuer"),
    10: .standard(proto: "gas_balance"),
    13: .standard(proto: "migrated_to"),
    14: .standard(proto: "migrated_from"),
    15: .standard(proto: "num_assets"),
    16: .same(proto: "stake"),
    17: .standard(proto: "pinned_files"),
    19: .standard(proto: "deposit_received"),
    20: .standard(proto: "withdraw_items"),
    21: .same(proto: "tokens"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _balance: Ocap_BigUint? = nil
    var _nonce: String = String()
    var _numTxs: String = String()
    var _address: String = String()
    var _pk: Data = Data()
    var _type: Ocap_WalletType? = nil
    var _moniker: String = String()
    var _context: Ocap_StateContext? = nil
    var _issuer: String = String()
    var _gasBalance: Ocap_BigUint? = nil
    var _migratedTo: [String] = []
    var _migratedFrom: [String] = []
    var _numAssets: String = String()
    var _stake: Ocap_StakeContext? = nil
    var _pinnedFiles: Ocap_CircularQueue? = nil
    var _depositReceived: Ocap_BigUint? = nil
    var _withdrawItems: Ocap_CircularQueue? = nil
    var _tokens: [Ocap_IndexedTokenInput] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _balance = source._balance
      _nonce = source._nonce
      _numTxs = source._numTxs
      _address = source._address
      _pk = source._pk
      _type = source._type
      _moniker = source._moniker
      _context = source._context
      _issuer = source._issuer
      _gasBalance = source._gasBalance
      _migratedTo = source._migratedTo
      _migratedFrom = source._migratedFrom
      _numAssets = source._numAssets
      _stake = source._stake
      _pinnedFiles = source._pinnedFiles
      _depositReceived = source._depositReceived
      _withdrawItems = source._withdrawItems
      _tokens = source._tokens
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._balance) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._nonce) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._numTxs) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._pk) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._type) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._moniker) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._context) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._issuer) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._gasBalance) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._migratedTo) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._migratedFrom) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._numAssets) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._stake) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._pinnedFiles) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._depositReceived) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._withdrawItems) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokens) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._nonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nonce, fieldNumber: 2)
      }
      if !_storage._numTxs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._numTxs, fieldNumber: 3)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 4)
      }
      if !_storage._pk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pk, fieldNumber: 5)
      }
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 7)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 9)
      }
      if let v = _storage._gasBalance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._migratedTo.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migratedTo, fieldNumber: 13)
      }
      if !_storage._migratedFrom.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migratedFrom, fieldNumber: 14)
      }
      if !_storage._numAssets.isEmpty {
        try visitor.visitSingularStringField(value: _storage._numAssets, fieldNumber: 15)
      }
      if let v = _storage._stake {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._pinnedFiles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._depositReceived {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._withdrawItems {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 21)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AccountState, rhs: Ocap_AccountState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._gasBalance != rhs_storage._gasBalance {return false}
        if _storage._migratedTo != rhs_storage._migratedTo {return false}
        if _storage._migratedFrom != rhs_storage._migratedFrom {return false}
        if _storage._numAssets != rhs_storage._numAssets {return false}
        if _storage._stake != rhs_storage._stake {return false}
        if _storage._pinnedFiles != rhs_storage._pinnedFiles {return false}
        if _storage._depositReceived != rhs_storage._depositReceived {return false}
        if _storage._withdrawItems != rhs_storage._withdrawItems {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .same(proto: "moniker"),
    4: .same(proto: "readonly"),
    5: .same(proto: "transferrable"),
    6: .same(proto: "ttl"),
    7: .standard(proto: "consumed_time"),
    8: .same(proto: "issuer"),
    9: .same(proto: "parent"),
    13: .same(proto: "stake"),
    14: .same(proto: "context"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _moniker: String = String()
    var _readonly: Bool = false
    var _transferrable: Bool = false
    var _ttl: UInt32 = 0
    var _consumedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _issuer: String = String()
    var _parent: String = String()
    var _stake: Ocap_StakeContext? = nil
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _moniker = source._moniker
      _readonly = source._readonly
      _transferrable = source._transferrable
      _ttl = source._ttl
      _consumedTime = source._consumedTime
      _issuer = source._issuer
      _parent = source._parent
      _stake = source._stake
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._owner) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._moniker) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._readonly) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._transferrable) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._ttl) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._consumedTime) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._issuer) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._stake) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._context) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 3)
      }
      if _storage._readonly != false {
        try visitor.visitSingularBoolField(value: _storage._readonly, fieldNumber: 4)
      }
      if _storage._transferrable != false {
        try visitor.visitSingularBoolField(value: _storage._transferrable, fieldNumber: 5)
      }
      if _storage._ttl != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ttl, fieldNumber: 6)
      }
      if let v = _storage._consumedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 8)
      }
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 9)
      }
      if let v = _storage._stake {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetState, rhs: Ocap_AssetState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._readonly != rhs_storage._readonly {return false}
        if _storage._transferrable != rhs_storage._transferrable {return false}
        if _storage._ttl != rhs_storage._ttl {return false}
        if _storage._consumedTime != rhs_storage._consumedTime {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._stake != rhs_storage._stake {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_CoreProtocol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoreProtocol"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_CoreProtocol, rhs: Ocap_CoreProtocol) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "consensus"),
    3: .same(proto: "tasks"),
    4: .standard(proto: "stake_summary"),
    5: .same(proto: "version"),
    8: .same(proto: "token"),
    9: .standard(proto: "tx_config"),
    12: .same(proto: "protocols"),
    13: .same(proto: "gas"),
    14: .standard(proto: "upgrade_info"),
    16: .standard(proto: "account_config"),
    17: .standard(proto: "token_swap_config"),
    2047: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _consensus: Ocap_ConsensusParams? = nil
    var _tasks: Dictionary<UInt64,Ocap_UpgradeTasks> = [:]
    var _stakeSummary: Dictionary<UInt32,Ocap_StakeSummary> = [:]
    var _version: String = String()
    var _token: Ocap_ForgeToken? = nil
    var _txConfig: Ocap_TransactionConfig? = nil
    var _protocols: [Ocap_CoreProtocol] = []
    var _gas: Dictionary<String,UInt32> = [:]
    var _upgradeInfo: Ocap_UpgradeInfo? = nil
    var _accountConfig: Dictionary<String,Ocap_AccountConfig> = [:]
    var _tokenSwapConfig: Ocap_TokenSwapConfig? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _consensus = source._consensus
      _tasks = source._tasks
      _stakeSummary = source._stakeSummary
      _version = source._version
      _token = source._token
      _txConfig = source._txConfig
      _protocols = source._protocols
      _gas = source._gas
      _upgradeInfo = source._upgradeInfo
      _accountConfig = source._accountConfig
      _tokenSwapConfig = source._tokenSwapConfig
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._consensus) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt64,Ocap_UpgradeTasks>.self, value: &_storage._tasks) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Ocap_StakeSummary>.self, value: &_storage._stakeSummary) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._token) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._txConfig) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._protocols) }()
        case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &_storage._gas) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._upgradeInfo) }()
        case 16: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_AccountConfig>.self, value: &_storage._accountConfig) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._tokenSwapConfig) }()
        case 2047: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._consensus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._tasks.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt64,Ocap_UpgradeTasks>.self, value: _storage._tasks, fieldNumber: 3)
      }
      if !_storage._stakeSummary.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Ocap_StakeSummary>.self, value: _storage._stakeSummary, fieldNumber: 4)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 5)
      }
      if let v = _storage._token {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._txConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._protocols.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._protocols, fieldNumber: 12)
      }
      if !_storage._gas.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: _storage._gas, fieldNumber: 13)
      }
      if let v = _storage._upgradeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if !_storage._accountConfig.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_AccountConfig>.self, value: _storage._accountConfig, fieldNumber: 16)
      }
      if let v = _storage._tokenSwapConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2047)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ForgeState, rhs: Ocap_ForgeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._consensus != rhs_storage._consensus {return false}
        if _storage._tasks != rhs_storage._tasks {return false}
        if _storage._stakeSummary != rhs_storage._stakeSummary {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._txConfig != rhs_storage._txConfig {return false}
        if _storage._protocols != rhs_storage._protocols {return false}
        if _storage._gas != rhs_storage._gas {return false}
        if _storage._upgradeInfo != rhs_storage._upgradeInfo {return false}
        if _storage._accountConfig != rhs_storage._accountConfig {return false}
        if _storage._tokenSwapConfig != rhs_storage._tokenSwapConfig {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RootState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RootState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "account"),
    3: .same(proto: "asset"),
    4: .same(proto: "receipt"),
    5: .same(proto: "protocol"),
    6: .same(proto: "governance"),
    7: .same(proto: "custom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.account) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.asset) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.receipt) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.`protocol`) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.governance) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.custom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularBytesField(value: self.account, fieldNumber: 2)
    }
    if !self.asset.isEmpty {
      try visitor.visitSingularBytesField(value: self.asset, fieldNumber: 3)
    }
    if !self.receipt.isEmpty {
      try visitor.visitSingularBytesField(value: self.receipt, fieldNumber: 4)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularBytesField(value: self.`protocol`, fieldNumber: 5)
    }
    if !self.governance.isEmpty {
      try visitor.visitSingularBytesField(value: self.governance, fieldNumber: 6)
    }
    if !self.custom.isEmpty {
      try visitor.visitSingularBytesField(value: self.custom, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RootState, rhs: Ocap_RootState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.account != rhs.account {return false}
    if lhs.asset != rhs.asset {return false}
    if lhs.receipt != rhs.receipt {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.governance != rhs.governance {return false}
    if lhs.custom != rhs.custom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_StatisticsState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatisticsState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "num_txs"),
    4: .standard(proto: "num_stakes"),
    5: .standard(proto: "num_validators"),
    6: .standard(proto: "tx_statistics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numBlocks) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.numTxs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._numStakes) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numValidators) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._txStatistics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.numBlocks != 0 {
      try visitor.visitSingularUInt64Field(value: self.numBlocks, fieldNumber: 2)
    }
    if self.numTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numTxs, fieldNumber: 3)
    }
    if let v = self._numStakes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.numValidators != 0 {
      try visitor.visitSingularUInt32Field(value: self.numValidators, fieldNumber: 5)
    }
    if let v = self._txStatistics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_StatisticsState, rhs: Ocap_StatisticsState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.numBlocks != rhs.numBlocks {return false}
    if lhs.numTxs != rhs.numTxs {return false}
    if lhs._numStakes != rhs._numStakes {return false}
    if lhs.numValidators != rhs.numValidators {return false}
    if lhs._txStatistics != rhs._txStatistics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_SwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "address"),
    3: .same(proto: "hashkey"),
    4: .same(proto: "sender"),
    5: .same(proto: "receiver"),
    6: .same(proto: "value"),
    7: .same(proto: "assets"),
    8: .same(proto: "locktime"),
    9: .same(proto: "hashlock"),
    10: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hashkey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.receiver) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.assets) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.locktime) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.hashlock) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.hashkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hashkey, fieldNumber: 3)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 4)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 5)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 7)
    }
    if self.locktime != 0 {
      try visitor.visitSingularUInt32Field(value: self.locktime, fieldNumber: 8)
    }
    if !self.hashlock.isEmpty {
      try visitor.visitSingularBytesField(value: self.hashlock, fieldNumber: 9)
    }
    if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_SwapState, rhs: Ocap_SwapState) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.address != rhs.address {return false}
    if lhs.hashkey != rhs.hashkey {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs._value != rhs._value {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.locktime != rhs.locktime {return false}
    if lhs.hashlock != rhs.hashlock {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_SwapStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "locked_value_out"),
    3: .standard(proto: "locked_value_in"),
    4: .standard(proto: "locked_assets_out"),
    5: .standard(proto: "locked_assets_in"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lockedValueOut) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lockedValueIn) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.lockedAssetsOut) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.lockedAssetsIn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if let v = self._lockedValueOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._lockedValueIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.lockedAssetsOut != 0 {
      try visitor.visitSingularUInt32Field(value: self.lockedAssetsOut, fieldNumber: 4)
    }
    if self.lockedAssetsIn != 0 {
      try visitor.visitSingularUInt32Field(value: self.lockedAssetsIn, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_SwapStatistics, rhs: Ocap_SwapStatistics) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._lockedValueOut != rhs._lockedValueOut {return false}
    if lhs._lockedValueIn != rhs._lockedValueIn {return false}
    if lhs.lockedAssetsOut != rhs.lockedAssetsOut {return false}
    if lhs.lockedAssetsIn != rhs.lockedAssetsIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegateOpState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateOpState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .standard(proto: "num_txs"),
    3: .standard(proto: "num_txs_delta"),
    4: .same(proto: "balance"),
    5: .standard(proto: "balance_delta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rule) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.numTxs) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.numTxsDelta) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._balanceDelta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rule.isEmpty {
      try visitor.visitSingularStringField(value: self.rule, fieldNumber: 1)
    }
    if self.numTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numTxs, fieldNumber: 2)
    }
    if self.numTxsDelta != 0 {
      try visitor.visitSingularUInt64Field(value: self.numTxsDelta, fieldNumber: 3)
    }
    if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._balanceDelta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegateOpState, rhs: Ocap_DelegateOpState) -> Bool {
    if lhs.rule != rhs.rule {return false}
    if lhs.numTxs != rhs.numTxs {return false}
    if lhs.numTxsDelta != rhs.numTxsDelta {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs._balanceDelta != rhs._balanceDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "ops"),
    14: .same(proto: "context"),
    15: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_DelegateOpState>.self, value: &self.ops) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.ops.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_DelegateOpState>.self, value: self.ops, fieldNumber: 2)
    }
    if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegateState, rhs: Ocap_DelegateState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.ops != rhs.ops {return false}
    if lhs._context != rhs._context {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "issuer"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "symbol"),
    6: .same(proto: "unit"),
    7: .same(proto: "decimal"),
    8: .same(proto: "icon"),
    9: .standard(proto: "total_supply"),
    10: .standard(proto: "foreign_token"),
    15: .same(proto: "context"),
    20: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _issuer: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _symbol: String = String()
    var _unit: String = String()
    var _decimal: UInt32 = 0
    var _icon: String = String()
    var _totalSupply: String = String()
    var _foreignToken: Ocap_ForeignToken? = nil
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _issuer = source._issuer
      _name = source._name
      _description_p = source._description_p
      _symbol = source._symbol
      _unit = source._unit
      _decimal = source._decimal
      _icon = source._icon
      _totalSupply = source._totalSupply
      _foreignToken = source._foreignToken
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._issuer) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._symbol) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._unit) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._decimal) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._icon) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._totalSupply) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._foreignToken) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._context) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 5)
      }
      if !_storage._unit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unit, fieldNumber: 6)
      }
      if _storage._decimal != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._decimal, fieldNumber: 7)
      }
      if !_storage._icon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._icon, fieldNumber: 8)
      }
      if !_storage._totalSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalSupply, fieldNumber: 9)
      }
      if let v = _storage._foreignToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenState, rhs: Ocap_TokenState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        if _storage._unit != rhs_storage._unit {return false}
        if _storage._decimal != rhs_storage._decimal {return false}
        if _storage._icon != rhs_storage._icon {return false}
        if _storage._totalSupply != rhs_storage._totalSupply {return false}
        if _storage._foreignToken != rhs_storage._foreignToken {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "settlement"),
    6: .same(proto: "limit"),
    7: .standard(proto: "trusted_issuers"),
    8: .same(proto: "input"),
    9: .same(proto: "output"),
    10: .same(proto: "hooks"),
    11: .same(proto: "data"),
    12: .same(proto: "context"),
    13: .same(proto: "balance"),
    14: .same(proto: "tokens"),
    15: .standard(proto: "num_minted"),
    16: .same(proto: "display"),
    17: .standard(proto: "last_settlement"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _settlement: String = String()
    var _limit: UInt32 = 0
    var _trustedIssuers: [String] = []
    var _input: Ocap_IndexedFactoryInput? = nil
    var _output: Ocap_CreateAssetTx? = nil
    var _hooks: [Ocap_AssetFactoryHook] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _context: Ocap_StateContext? = nil
    var _balance: Ocap_BigUint? = nil
    var _tokens: [Ocap_IndexedTokenInput] = []
    var _numMinted: UInt32 = 0
    var _display: Ocap_AssetDisplay? = nil
    var _lastSettlement: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _name = source._name
      _description_p = source._description_p
      _settlement = source._settlement
      _limit = source._limit
      _trustedIssuers = source._trustedIssuers
      _input = source._input
      _output = source._output
      _hooks = source._hooks
      _data = source._data
      _context = source._context
      _balance = source._balance
      _tokens = source._tokens
      _numMinted = source._numMinted
      _display = source._display
      _lastSettlement = source._lastSettlement
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._owner) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._settlement) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._limit) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._trustedIssuers) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._output) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._hooks) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._context) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._balance) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokens) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._numMinted) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._display) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._lastSettlement) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if !_storage._settlement.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlement, fieldNumber: 5)
      }
      if _storage._limit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._limit, fieldNumber: 6)
      }
      if !_storage._trustedIssuers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._trustedIssuers, fieldNumber: 7)
      }
      if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._output {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._hooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hooks, fieldNumber: 10)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 14)
      }
      if _storage._numMinted != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numMinted, fieldNumber: 15)
      }
      if let v = _storage._display {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._lastSettlement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFactoryState, rhs: Ocap_AssetFactoryState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._settlement != rhs_storage._settlement {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._trustedIssuers != rhs_storage._trustedIssuers {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._hooks != rhs_storage._hooks {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._numMinted != rhs_storage._numMinted {return false}
        if _storage._display != rhs_storage._display {return false}
        if _storage._lastSettlement != rhs_storage._lastSettlement {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_StakeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .same(proto: "tokens"),
    5: .same(proto: "assets"),
    6: .same(proto: "revocable"),
    7: .same(proto: "message"),
    8: .standard(proto: "revoke_waiting_period"),
    9: .standard(proto: "revoked_tokens"),
    10: .standard(proto: "revoked_assets"),
    30: .same(proto: "context"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _sender: String = String()
    var _receiver: String = String()
    var _tokens: [Ocap_IndexedTokenInput] = []
    var _assets: [String] = []
    var _revocable: Bool = false
    var _message: String = String()
    var _revokeWaitingPeriod: UInt32 = 0
    var _revokedTokens: [Ocap_IndexedTokenInput] = []
    var _revokedAssets: [String] = []
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _sender = source._sender
      _receiver = source._receiver
      _tokens = source._tokens
      _assets = source._assets
      _revocable = source._revocable
      _message = source._message
      _revokeWaitingPeriod = source._revokeWaitingPeriod
      _revokedTokens = source._revokedTokens
      _revokedAssets = source._revokedAssets
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sender) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._receiver) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._tokens) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._assets) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._revocable) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._revokeWaitingPeriod) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._revokedTokens) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._revokedAssets) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._context) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 2)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 3)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 4)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 5)
      }
      if _storage._revocable != false {
        try visitor.visitSingularBoolField(value: _storage._revocable, fieldNumber: 6)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 7)
      }
      if _storage._revokeWaitingPeriod != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._revokeWaitingPeriod, fieldNumber: 8)
      }
      if !_storage._revokedTokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._revokedTokens, fieldNumber: 9)
      }
      if !_storage._revokedAssets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._revokedAssets, fieldNumber: 10)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_StakeState, rhs: Ocap_StakeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._revocable != rhs_storage._revocable {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._revokeWaitingPeriod != rhs_storage._revokeWaitingPeriod {return false}
        if _storage._revokedTokens != rhs_storage._revokedTokens {return false}
        if _storage._revokedAssets != rhs_storage._revokedAssets {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RollupState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollupState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "token_address"),
    4: .standard(proto: "contract_address"),
    5: .standard(proto: "seed_validators"),
    6: .same(proto: "validators"),
    7: .standard(proto: "min_stake_amount"),
    8: .standard(proto: "max_stake_amount"),
    9: .standard(proto: "min_signer_count"),
    10: .standard(proto: "max_signer_count"),
    11: .standard(proto: "min_block_size"),
    12: .standard(proto: "max_block_size"),
    13: .standard(proto: "min_block_interval"),
    14: .standard(proto: "min_block_confirmation"),
    17: .same(proto: "issuer"),
    18: .standard(proto: "deposit_fee_rate"),
    19: .standard(proto: "withdraw_fee_rate"),
    20: .standard(proto: "proposer_fee_share"),
    21: .standard(proto: "publisher_fee_share"),
    22: .standard(proto: "min_deposit_amount"),
    23: .standard(proto: "min_withdraw_amount"),
    24: .standard(proto: "block_height"),
    25: .standard(proto: "block_hash"),
    26: .standard(proto: "token_info"),
    27: .standard(proto: "total_deposit_amount"),
    28: .standard(proto: "total_withdraw_amount"),
    29: .standard(proto: "max_deposit_amount"),
    30: .standard(proto: "max_withdraw_amount"),
    31: .standard(proto: "min_deposit_fee"),
    32: .standard(proto: "max_deposit_fee"),
    33: .standard(proto: "min_withdraw_fee"),
    34: .standard(proto: "max_withdraw_fee"),
    35: .same(proto: "paused"),
    36: .standard(proto: "foreign_token"),
    37: .standard(proto: "leave_waiting_period"),
    38: .standard(proto: "publish_waiting_period"),
    39: .standard(proto: "publish_slash_rate"),
    40: .same(proto: "context"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _tokenAddress: String = String()
    var _contractAddress: String = String()
    var _seedValidators: [Ocap_RollupValidator] = []
    var _validators: [Ocap_RollupValidator] = []
    var _minStakeAmount: String = String()
    var _maxStakeAmount: String = String()
    var _minSignerCount: UInt32 = 0
    var _maxSignerCount: UInt32 = 0
    var _minBlockSize: UInt32 = 0
    var _maxBlockSize: UInt32 = 0
    var _minBlockInterval: UInt32 = 0
    var _minBlockConfirmation: UInt32 = 0
    var _issuer: String = String()
    var _depositFeeRate: UInt32 = 0
    var _withdrawFeeRate: UInt32 = 0
    var _proposerFeeShare: UInt32 = 0
    var _publisherFeeShare: UInt32 = 0
    var _minDepositAmount: String = String()
    var _minWithdrawAmount: String = String()
    var _blockHeight: UInt64 = 0
    var _blockHash: String = String()
    var _tokenInfo: Ocap_IndexedTokenInput? = nil
    var _totalDepositAmount: String = String()
    var _totalWithdrawAmount: String = String()
    var _maxDepositAmount: String = String()
    var _maxWithdrawAmount: String = String()
    var _minDepositFee: String = String()
    var _maxDepositFee: String = String()
    var _minWithdrawFee: String = String()
    var _maxWithdrawFee: String = String()
    var _paused: Bool = false
    var _foreignToken: Ocap_ForeignToken? = nil
    var _leaveWaitingPeriod: UInt32 = 0
    var _publishWaitingPeriod: UInt32 = 0
    var _publishSlashRate: UInt32 = 0
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _tokenAddress = source._tokenAddress
      _contractAddress = source._contractAddress
      _seedValidators = source._seedValidators
      _validators = source._validators
      _minStakeAmount = source._minStakeAmount
      _maxStakeAmount = source._maxStakeAmount
      _minSignerCount = source._minSignerCount
      _maxSignerCount = source._maxSignerCount
      _minBlockSize = source._minBlockSize
      _maxBlockSize = source._maxBlockSize
      _minBlockInterval = source._minBlockInterval
      _minBlockConfirmation = source._minBlockConfirmation
      _issuer = source._issuer
      _depositFeeRate = source._depositFeeRate
      _withdrawFeeRate = source._withdrawFeeRate
      _proposerFeeShare = source._proposerFeeShare
      _publisherFeeShare = source._publisherFeeShare
      _minDepositAmount = source._minDepositAmount
      _minWithdrawAmount = source._minWithdrawAmount
      _blockHeight = source._blockHeight
      _blockHash = source._blockHash
      _tokenInfo = source._tokenInfo
      _totalDepositAmount = source._totalDepositAmount
      _totalWithdrawAmount = source._totalWithdrawAmount
      _maxDepositAmount = source._maxDepositAmount
      _maxWithdrawAmount = source._maxWithdrawAmount
      _minDepositFee = source._minDepositFee
      _maxDepositFee = source._maxDepositFee
      _minWithdrawFee = source._minWithdrawFee
      _maxWithdrawFee = source._maxWithdrawFee
      _paused = source._paused
      _foreignToken = source._foreignToken
      _leaveWaitingPeriod = source._leaveWaitingPeriod
      _publishWaitingPeriod = source._publishWaitingPeriod
      _publishSlashRate = source._publishSlashRate
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._tokenAddress) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._contractAddress) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._seedValidators) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._validators) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._minStakeAmount) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._maxStakeAmount) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._minSignerCount) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxSignerCount) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._minBlockSize) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxBlockSize) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._minBlockInterval) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._minBlockConfirmation) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._issuer) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._depositFeeRate) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._withdrawFeeRate) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._proposerFeeShare) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._publisherFeeShare) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._minDepositAmount) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._minWithdrawAmount) }()
        case 24: try { try decoder.decodeSingularUInt64Field(value: &_storage._blockHeight) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._blockHash) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._tokenInfo) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._totalDepositAmount) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._totalWithdrawAmount) }()
        case 29: try { try decoder.decodeSingularStringField(value: &_storage._maxDepositAmount) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._maxWithdrawAmount) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._minDepositFee) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._maxDepositFee) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._minWithdrawFee) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._maxWithdrawFee) }()
        case 35: try { try decoder.decodeSingularBoolField(value: &_storage._paused) }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._foreignToken) }()
        case 37: try { try decoder.decodeSingularUInt32Field(value: &_storage._leaveWaitingPeriod) }()
        case 38: try { try decoder.decodeSingularUInt32Field(value: &_storage._publishWaitingPeriod) }()
        case 39: try { try decoder.decodeSingularUInt32Field(value: &_storage._publishSlashRate) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._context) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._tokenAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tokenAddress, fieldNumber: 2)
      }
      if !_storage._contractAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contractAddress, fieldNumber: 4)
      }
      if !_storage._seedValidators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._seedValidators, fieldNumber: 5)
      }
      if !_storage._validators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._validators, fieldNumber: 6)
      }
      if !_storage._minStakeAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minStakeAmount, fieldNumber: 7)
      }
      if !_storage._maxStakeAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxStakeAmount, fieldNumber: 8)
      }
      if _storage._minSignerCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minSignerCount, fieldNumber: 9)
      }
      if _storage._maxSignerCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxSignerCount, fieldNumber: 10)
      }
      if _storage._minBlockSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minBlockSize, fieldNumber: 11)
      }
      if _storage._maxBlockSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxBlockSize, fieldNumber: 12)
      }
      if _storage._minBlockInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minBlockInterval, fieldNumber: 13)
      }
      if _storage._minBlockConfirmation != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minBlockConfirmation, fieldNumber: 14)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 17)
      }
      if _storage._depositFeeRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._depositFeeRate, fieldNumber: 18)
      }
      if _storage._withdrawFeeRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._withdrawFeeRate, fieldNumber: 19)
      }
      if _storage._proposerFeeShare != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._proposerFeeShare, fieldNumber: 20)
      }
      if _storage._publisherFeeShare != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._publisherFeeShare, fieldNumber: 21)
      }
      if !_storage._minDepositAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minDepositAmount, fieldNumber: 22)
      }
      if !_storage._minWithdrawAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minWithdrawAmount, fieldNumber: 23)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._blockHeight, fieldNumber: 24)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockHash, fieldNumber: 25)
      }
      if let v = _storage._tokenInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if !_storage._totalDepositAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalDepositAmount, fieldNumber: 27)
      }
      if !_storage._totalWithdrawAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalWithdrawAmount, fieldNumber: 28)
      }
      if !_storage._maxDepositAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxDepositAmount, fieldNumber: 29)
      }
      if !_storage._maxWithdrawAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxWithdrawAmount, fieldNumber: 30)
      }
      if !_storage._minDepositFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minDepositFee, fieldNumber: 31)
      }
      if !_storage._maxDepositFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxDepositFee, fieldNumber: 32)
      }
      if !_storage._minWithdrawFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minWithdrawFee, fieldNumber: 33)
      }
      if !_storage._maxWithdrawFee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._maxWithdrawFee, fieldNumber: 34)
      }
      if _storage._paused != false {
        try visitor.visitSingularBoolField(value: _storage._paused, fieldNumber: 35)
      }
      if let v = _storage._foreignToken {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }
      if _storage._leaveWaitingPeriod != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._leaveWaitingPeriod, fieldNumber: 37)
      }
      if _storage._publishWaitingPeriod != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._publishWaitingPeriod, fieldNumber: 38)
      }
      if _storage._publishSlashRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._publishSlashRate, fieldNumber: 39)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RollupState, rhs: Ocap_RollupState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._tokenAddress != rhs_storage._tokenAddress {return false}
        if _storage._contractAddress != rhs_storage._contractAddress {return false}
        if _storage._seedValidators != rhs_storage._seedValidators {return false}
        if _storage._validators != rhs_storage._validators {return false}
        if _storage._minStakeAmount != rhs_storage._minStakeAmount {return false}
        if _storage._maxStakeAmount != rhs_storage._maxStakeAmount {return false}
        if _storage._minSignerCount != rhs_storage._minSignerCount {return false}
        if _storage._maxSignerCount != rhs_storage._maxSignerCount {return false}
        if _storage._minBlockSize != rhs_storage._minBlockSize {return false}
        if _storage._maxBlockSize != rhs_storage._maxBlockSize {return false}
        if _storage._minBlockInterval != rhs_storage._minBlockInterval {return false}
        if _storage._minBlockConfirmation != rhs_storage._minBlockConfirmation {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._depositFeeRate != rhs_storage._depositFeeRate {return false}
        if _storage._withdrawFeeRate != rhs_storage._withdrawFeeRate {return false}
        if _storage._proposerFeeShare != rhs_storage._proposerFeeShare {return false}
        if _storage._publisherFeeShare != rhs_storage._publisherFeeShare {return false}
        if _storage._minDepositAmount != rhs_storage._minDepositAmount {return false}
        if _storage._minWithdrawAmount != rhs_storage._minWithdrawAmount {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._tokenInfo != rhs_storage._tokenInfo {return false}
        if _storage._totalDepositAmount != rhs_storage._totalDepositAmount {return false}
        if _storage._totalWithdrawAmount != rhs_storage._totalWithdrawAmount {return false}
        if _storage._maxDepositAmount != rhs_storage._maxDepositAmount {return false}
        if _storage._maxWithdrawAmount != rhs_storage._maxWithdrawAmount {return false}
        if _storage._minDepositFee != rhs_storage._minDepositFee {return false}
        if _storage._maxDepositFee != rhs_storage._maxDepositFee {return false}
        if _storage._minWithdrawFee != rhs_storage._minWithdrawFee {return false}
        if _storage._maxWithdrawFee != rhs_storage._maxWithdrawFee {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._foreignToken != rhs_storage._foreignToken {return false}
        if _storage._leaveWaitingPeriod != rhs_storage._leaveWaitingPeriod {return false}
        if _storage._publishWaitingPeriod != rhs_storage._publishWaitingPeriod {return false}
        if _storage._publishSlashRate != rhs_storage._publishSlashRate {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RollupBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollupBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .standard(proto: "merkle_root"),
    4: .standard(proto: "previous_hash"),
    5: .standard(proto: "txs_hash"),
    6: .same(proto: "txs"),
    7: .same(proto: "proposer"),
    8: .same(proto: "signatures"),
    10: .same(proto: "rollup"),
    11: .standard(proto: "minted_amount"),
    12: .standard(proto: "burned_amount"),
    13: .standard(proto: "reward_amount"),
    14: .standard(proto: "min_reward"),
    30: .same(proto: "context"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _height: UInt64 = 0
    var _merkleRoot: String = String()
    var _previousHash: String = String()
    var _txsHash: String = String()
    var _txs: [String] = []
    var _proposer: String = String()
    var _signatures: [Ocap_Multisig] = []
    var _rollup: String = String()
    var _mintedAmount: String = String()
    var _burnedAmount: String = String()
    var _rewardAmount: String = String()
    var _minReward: String = String()
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _height = source._height
      _merkleRoot = source._merkleRoot
      _previousHash = source._previousHash
      _txsHash = source._txsHash
      _txs = source._txs
      _proposer = source._proposer
      _signatures = source._signatures
      _rollup = source._rollup
      _mintedAmount = source._mintedAmount
      _burnedAmount = source._burnedAmount
      _rewardAmount = source._rewardAmount
      _minReward = source._minReward
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._hash) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._height) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._merkleRoot) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._previousHash) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._txsHash) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._txs) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._proposer) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._signatures) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._rollup) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._mintedAmount) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._burnedAmount) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._rewardAmount) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._minReward) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._context) }()
        case 50: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 2)
      }
      if !_storage._merkleRoot.isEmpty {
        try visitor.visitSingularStringField(value: _storage._merkleRoot, fieldNumber: 3)
      }
      if !_storage._previousHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._previousHash, fieldNumber: 4)
      }
      if !_storage._txsHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._txsHash, fieldNumber: 5)
      }
      if !_storage._txs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._txs, fieldNumber: 6)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proposer, fieldNumber: 7)
      }
      if !_storage._signatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signatures, fieldNumber: 8)
      }
      if !_storage._rollup.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rollup, fieldNumber: 10)
      }
      if !_storage._mintedAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mintedAmount, fieldNumber: 11)
      }
      if !_storage._burnedAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._burnedAmount, fieldNumber: 12)
      }
      if !_storage._rewardAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rewardAmount, fieldNumber: 13)
      }
      if !_storage._minReward.isEmpty {
        try visitor.visitSingularStringField(value: _storage._minReward, fieldNumber: 14)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RollupBlock, rhs: Ocap_RollupBlock) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._merkleRoot != rhs_storage._merkleRoot {return false}
        if _storage._previousHash != rhs_storage._previousHash {return false}
        if _storage._txsHash != rhs_storage._txsHash {return false}
        if _storage._txs != rhs_storage._txs {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._signatures != rhs_storage._signatures {return false}
        if _storage._rollup != rhs_storage._rollup {return false}
        if _storage._mintedAmount != rhs_storage._mintedAmount {return false}
        if _storage._burnedAmount != rhs_storage._burnedAmount {return false}
        if _storage._rewardAmount != rhs_storage._rewardAmount {return false}
        if _storage._minReward != rhs_storage._minReward {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_EvidenceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvidenceState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "data"),
    30: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 30: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_EvidenceState, rhs: Ocap_EvidenceState) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.data != rhs.data {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
