// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Ocap_AccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var nonce: String {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var numTxs: String {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var pk: Data {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  public var type: Ocap_WalletType {
    get {return _storage._type ?? Ocap_WalletType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var gasBalance: Ocap_BigUint {
    get {return _storage._gasBalance ?? Ocap_BigUint()}
    set {_uniqueStorage()._gasBalance = newValue}
  }
  /// Returns true if `gasBalance` has been explicitly set.
  public var hasGasBalance: Bool {return _storage._gasBalance != nil}
  /// Clears the value of `gasBalance`. Subsequent reads from it will return its default value.
  public mutating func clearGasBalance() {_uniqueStorage()._gasBalance = nil}

  /// the address that is being migrated. Once this is set this account state is
  /// read only. No further tx can alter this account state. And tx with "from"
  /// equal to the old address will be rejected by ocap
  public var migratedTo: [String] {
    get {return _storage._migratedTo}
    set {_uniqueStorage()._migratedTo = newValue}
  }

  public var migratedFrom: [String] {
    get {return _storage._migratedFrom}
    set {_uniqueStorage()._migratedFrom = newValue}
  }

  public var numAssets: String {
    get {return _storage._numAssets}
    set {_uniqueStorage()._numAssets = newValue}
  }

  public var stake: Ocap_StakeContext {
    get {return _storage._stake ?? Ocap_StakeContext()}
    set {_uniqueStorage()._stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  public var hasStake: Bool {return _storage._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  public mutating func clearStake() {_uniqueStorage()._stake = nil}

  public var pinnedFiles: Ocap_CircularQueue {
    get {return _storage._pinnedFiles ?? Ocap_CircularQueue()}
    set {_uniqueStorage()._pinnedFiles = newValue}
  }
  /// Returns true if `pinnedFiles` has been explicitly set.
  public var hasPinnedFiles: Bool {return _storage._pinnedFiles != nil}
  /// Clears the value of `pinnedFiles`. Subsequent reads from it will return its default value.
  public mutating func clearPinnedFiles() {_uniqueStorage()._pinnedFiles = nil}

  public var poke: Ocap_PokeInfo {
    get {return _storage._poke ?? Ocap_PokeInfo()}
    set {_uniqueStorage()._poke = newValue}
  }
  /// Returns true if `poke` has been explicitly set.
  public var hasPoke: Bool {return _storage._poke != nil}
  /// Clears the value of `poke`. Subsequent reads from it will return its default value.
  public mutating func clearPoke() {_uniqueStorage()._poke = nil}

  /// The current deposit this account has received. It cannot exceed the deposit
  /// cap.
  public var depositReceived: Ocap_BigUint {
    get {return _storage._depositReceived ?? Ocap_BigUint()}
    set {_uniqueStorage()._depositReceived = newValue}
  }
  /// Returns true if `depositReceived` has been explicitly set.
  public var hasDepositReceived: Bool {return _storage._depositReceived != nil}
  /// Clears the value of `depositReceived`. Subsequent reads from it will return its default value.
  public mutating func clearDepositReceived() {_uniqueStorage()._depositReceived = nil}

  /// 20-49 reserve for future
  public var withdrawItems: Ocap_CircularQueue {
    get {return _storage._withdrawItems ?? Ocap_CircularQueue()}
    set {_uniqueStorage()._withdrawItems = newValue}
  }
  /// Returns true if `withdrawItems` has been explicitly set.
  public var hasWithdrawItems: Bool {return _storage._withdrawItems != nil}
  /// Clears the value of `withdrawItems`. Subsequent reads from it will return its default value.
  public mutating func clearWithdrawItems() {_uniqueStorage()._withdrawItems = nil}

  public var tokens: Dictionary<String,String> {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_AssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var readonly: Bool {
    get {return _storage._readonly}
    set {_uniqueStorage()._readonly = newValue}
  }

  public var transferrable: Bool {
    get {return _storage._transferrable}
    set {_uniqueStorage()._transferrable = newValue}
  }

  public var ttl: UInt32 {
    get {return _storage._ttl}
    set {_uniqueStorage()._ttl = newValue}
  }

  /// once it is consumed, it is untransferrable
  public var consumedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._consumedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._consumedTime = newValue}
  }
  /// Returns true if `consumedTime` has been explicitly set.
  public var hasConsumedTime: Bool {return _storage._consumedTime != nil}
  /// Clears the value of `consumedTime`. Subsequent reads from it will return its default value.
  public mutating func clearConsumedTime() {_uniqueStorage()._consumedTime = nil}

  /// who issued the asset
  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  /// parent address for the asset state, e.g. a ticket is inherited from an
  /// event
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  public var stake: Ocap_StakeContext {
    get {return _storage._stake ?? Ocap_StakeContext()}
    set {_uniqueStorage()._stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  public var hasStake: Bool {return _storage._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  public mutating func clearStake() {_uniqueStorage()._stake = nil}

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_CoreProtocol {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// consensus parameters, in future we shall be able to modify it
  public var consensus: Ocap_ConsensusParams {
    get {return _storage._consensus ?? Ocap_ConsensusParams()}
    set {_uniqueStorage()._consensus = newValue}
  }
  /// Returns true if `consensus` has been explicitly set.
  public var hasConsensus: Bool {return _storage._consensus != nil}
  /// Clears the value of `consensus`. Subsequent reads from it will return its default value.
  public mutating func clearConsensus() {_uniqueStorage()._consensus = nil}

  public var tasks: Dictionary<UInt64,Ocap_UpgradeTasks> {
    get {return _storage._tasks}
    set {_uniqueStorage()._tasks = newValue}
  }

  public var stakeSummary: Dictionary<UInt32,Ocap_StakeSummary> {
    get {return _storage._stakeSummary}
    set {_uniqueStorage()._stakeSummary = newValue}
  }

  /// string data_version = 6; current data version deprecated
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var token: Ocap_ForgeToken {
    get {return _storage._token ?? Ocap_ForgeToken()}
    set {_uniqueStorage()._token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return _storage._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {_uniqueStorage()._token = nil}

  public var txConfig: Ocap_TransactionConfig {
    get {return _storage._txConfig ?? Ocap_TransactionConfig()}
    set {_uniqueStorage()._txConfig = newValue}
  }
  /// Returns true if `txConfig` has been explicitly set.
  public var hasTxConfig: Bool {return _storage._txConfig != nil}
  /// Clears the value of `txConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTxConfig() {_uniqueStorage()._txConfig = nil}

  /// StakeConfig stake_config = 10; deprecated
  /// PokeConfig poke_config = 11; deprecated
  public var protocols: [Ocap_CoreProtocol] {
    get {return _storage._protocols}
    set {_uniqueStorage()._protocols = newValue}
  }

  public var gas: Dictionary<String,UInt32> {
    get {return _storage._gas}
    set {_uniqueStorage()._gas = newValue}
  }

  public var upgradeInfo: Ocap_UpgradeInfo {
    get {return _storage._upgradeInfo ?? Ocap_UpgradeInfo()}
    set {_uniqueStorage()._upgradeInfo = newValue}
  }
  /// Returns true if `upgradeInfo` has been explicitly set.
  public var hasUpgradeInfo: Bool {return _storage._upgradeInfo != nil}
  /// Clears the value of `upgradeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUpgradeInfo() {_uniqueStorage()._upgradeInfo = nil}

  public var accountConfig: Dictionary<String,Ocap_AccountConfig> {
    get {return _storage._accountConfig}
    set {_uniqueStorage()._accountConfig = newValue}
  }

  public var tokenSwapConfig: Ocap_TokenSwapConfig {
    get {return _storage._tokenSwapConfig ?? Ocap_TokenSwapConfig()}
    set {_uniqueStorage()._tokenSwapConfig = newValue}
  }
  /// Returns true if `tokenSwapConfig` has been explicitly set.
  public var hasTokenSwapConfig: Bool {return _storage._tokenSwapConfig != nil}
  /// Clears the value of `tokenSwapConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTokenSwapConfig() {_uniqueStorage()._tokenSwapConfig = nil}

  /// app can define their own app state
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// keep a list of state root for different dbs (column families).
/// RootState will be stored in the default column family, and we return the
/// root hash for default column family, thus our app_state would contain all
/// hashes from different column families.
public struct Ocap_RootState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var account: Data = SwiftProtobuf.Internal.emptyData

  public var asset: Data = SwiftProtobuf.Internal.emptyData

  public var receipt: Data = SwiftProtobuf.Internal.emptyData

  public var `protocol`: Data = SwiftProtobuf.Internal.emptyData

  public var governance: Data = SwiftProtobuf.Internal.emptyData

  public var custom: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_StakeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var from: String {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// state context, replace exiting fields
  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  /// app can extend this
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_StatisticsState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var numBlocks: UInt64 {
    get {return _storage._numBlocks}
    set {_uniqueStorage()._numBlocks = newValue}
  }

  public var numTxs: UInt64 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var numStakes: Ocap_BigUint {
    get {return _storage._numStakes ?? Ocap_BigUint()}
    set {_uniqueStorage()._numStakes = newValue}
  }
  /// Returns true if `numStakes` has been explicitly set.
  public var hasNumStakes: Bool {return _storage._numStakes != nil}
  /// Clears the value of `numStakes`. Subsequent reads from it will return its default value.
  public mutating func clearNumStakes() {_uniqueStorage()._numStakes = nil}

  public var numValidators: UInt32 {
    get {return _storage._numValidators}
    set {_uniqueStorage()._numValidators = newValue}
  }

  public var txStatistics: Ocap_TxStatistics {
    get {return _storage._txStatistics ?? Ocap_TxStatistics()}
    set {_uniqueStorage()._txStatistics = newValue}
  }
  /// Returns true if `txStatistics` has been explicitly set.
  public var hasTxStatistics: Bool {return _storage._txStatistics != nil}
  /// Clears the value of `txStatistics`. Subsequent reads from it will return its default value.
  public mutating func clearTxStatistics() {_uniqueStorage()._txStatistics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_BlacklistState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: [peiling] We have already defined this state in core protocols repo.
/// The only reason we define this state here again is because the protobuf
/// definition ResponseGetSwapState needs to reference to this SwapState.
public struct Ocap_SwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var hashkey: Data {
    get {return _storage._hashkey}
    set {_uniqueStorage()._hashkey = newValue}
  }

  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  public var value: Ocap_BigUint {
    get {return _storage._value ?? Ocap_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  public var locktime: UInt32 {
    get {return _storage._locktime}
    set {_uniqueStorage()._locktime = newValue}
  }

  public var hashlock: Data {
    get {return _storage._hashlock}
    set {_uniqueStorage()._hashlock = newValue}
  }

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TODO: [peiling] We have already defined this state in core protocols repo.
/// The only reason we define this state here again is because the protobuf
/// definition ResponseGetSwapStatistics needs to reference to this.
public struct Ocap_SwapStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var lockedValueOut: Ocap_BigUint {
    get {return _storage._lockedValueOut ?? Ocap_BigUint()}
    set {_uniqueStorage()._lockedValueOut = newValue}
  }
  /// Returns true if `lockedValueOut` has been explicitly set.
  public var hasLockedValueOut: Bool {return _storage._lockedValueOut != nil}
  /// Clears the value of `lockedValueOut`. Subsequent reads from it will return its default value.
  public mutating func clearLockedValueOut() {_uniqueStorage()._lockedValueOut = nil}

  public var lockedValueIn: Ocap_BigUint {
    get {return _storage._lockedValueIn ?? Ocap_BigUint()}
    set {_uniqueStorage()._lockedValueIn = newValue}
  }
  /// Returns true if `lockedValueIn` has been explicitly set.
  public var hasLockedValueIn: Bool {return _storage._lockedValueIn != nil}
  /// Clears the value of `lockedValueIn`. Subsequent reads from it will return its default value.
  public mutating func clearLockedValueIn() {_uniqueStorage()._lockedValueIn = nil}

  public var lockedAssetsOut: UInt32 {
    get {return _storage._lockedAssetsOut}
    set {_uniqueStorage()._lockedAssetsOut = newValue}
  }

  public var lockedAssetsIn: UInt32 {
    get {return _storage._lockedAssetsIn}
    set {_uniqueStorage()._lockedAssetsIn = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// a rule can check against the statistics values, e.g. state.num_txs < 10000,
/// state.balance_delta < 50000, delta is calculated based on the
/// configuration for interval.
public struct Ocap_DelegateOpState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// all the individual rules in DelegateTx will be concat into one per type_url
  /// by "AND"
  public var rule: String {
    get {return _storage._rule}
    set {_uniqueStorage()._rule = newValue}
  }

  public var numTxs: UInt64 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var numTxsDelta: UInt64 {
    get {return _storage._numTxsDelta}
    set {_uniqueStorage()._numTxsDelta = newValue}
  }

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var balanceDelta: Ocap_BigUint {
    get {return _storage._balanceDelta ?? Ocap_BigUint()}
    set {_uniqueStorage()._balanceDelta = newValue}
  }
  /// Returns true if `balanceDelta` has been explicitly set.
  public var hasBalanceDelta: Bool {return _storage._balanceDelta != nil}
  /// Clears the value of `balanceDelta`. Subsequent reads from it will return its default value.
  public mutating func clearBalanceDelta() {_uniqueStorage()._balanceDelta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_DelegateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var ops: Dictionary<String,Ocap_DelegateOpState> {
    get {return _storage._ops}
    set {_uniqueStorage()._ops = newValue}
  }

  /// state context, replace exiting fields
  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  /// app can extend this
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_TokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  public var unit: String {
    get {return _storage._unit}
    set {_uniqueStorage()._unit = newValue}
  }

  public var icon: String {
    get {return _storage._icon}
    set {_uniqueStorage()._icon = newValue}
  }

  public var totalSupply: String {
    get {return _storage._totalSupply}
    set {_uniqueStorage()._totalSupply = newValue}
  }

  public var faucetSupply: String {
    get {return _storage._faucetSupply}
    set {_uniqueStorage()._faucetSupply = newValue}
  }

  public var erc20ContractAddress: String {
    get {return _storage._erc20ContractAddress}
    set {_uniqueStorage()._erc20ContractAddress = newValue}
  }

  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Very similar to AssetFactory, appended some state vars
public struct Ocap_AssetFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// immutable
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  /// mutable
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// immutable
  public var settlement: String {
    get {return _storage._settlement}
    set {_uniqueStorage()._settlement = newValue}
  }

  public var limit: UInt32 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  /// mutable
  public var trustedIssuers: [String] {
    get {return _storage._trustedIssuers}
    set {_uniqueStorage()._trustedIssuers = newValue}
  }

  /// immutable
  public var input: Ocap_AssetFactoryInput {
    get {return _storage._input ?? Ocap_AssetFactoryInput()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  public var output: Ocap_CreateAssetTx {
    get {return _storage._output ?? Ocap_CreateAssetTx()}
    set {_uniqueStorage()._output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return _storage._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {_uniqueStorage()._output = nil}

  public var hooks: [Ocap_AssetFactoryHook] {
    get {return _storage._hooks}
    set {_uniqueStorage()._hooks = newValue}
  }

  /// mutable
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  /// mutable
  public var context: Ocap_StateContext {
    get {return _storage._context ?? Ocap_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var tokens: Dictionary<String,Ocap_BigUint> {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var numMinted: UInt32 {
    get {return _storage._numMinted}
    set {_uniqueStorage()._numMinted = newValue}
  }

  /// mutable
  public var lastSettlement: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastSettlement ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastSettlement = newValue}
  }
  /// Returns true if `lastSettlement` has been explicitly set.
  public var hasLastSettlement: Bool {return _storage._lastSettlement != nil}
  /// Clears the value of `lastSettlement`. Subsequent reads from it will return its default value.
  public mutating func clearLastSettlement() {_uniqueStorage()._lastSettlement = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_AccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "num_txs"),
    4: .same(proto: "address"),
    5: .same(proto: "pk"),
    6: .same(proto: "type"),
    7: .same(proto: "moniker"),
    8: .same(proto: "context"),
    9: .same(proto: "issuer"),
    10: .standard(proto: "gas_balance"),
    13: .standard(proto: "migrated_to"),
    14: .standard(proto: "migrated_from"),
    15: .standard(proto: "num_assets"),
    16: .same(proto: "stake"),
    17: .standard(proto: "pinned_files"),
    18: .same(proto: "poke"),
    19: .standard(proto: "deposit_received"),
    20: .standard(proto: "withdraw_items"),
    21: .same(proto: "tokens"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _balance: Ocap_BigUint? = nil
    var _nonce: String = String()
    var _numTxs: String = String()
    var _address: String = String()
    var _pk: Data = SwiftProtobuf.Internal.emptyData
    var _type: Ocap_WalletType? = nil
    var _moniker: String = String()
    var _context: Ocap_StateContext? = nil
    var _issuer: String = String()
    var _gasBalance: Ocap_BigUint? = nil
    var _migratedTo: [String] = []
    var _migratedFrom: [String] = []
    var _numAssets: String = String()
    var _stake: Ocap_StakeContext? = nil
    var _pinnedFiles: Ocap_CircularQueue? = nil
    var _poke: Ocap_PokeInfo? = nil
    var _depositReceived: Ocap_BigUint? = nil
    var _withdrawItems: Ocap_CircularQueue? = nil
    var _tokens: Dictionary<String,String> = [:]
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _balance = source._balance
      _nonce = source._nonce
      _numTxs = source._numTxs
      _address = source._address
      _pk = source._pk
      _type = source._type
      _moniker = source._moniker
      _context = source._context
      _issuer = source._issuer
      _gasBalance = source._gasBalance
      _migratedTo = source._migratedTo
      _migratedFrom = source._migratedFrom
      _numAssets = source._numAssets
      _stake = source._stake
      _pinnedFiles = source._pinnedFiles
      _poke = source._poke
      _depositReceived = source._depositReceived
      _withdrawItems = source._withdrawItems
      _tokens = source._tokens
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 2: try decoder.decodeSingularStringField(value: &_storage._nonce)
        case 3: try decoder.decodeSingularStringField(value: &_storage._numTxs)
        case 4: try decoder.decodeSingularStringField(value: &_storage._address)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._pk)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 7: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 9: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._gasBalance)
        case 13: try decoder.decodeRepeatedStringField(value: &_storage._migratedTo)
        case 14: try decoder.decodeRepeatedStringField(value: &_storage._migratedFrom)
        case 15: try decoder.decodeSingularStringField(value: &_storage._numAssets)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._stake)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._pinnedFiles)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._poke)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._depositReceived)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._withdrawItems)
        case 21: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._tokens)
        case 50: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._nonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nonce, fieldNumber: 2)
      }
      if !_storage._numTxs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._numTxs, fieldNumber: 3)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 4)
      }
      if !_storage._pk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pk, fieldNumber: 5)
      }
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 7)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 9)
      }
      if let v = _storage._gasBalance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._migratedTo.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migratedTo, fieldNumber: 13)
      }
      if !_storage._migratedFrom.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migratedFrom, fieldNumber: 14)
      }
      if !_storage._numAssets.isEmpty {
        try visitor.visitSingularStringField(value: _storage._numAssets, fieldNumber: 15)
      }
      if let v = _storage._stake {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._pinnedFiles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._poke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._depositReceived {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._withdrawItems {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._tokens, fieldNumber: 21)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AccountState, rhs: Ocap_AccountState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._gasBalance != rhs_storage._gasBalance {return false}
        if _storage._migratedTo != rhs_storage._migratedTo {return false}
        if _storage._migratedFrom != rhs_storage._migratedFrom {return false}
        if _storage._numAssets != rhs_storage._numAssets {return false}
        if _storage._stake != rhs_storage._stake {return false}
        if _storage._pinnedFiles != rhs_storage._pinnedFiles {return false}
        if _storage._poke != rhs_storage._poke {return false}
        if _storage._depositReceived != rhs_storage._depositReceived {return false}
        if _storage._withdrawItems != rhs_storage._withdrawItems {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .same(proto: "moniker"),
    4: .same(proto: "readonly"),
    5: .same(proto: "transferrable"),
    6: .same(proto: "ttl"),
    7: .standard(proto: "consumed_time"),
    8: .same(proto: "issuer"),
    9: .same(proto: "parent"),
    13: .same(proto: "stake"),
    14: .same(proto: "context"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _moniker: String = String()
    var _readonly: Bool = false
    var _transferrable: Bool = false
    var _ttl: UInt32 = 0
    var _consumedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _issuer: String = String()
    var _parent: String = String()
    var _stake: Ocap_StakeContext? = nil
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _moniker = source._moniker
      _readonly = source._readonly
      _transferrable = source._transferrable
      _ttl = source._ttl
      _consumedTime = source._consumedTime
      _issuer = source._issuer
      _parent = source._parent
      _stake = source._stake
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._owner)
        case 3: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._readonly)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._transferrable)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._ttl)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._consumedTime)
        case 8: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 9: try decoder.decodeSingularStringField(value: &_storage._parent)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._stake)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 50: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 3)
      }
      if _storage._readonly != false {
        try visitor.visitSingularBoolField(value: _storage._readonly, fieldNumber: 4)
      }
      if _storage._transferrable != false {
        try visitor.visitSingularBoolField(value: _storage._transferrable, fieldNumber: 5)
      }
      if _storage._ttl != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ttl, fieldNumber: 6)
      }
      if let v = _storage._consumedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 8)
      }
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 9)
      }
      if let v = _storage._stake {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetState, rhs: Ocap_AssetState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._readonly != rhs_storage._readonly {return false}
        if _storage._transferrable != rhs_storage._transferrable {return false}
        if _storage._ttl != rhs_storage._ttl {return false}
        if _storage._consumedTime != rhs_storage._consumedTime {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._stake != rhs_storage._stake {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_CoreProtocol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoreProtocol"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_CoreProtocol, rhs: Ocap_CoreProtocol) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "consensus"),
    3: .same(proto: "tasks"),
    4: .standard(proto: "stake_summary"),
    5: .same(proto: "version"),
    8: .same(proto: "token"),
    9: .standard(proto: "tx_config"),
    12: .same(proto: "protocols"),
    13: .same(proto: "gas"),
    14: .standard(proto: "upgrade_info"),
    16: .standard(proto: "account_config"),
    17: .standard(proto: "token_swap_config"),
    2047: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _consensus: Ocap_ConsensusParams? = nil
    var _tasks: Dictionary<UInt64,Ocap_UpgradeTasks> = [:]
    var _stakeSummary: Dictionary<UInt32,Ocap_StakeSummary> = [:]
    var _version: String = String()
    var _token: Ocap_ForgeToken? = nil
    var _txConfig: Ocap_TransactionConfig? = nil
    var _protocols: [Ocap_CoreProtocol] = []
    var _gas: Dictionary<String,UInt32> = [:]
    var _upgradeInfo: Ocap_UpgradeInfo? = nil
    var _accountConfig: Dictionary<String,Ocap_AccountConfig> = [:]
    var _tokenSwapConfig: Ocap_TokenSwapConfig? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _consensus = source._consensus
      _tasks = source._tasks
      _stakeSummary = source._stakeSummary
      _version = source._version
      _token = source._token
      _txConfig = source._txConfig
      _protocols = source._protocols
      _gas = source._gas
      _upgradeInfo = source._upgradeInfo
      _accountConfig = source._accountConfig
      _tokenSwapConfig = source._tokenSwapConfig
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._consensus)
        case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt64,Ocap_UpgradeTasks>.self, value: &_storage._tasks)
        case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Ocap_StakeSummary>.self, value: &_storage._stakeSummary)
        case 5: try decoder.decodeSingularStringField(value: &_storage._version)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._token)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._txConfig)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._protocols)
        case 13: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &_storage._gas)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._upgradeInfo)
        case 16: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_AccountConfig>.self, value: &_storage._accountConfig)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._tokenSwapConfig)
        case 2047: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._consensus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._tasks.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt64,Ocap_UpgradeTasks>.self, value: _storage._tasks, fieldNumber: 3)
      }
      if !_storage._stakeSummary.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Ocap_StakeSummary>.self, value: _storage._stakeSummary, fieldNumber: 4)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 5)
      }
      if let v = _storage._token {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._txConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._protocols.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._protocols, fieldNumber: 12)
      }
      if !_storage._gas.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: _storage._gas, fieldNumber: 13)
      }
      if let v = _storage._upgradeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if !_storage._accountConfig.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_AccountConfig>.self, value: _storage._accountConfig, fieldNumber: 16)
      }
      if let v = _storage._tokenSwapConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2047)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ForgeState, rhs: Ocap_ForgeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._consensus != rhs_storage._consensus {return false}
        if _storage._tasks != rhs_storage._tasks {return false}
        if _storage._stakeSummary != rhs_storage._stakeSummary {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._txConfig != rhs_storage._txConfig {return false}
        if _storage._protocols != rhs_storage._protocols {return false}
        if _storage._gas != rhs_storage._gas {return false}
        if _storage._upgradeInfo != rhs_storage._upgradeInfo {return false}
        if _storage._accountConfig != rhs_storage._accountConfig {return false}
        if _storage._tokenSwapConfig != rhs_storage._tokenSwapConfig {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RootState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RootState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "account"),
    3: .same(proto: "asset"),
    4: .same(proto: "receipt"),
    5: .same(proto: "protocol"),
    6: .same(proto: "governance"),
    7: .same(proto: "custom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularBytesField(value: &self.account)
      case 3: try decoder.decodeSingularBytesField(value: &self.asset)
      case 4: try decoder.decodeSingularBytesField(value: &self.receipt)
      case 5: try decoder.decodeSingularBytesField(value: &self.`protocol`)
      case 6: try decoder.decodeSingularBytesField(value: &self.governance)
      case 7: try decoder.decodeSingularBytesField(value: &self.custom)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularBytesField(value: self.account, fieldNumber: 2)
    }
    if !self.asset.isEmpty {
      try visitor.visitSingularBytesField(value: self.asset, fieldNumber: 3)
    }
    if !self.receipt.isEmpty {
      try visitor.visitSingularBytesField(value: self.receipt, fieldNumber: 4)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularBytesField(value: self.`protocol`, fieldNumber: 5)
    }
    if !self.governance.isEmpty {
      try visitor.visitSingularBytesField(value: self.governance, fieldNumber: 6)
    }
    if !self.custom.isEmpty {
      try visitor.visitSingularBytesField(value: self.custom, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RootState, rhs: Ocap_RootState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.account != rhs.account {return false}
    if lhs.asset != rhs.asset {return false}
    if lhs.receipt != rhs.receipt {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.governance != rhs.governance {return false}
    if lhs.custom != rhs.custom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_StakeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "balance"),
    5: .same(proto: "message"),
    14: .same(proto: "context"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _from: String = String()
    var _to: String = String()
    var _balance: Ocap_BigUint? = nil
    var _message: String = String()
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _from = source._from
      _to = source._to
      _balance = source._balance
      _message = source._message
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._from)
        case 3: try decoder.decodeSingularStringField(value: &_storage._to)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 5: try decoder.decodeSingularStringField(value: &_storage._message)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._from.isEmpty {
        try visitor.visitSingularStringField(value: _storage._from, fieldNumber: 2)
      }
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 3)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 5)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_StakeState, rhs: Ocap_StakeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_StatisticsState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatisticsState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "num_txs"),
    4: .standard(proto: "num_stakes"),
    5: .standard(proto: "num_validators"),
    6: .standard(proto: "tx_statistics"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _numBlocks: UInt64 = 0
    var _numTxs: UInt64 = 0
    var _numStakes: Ocap_BigUint? = nil
    var _numValidators: UInt32 = 0
    var _txStatistics: Ocap_TxStatistics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _numBlocks = source._numBlocks
      _numTxs = source._numTxs
      _numStakes = source._numStakes
      _numValidators = source._numValidators
      _txStatistics = source._txStatistics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._numBlocks)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._numTxs)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._numStakes)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._numValidators)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._txStatistics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if _storage._numBlocks != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numBlocks, fieldNumber: 2)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numTxs, fieldNumber: 3)
      }
      if let v = _storage._numStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._numValidators != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numValidators, fieldNumber: 5)
      }
      if let v = _storage._txStatistics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_StatisticsState, rhs: Ocap_StatisticsState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._numBlocks != rhs_storage._numBlocks {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._numStakes != rhs_storage._numStakes {return false}
        if _storage._numValidators != rhs_storage._numValidators {return false}
        if _storage._txStatistics != rhs_storage._txStatistics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_BlacklistState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlacklistState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitRepeatedStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_BlacklistState, rhs: Ocap_BlacklistState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_SwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "address"),
    3: .same(proto: "hashkey"),
    4: .same(proto: "sender"),
    5: .same(proto: "receiver"),
    6: .same(proto: "value"),
    7: .same(proto: "assets"),
    8: .same(proto: "locktime"),
    9: .same(proto: "hashlock"),
    10: .same(proto: "context"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _address: String = String()
    var _hashkey: Data = SwiftProtobuf.Internal.emptyData
    var _sender: String = String()
    var _receiver: String = String()
    var _value: Ocap_BigUint? = nil
    var _assets: [String] = []
    var _locktime: UInt32 = 0
    var _hashlock: Data = SwiftProtobuf.Internal.emptyData
    var _context: Ocap_StateContext? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _address = source._address
      _hashkey = source._hashkey
      _sender = source._sender
      _receiver = source._receiver
      _value = source._value
      _assets = source._assets
      _locktime = source._locktime
      _hashlock = source._hashlock
      _context = source._context
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._hash)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._hashkey)
        case 4: try decoder.decodeSingularStringField(value: &_storage._sender)
        case 5: try decoder.decodeSingularStringField(value: &_storage._receiver)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._locktime)
        case 9: try decoder.decodeSingularBytesField(value: &_storage._hashlock)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._context)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._hashkey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hashkey, fieldNumber: 3)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 4)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 5)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 7)
      }
      if _storage._locktime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._locktime, fieldNumber: 8)
      }
      if !_storage._hashlock.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hashlock, fieldNumber: 9)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_SwapState, rhs: Ocap_SwapState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._hashkey != rhs_storage._hashkey {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._locktime != rhs_storage._locktime {return false}
        if _storage._hashlock != rhs_storage._hashlock {return false}
        if _storage._context != rhs_storage._context {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_SwapStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "locked_value_out"),
    3: .standard(proto: "locked_value_in"),
    4: .standard(proto: "locked_assets_out"),
    5: .standard(proto: "locked_assets_in"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _lockedValueOut: Ocap_BigUint? = nil
    var _lockedValueIn: Ocap_BigUint? = nil
    var _lockedAssetsOut: UInt32 = 0
    var _lockedAssetsIn: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _lockedValueOut = source._lockedValueOut
      _lockedValueIn = source._lockedValueIn
      _lockedAssetsOut = source._lockedAssetsOut
      _lockedAssetsIn = source._lockedAssetsIn
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._lockedValueOut)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lockedValueIn)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._lockedAssetsOut)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._lockedAssetsIn)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._lockedValueOut {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lockedValueIn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._lockedAssetsOut != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lockedAssetsOut, fieldNumber: 4)
      }
      if _storage._lockedAssetsIn != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lockedAssetsIn, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_SwapStatistics, rhs: Ocap_SwapStatistics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._lockedValueOut != rhs_storage._lockedValueOut {return false}
        if _storage._lockedValueIn != rhs_storage._lockedValueIn {return false}
        if _storage._lockedAssetsOut != rhs_storage._lockedAssetsOut {return false}
        if _storage._lockedAssetsIn != rhs_storage._lockedAssetsIn {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegateOpState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateOpState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .standard(proto: "num_txs"),
    3: .standard(proto: "num_txs_delta"),
    4: .same(proto: "balance"),
    5: .standard(proto: "balance_delta"),
  ]

  fileprivate class _StorageClass {
    var _rule: String = String()
    var _numTxs: UInt64 = 0
    var _numTxsDelta: UInt64 = 0
    var _balance: Ocap_BigUint? = nil
    var _balanceDelta: Ocap_BigUint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rule = source._rule
      _numTxs = source._numTxs
      _numTxsDelta = source._numTxsDelta
      _balance = source._balance
      _balanceDelta = source._balanceDelta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._rule)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._numTxs)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._numTxsDelta)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._balanceDelta)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._rule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rule, fieldNumber: 1)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numTxs, fieldNumber: 2)
      }
      if _storage._numTxsDelta != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numTxsDelta, fieldNumber: 3)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._balanceDelta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegateOpState, rhs: Ocap_DelegateOpState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rule != rhs_storage._rule {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._numTxsDelta != rhs_storage._numTxsDelta {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._balanceDelta != rhs_storage._balanceDelta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "ops"),
    14: .same(proto: "context"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _ops: Dictionary<String,Ocap_DelegateOpState> = [:]
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _ops = source._ops
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_DelegateOpState>.self, value: &_storage._ops)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._ops.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_DelegateOpState>.self, value: _storage._ops, fieldNumber: 2)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegateState, rhs: Ocap_DelegateState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._ops != rhs_storage._ops {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "issuer"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "symbol"),
    6: .same(proto: "unit"),
    7: .same(proto: "icon"),
    8: .standard(proto: "total_supply"),
    9: .standard(proto: "faucet_supply"),
    10: .standard(proto: "erc20_contract_address"),
    15: .same(proto: "context"),
    20: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _issuer: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _symbol: String = String()
    var _unit: String = String()
    var _icon: String = String()
    var _totalSupply: String = String()
    var _faucetSupply: String = String()
    var _erc20ContractAddress: String = String()
    var _context: Ocap_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _issuer = source._issuer
      _name = source._name
      _description_p = source._description_p
      _symbol = source._symbol
      _unit = source._unit
      _icon = source._icon
      _totalSupply = source._totalSupply
      _faucetSupply = source._faucetSupply
      _erc20ContractAddress = source._erc20ContractAddress
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularStringField(value: &_storage._symbol)
        case 6: try decoder.decodeSingularStringField(value: &_storage._unit)
        case 7: try decoder.decodeSingularStringField(value: &_storage._icon)
        case 8: try decoder.decodeSingularStringField(value: &_storage._totalSupply)
        case 9: try decoder.decodeSingularStringField(value: &_storage._faucetSupply)
        case 10: try decoder.decodeSingularStringField(value: &_storage._erc20ContractAddress)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 5)
      }
      if !_storage._unit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unit, fieldNumber: 6)
      }
      if !_storage._icon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._icon, fieldNumber: 7)
      }
      if !_storage._totalSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalSupply, fieldNumber: 8)
      }
      if !_storage._faucetSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._faucetSupply, fieldNumber: 9)
      }
      if !_storage._erc20ContractAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._erc20ContractAddress, fieldNumber: 10)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenState, rhs: Ocap_TokenState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        if _storage._unit != rhs_storage._unit {return false}
        if _storage._icon != rhs_storage._icon {return false}
        if _storage._totalSupply != rhs_storage._totalSupply {return false}
        if _storage._faucetSupply != rhs_storage._faucetSupply {return false}
        if _storage._erc20ContractAddress != rhs_storage._erc20ContractAddress {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "settlement"),
    6: .same(proto: "limit"),
    7: .standard(proto: "trusted_issuers"),
    8: .same(proto: "input"),
    9: .same(proto: "output"),
    10: .same(proto: "hooks"),
    11: .same(proto: "data"),
    12: .same(proto: "context"),
    13: .same(proto: "balance"),
    14: .same(proto: "tokens"),
    15: .standard(proto: "num_minted"),
    16: .standard(proto: "last_settlement"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _settlement: String = String()
    var _limit: UInt32 = 0
    var _trustedIssuers: [String] = []
    var _input: Ocap_AssetFactoryInput? = nil
    var _output: Ocap_CreateAssetTx? = nil
    var _hooks: [Ocap_AssetFactoryHook] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _context: Ocap_StateContext? = nil
    var _balance: Ocap_BigUint? = nil
    var _tokens: Dictionary<String,Ocap_BigUint> = [:]
    var _numMinted: UInt32 = 0
    var _lastSettlement: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _name = source._name
      _description_p = source._description_p
      _settlement = source._settlement
      _limit = source._limit
      _trustedIssuers = source._trustedIssuers
      _input = source._input
      _output = source._output
      _hooks = source._hooks
      _data = source._data
      _context = source._context
      _balance = source._balance
      _tokens = source._tokens
      _numMinted = source._numMinted
      _lastSettlement = source._lastSettlement
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._owner)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularStringField(value: &_storage._settlement)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._limit)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._trustedIssuers)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._input)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._output)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._hooks)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._data)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 14: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_BigUint>.self, value: &_storage._tokens)
        case 15: try decoder.decodeSingularUInt32Field(value: &_storage._numMinted)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._lastSettlement)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if !_storage._settlement.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlement, fieldNumber: 5)
      }
      if _storage._limit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._limit, fieldNumber: 6)
      }
      if !_storage._trustedIssuers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._trustedIssuers, fieldNumber: 7)
      }
      if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._output {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._hooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hooks, fieldNumber: 10)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ocap_BigUint>.self, value: _storage._tokens, fieldNumber: 14)
      }
      if _storage._numMinted != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numMinted, fieldNumber: 15)
      }
      if let v = _storage._lastSettlement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFactoryState, rhs: Ocap_AssetFactoryState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._settlement != rhs_storage._settlement {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._trustedIssuers != rhs_storage._trustedIssuers {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._hooks != rhs_storage._hooks {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._numMinted != rhs_storage._numMinted {return false}
        if _storage._lastSettlement != rhs_storage._lastSettlement {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
