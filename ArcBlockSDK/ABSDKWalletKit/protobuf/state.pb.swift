// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: state.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ForgeAbi_AccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var balance: ForgeAbi_BigUint {
    get {return _storage._balance ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var nonce: UInt64 {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var numTxs: UInt64 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var pk: Data {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  public var type: ForgeAbi_WalletType {
    get {return _storage._type ?? ForgeAbi_WalletType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var context: ForgeAbi_StateContext {
    get {return _storage._context ?? ForgeAbi_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var gasBalance: ForgeAbi_BigUint {
    get {return _storage._gasBalance ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._gasBalance = newValue}
  }
  /// Returns true if `gasBalance` has been explicitly set.
  public var hasGasBalance: Bool {return _storage._gasBalance != nil}
  /// Clears the value of `gasBalance`. Subsequent reads from it will return its default value.
  public mutating func clearGasBalance() {_uniqueStorage()._gasBalance = nil}

  /// the address that is being migrated. Once this is set this account state is
  /// read only. No further tx can alter this account state. And tx with "from"
  /// equal to the old address will be rejected by Forge
  public var migratedTo: [String] {
    get {return _storage._migratedTo}
    set {_uniqueStorage()._migratedTo = newValue}
  }

  public var migratedFrom: [String] {
    get {return _storage._migratedFrom}
    set {_uniqueStorage()._migratedFrom = newValue}
  }

  public var numAssets: UInt64 {
    get {return _storage._numAssets}
    set {_uniqueStorage()._numAssets = newValue}
  }

  public var stake: ForgeAbi_StakeContext {
    get {return _storage._stake ?? ForgeAbi_StakeContext()}
    set {_uniqueStorage()._stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  public var hasStake: Bool {return _storage._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  public mutating func clearStake() {_uniqueStorage()._stake = nil}

  public var pinnedFiles: ForgeAbi_CircularQueue {
    get {return _storage._pinnedFiles ?? ForgeAbi_CircularQueue()}
    set {_uniqueStorage()._pinnedFiles = newValue}
  }
  /// Returns true if `pinnedFiles` has been explicitly set.
  public var hasPinnedFiles: Bool {return _storage._pinnedFiles != nil}
  /// Clears the value of `pinnedFiles`. Subsequent reads from it will return its default value.
  public mutating func clearPinnedFiles() {_uniqueStorage()._pinnedFiles = nil}

  public var poke: ForgeAbi_PokeInfo {
    get {return _storage._poke ?? ForgeAbi_PokeInfo()}
    set {_uniqueStorage()._poke = newValue}
  }
  /// Returns true if `poke` has been explicitly set.
  public var hasPoke: Bool {return _storage._poke != nil}
  /// Clears the value of `poke`. Subsequent reads from it will return its default value.
  public mutating func clearPoke() {_uniqueStorage()._poke = nil}

  /// The current deposit this account has received. It cannot exceed the deposit
  /// cap.
  public var depositReceived: ForgeAbi_BigUint {
    get {return _storage._depositReceived ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._depositReceived = newValue}
  }
  /// Returns true if `depositReceived` has been explicitly set.
  public var hasDepositReceived: Bool {return _storage._depositReceived != nil}
  /// Clears the value of `depositReceived`. Subsequent reads from it will return its default value.
  public mutating func clearDepositReceived() {_uniqueStorage()._depositReceived = nil}

  /// 20-49 reserve for future
  public var withdrawItems: ForgeAbi_CircularQueue {
    get {return _storage._withdrawItems ?? ForgeAbi_CircularQueue()}
    set {_uniqueStorage()._withdrawItems = newValue}
  }
  /// Returns true if `withdrawItems` has been explicitly set.
  public var hasWithdrawItems: Bool {return _storage._withdrawItems != nil}
  /// Clears the value of `withdrawItems`. Subsequent reads from it will return its default value.
  public mutating func clearWithdrawItems() {_uniqueStorage()._withdrawItems = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_AssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var readonly: Bool {
    get {return _storage._readonly}
    set {_uniqueStorage()._readonly = newValue}
  }

  public var transferrable: Bool {
    get {return _storage._transferrable}
    set {_uniqueStorage()._transferrable = newValue}
  }

  public var ttl: UInt32 {
    get {return _storage._ttl}
    set {_uniqueStorage()._ttl = newValue}
  }

  /// once it is consumed, it is untransferrable
  public var consumedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._consumedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._consumedTime = newValue}
  }
  /// Returns true if `consumedTime` has been explicitly set.
  public var hasConsumedTime: Bool {return _storage._consumedTime != nil}
  /// Clears the value of `consumedTime`. Subsequent reads from it will return its default value.
  public mutating func clearConsumedTime() {_uniqueStorage()._consumedTime = nil}

  /// who issued the asset
  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  /// parent address for the asset state, e.g. a ticket is inherited from an
  /// event
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  public var stake: ForgeAbi_StakeContext {
    get {return _storage._stake ?? ForgeAbi_StakeContext()}
    set {_uniqueStorage()._stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  public var hasStake: Bool {return _storage._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  public mutating func clearStake() {_uniqueStorage()._stake = nil}

  public var context: ForgeAbi_StateContext {
    get {return _storage._context ?? ForgeAbi_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_CoreProtocol {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ForgeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// consensus parameters, in future we shall be able to modify it
  public var consensus: ForgeAbi_ConsensusParams {
    get {return _storage._consensus ?? ForgeAbi_ConsensusParams()}
    set {_uniqueStorage()._consensus = newValue}
  }
  /// Returns true if `consensus` has been explicitly set.
  public var hasConsensus: Bool {return _storage._consensus != nil}
  /// Clears the value of `consensus`. Subsequent reads from it will return its default value.
  public mutating func clearConsensus() {_uniqueStorage()._consensus = nil}

  public var tasks: Dictionary<UInt64,ForgeAbi_UpgradeTasks> {
    get {return _storage._tasks}
    set {_uniqueStorage()._tasks = newValue}
  }

  public var stakeSummary: Dictionary<UInt32,ForgeAbi_StakeSummary> {
    get {return _storage._stakeSummary}
    set {_uniqueStorage()._stakeSummary = newValue}
  }

  /// string data_version = 6; current data version deprecated
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var token: ForgeAbi_ForgeToken {
    get {return _storage._token ?? ForgeAbi_ForgeToken()}
    set {_uniqueStorage()._token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return _storage._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {_uniqueStorage()._token = nil}

  public var txConfig: ForgeAbi_TransactionConfig {
    get {return _storage._txConfig ?? ForgeAbi_TransactionConfig()}
    set {_uniqueStorage()._txConfig = newValue}
  }
  /// Returns true if `txConfig` has been explicitly set.
  public var hasTxConfig: Bool {return _storage._txConfig != nil}
  /// Clears the value of `txConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTxConfig() {_uniqueStorage()._txConfig = nil}

  /// StakeConfig stake_config = 10; deprecated
  /// PokeConfig poke_config = 11; deprecated
  public var protocols: [ForgeAbi_CoreProtocol] {
    get {return _storage._protocols}
    set {_uniqueStorage()._protocols = newValue}
  }

  public var gas: Dictionary<String,UInt32> {
    get {return _storage._gas}
    set {_uniqueStorage()._gas = newValue}
  }

  public var upgradeInfo: ForgeAbi_UpgradeInfo {
    get {return _storage._upgradeInfo ?? ForgeAbi_UpgradeInfo()}
    set {_uniqueStorage()._upgradeInfo = newValue}
  }
  /// Returns true if `upgradeInfo` has been explicitly set.
  public var hasUpgradeInfo: Bool {return _storage._upgradeInfo != nil}
  /// Clears the value of `upgradeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUpgradeInfo() {_uniqueStorage()._upgradeInfo = nil}

  public var accountConfig: Dictionary<String,ForgeAbi_AccountConfig> {
    get {return _storage._accountConfig}
    set {_uniqueStorage()._accountConfig = newValue}
  }

  public var tokenSwapConfig: ForgeAbi_TokenSwapConfig {
    get {return _storage._tokenSwapConfig ?? ForgeAbi_TokenSwapConfig()}
    set {_uniqueStorage()._tokenSwapConfig = newValue}
  }
  /// Returns true if `tokenSwapConfig` has been explicitly set.
  public var hasTokenSwapConfig: Bool {return _storage._tokenSwapConfig != nil}
  /// Clears the value of `tokenSwapConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTokenSwapConfig() {_uniqueStorage()._tokenSwapConfig = nil}

  /// forge app can define their own app state
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// keep a list of state root for different dbs (column families).
/// RootState will be stored in the default column family, and we return the
/// root hash for default column family, thus our app_state would contain all
/// hashes from different column families.
public struct ForgeAbi_RootState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var account: Data = SwiftProtobuf.Internal.emptyData

  public var asset: Data = SwiftProtobuf.Internal.emptyData

  public var receipt: Data = SwiftProtobuf.Internal.emptyData

  public var `protocol`: Data = SwiftProtobuf.Internal.emptyData

  public var governance: Data = SwiftProtobuf.Internal.emptyData

  public var custom: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_StakeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var from: String {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  public var balance: ForgeAbi_BigUint {
    get {return _storage._balance ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// state context, replace exiting fields
  public var context: ForgeAbi_StateContext {
    get {return _storage._context ?? ForgeAbi_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  /// forge app can extend this
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_StatisticsState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var numBlocks: UInt64 {
    get {return _storage._numBlocks}
    set {_uniqueStorage()._numBlocks = newValue}
  }

  public var numTxs: UInt64 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var numStakes: ForgeAbi_BigUint {
    get {return _storage._numStakes ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._numStakes = newValue}
  }
  /// Returns true if `numStakes` has been explicitly set.
  public var hasNumStakes: Bool {return _storage._numStakes != nil}
  /// Clears the value of `numStakes`. Subsequent reads from it will return its default value.
  public mutating func clearNumStakes() {_uniqueStorage()._numStakes = nil}

  public var numValidators: UInt32 {
    get {return _storage._numValidators}
    set {_uniqueStorage()._numValidators = newValue}
  }

  public var txStatistics: ForgeAbi_TxStatistics {
    get {return _storage._txStatistics ?? ForgeAbi_TxStatistics()}
    set {_uniqueStorage()._txStatistics = newValue}
  }
  /// Returns true if `txStatistics` has been explicitly set.
  public var hasTxStatistics: Bool {return _storage._txStatistics != nil}
  /// Clears the value of `txStatistics`. Subsequent reads from it will return its default value.
  public mutating func clearTxStatistics() {_uniqueStorage()._txStatistics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_BlacklistState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ProtocolState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var itx: ForgeAbi_DeployProtocolTx {
    get {return _storage._itx ?? ForgeAbi_DeployProtocolTx()}
    set {_uniqueStorage()._itx = newValue}
  }
  /// Returns true if `itx` has been explicitly set.
  public var hasItx: Bool {return _storage._itx != nil}
  /// Clears the value of `itx`. Subsequent reads from it will return its default value.
  public mutating func clearItx() {_uniqueStorage()._itx = nil}

  /// root hash of the MPT of this tx protocol
  public var rootHash: Data {
    get {return _storage._rootHash}
    set {_uniqueStorage()._rootHash = newValue}
  }

  public var status: ForgeAbi_ProtocolStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var migratedTo: [String] {
    get {return _storage._migratedTo}
    set {_uniqueStorage()._migratedTo = newValue}
  }

  public var migratedFrom: [String] {
    get {return _storage._migratedFrom}
    set {_uniqueStorage()._migratedFrom = newValue}
  }

  public var context: ForgeAbi_StateContext {
    get {return _storage._context ?? ForgeAbi_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  /// forge app can define their own app state
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This is just for displaying purpose.
public struct ForgeAbi_TetherState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var available: Bool {
    get {return _storage._available}
    set {_uniqueStorage()._available = newValue}
  }

  public var custodian: String {
    get {return _storage._custodian}
    set {_uniqueStorage()._custodian = newValue}
  }

  public var depositor: String {
    get {return _storage._depositor}
    set {_uniqueStorage()._depositor = newValue}
  }

  public var withdrawer: String {
    get {return _storage._withdrawer}
    set {_uniqueStorage()._withdrawer = newValue}
  }

  public var value: ForgeAbi_BigUint {
    get {return _storage._value ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var commission: ForgeAbi_BigUint {
    get {return _storage._commission ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._commission = newValue}
  }
  /// Returns true if `commission` has been explicitly set.
  public var hasCommission: Bool {return _storage._commission != nil}
  /// Clears the value of `commission`. Subsequent reads from it will return its default value.
  public mutating func clearCommission() {_uniqueStorage()._commission = nil}

  public var charge: ForgeAbi_BigUint {
    get {return _storage._charge ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._charge = newValue}
  }
  /// Returns true if `charge` has been explicitly set.
  public var hasCharge: Bool {return _storage._charge != nil}
  /// Clears the value of `charge`. Subsequent reads from it will return its default value.
  public mutating func clearCharge() {_uniqueStorage()._charge = nil}

  public var target: String {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  public var locktime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._locktime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._locktime = newValue}
  }
  /// Returns true if `locktime` has been explicitly set.
  public var hasLocktime: Bool {return _storage._locktime != nil}
  /// Clears the value of `locktime`. Subsequent reads from it will return its default value.
  public mutating func clearLocktime() {_uniqueStorage()._locktime = nil}

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This is the one stored in state DB.
public struct ForgeAbi_TetherInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var available: Bool = false

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TODO: [peiling] We have already defined this state in core protocols repo.
/// The only reason we define this state here again is because the protobuf
/// definition ResponseGetSwapState needs to reference to this SwapState.
public struct ForgeAbi_SwapState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var hashkey: Data {
    get {return _storage._hashkey}
    set {_uniqueStorage()._hashkey = newValue}
  }

  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  public var value: ForgeAbi_BigUint {
    get {return _storage._value ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  public var locktime: UInt32 {
    get {return _storage._locktime}
    set {_uniqueStorage()._locktime = newValue}
  }

  public var hashlock: Data {
    get {return _storage._hashlock}
    set {_uniqueStorage()._hashlock = newValue}
  }

  public var context: ForgeAbi_StateContext {
    get {return _storage._context ?? ForgeAbi_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// a rule can check against the statistics values, e.g. state.num_txs < 10000,
/// state.balance_delta < 50000, delta is calculated based on the
/// configuration for interval.
public struct ForgeAbi_DelegateOpState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// all the individual rules in DelegateTx will be concat into one per type_url
  /// by "AND"
  public var rule: String {
    get {return _storage._rule}
    set {_uniqueStorage()._rule = newValue}
  }

  public var numTxs: UInt64 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var numTxsDelta: UInt64 {
    get {return _storage._numTxsDelta}
    set {_uniqueStorage()._numTxsDelta = newValue}
  }

  public var balance: ForgeAbi_BigUint {
    get {return _storage._balance ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var balanceDelta: ForgeAbi_BigUint {
    get {return _storage._balanceDelta ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._balanceDelta = newValue}
  }
  /// Returns true if `balanceDelta` has been explicitly set.
  public var hasBalanceDelta: Bool {return _storage._balanceDelta != nil}
  /// Clears the value of `balanceDelta`. Subsequent reads from it will return its default value.
  public mutating func clearBalanceDelta() {_uniqueStorage()._balanceDelta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_DelegateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var ops: Dictionary<String,ForgeAbi_DelegateOpState> {
    get {return _storage._ops}
    set {_uniqueStorage()._ops = newValue}
  }

  /// state context, replace exiting fields
  public var context: ForgeAbi_StateContext {
    get {return _storage._context ?? ForgeAbi_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  /// forge app can extend this
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "forge_abi"

extension ForgeAbi_AccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "balance"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "num_txs"),
    4: .same(proto: "address"),
    5: .same(proto: "pk"),
    6: .same(proto: "type"),
    7: .same(proto: "moniker"),
    8: .same(proto: "context"),
    9: .same(proto: "issuer"),
    10: .standard(proto: "gas_balance"),
    13: .standard(proto: "migrated_to"),
    14: .standard(proto: "migrated_from"),
    15: .standard(proto: "num_assets"),
    16: .same(proto: "stake"),
    17: .standard(proto: "pinned_files"),
    18: .same(proto: "poke"),
    19: .standard(proto: "deposit_received"),
    20: .standard(proto: "withdraw_items"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _balance: ForgeAbi_BigUint? = nil
    var _nonce: UInt64 = 0
    var _numTxs: UInt64 = 0
    var _address: String = String()
    var _pk: Data = SwiftProtobuf.Internal.emptyData
    var _type: ForgeAbi_WalletType? = nil
    var _moniker: String = String()
    var _context: ForgeAbi_StateContext? = nil
    var _issuer: String = String()
    var _gasBalance: ForgeAbi_BigUint? = nil
    var _migratedTo: [String] = []
    var _migratedFrom: [String] = []
    var _numAssets: UInt64 = 0
    var _stake: ForgeAbi_StakeContext? = nil
    var _pinnedFiles: ForgeAbi_CircularQueue? = nil
    var _poke: ForgeAbi_PokeInfo? = nil
    var _depositReceived: ForgeAbi_BigUint? = nil
    var _withdrawItems: ForgeAbi_CircularQueue? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _balance = source._balance
      _nonce = source._nonce
      _numTxs = source._numTxs
      _address = source._address
      _pk = source._pk
      _type = source._type
      _moniker = source._moniker
      _context = source._context
      _issuer = source._issuer
      _gasBalance = source._gasBalance
      _migratedTo = source._migratedTo
      _migratedFrom = source._migratedFrom
      _numAssets = source._numAssets
      _stake = source._stake
      _pinnedFiles = source._pinnedFiles
      _poke = source._poke
      _depositReceived = source._depositReceived
      _withdrawItems = source._withdrawItems
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._nonce)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._numTxs)
        case 4: try decoder.decodeSingularStringField(value: &_storage._address)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._pk)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 7: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 9: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._gasBalance)
        case 13: try decoder.decodeRepeatedStringField(value: &_storage._migratedTo)
        case 14: try decoder.decodeRepeatedStringField(value: &_storage._migratedFrom)
        case 15: try decoder.decodeSingularUInt64Field(value: &_storage._numAssets)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._stake)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._pinnedFiles)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._poke)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._depositReceived)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._withdrawItems)
        case 50: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._nonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nonce, fieldNumber: 2)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numTxs, fieldNumber: 3)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 4)
      }
      if !_storage._pk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pk, fieldNumber: 5)
      }
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 7)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 9)
      }
      if let v = _storage._gasBalance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._migratedTo.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migratedTo, fieldNumber: 13)
      }
      if !_storage._migratedFrom.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migratedFrom, fieldNumber: 14)
      }
      if _storage._numAssets != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numAssets, fieldNumber: 15)
      }
      if let v = _storage._stake {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._pinnedFiles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._poke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._depositReceived {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._withdrawItems {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_AccountState, rhs: ForgeAbi_AccountState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._gasBalance != rhs_storage._gasBalance {return false}
        if _storage._migratedTo != rhs_storage._migratedTo {return false}
        if _storage._migratedFrom != rhs_storage._migratedFrom {return false}
        if _storage._numAssets != rhs_storage._numAssets {return false}
        if _storage._stake != rhs_storage._stake {return false}
        if _storage._pinnedFiles != rhs_storage._pinnedFiles {return false}
        if _storage._poke != rhs_storage._poke {return false}
        if _storage._depositReceived != rhs_storage._depositReceived {return false}
        if _storage._withdrawItems != rhs_storage._withdrawItems {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_AssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .same(proto: "moniker"),
    4: .same(proto: "readonly"),
    5: .same(proto: "transferrable"),
    6: .same(proto: "ttl"),
    7: .standard(proto: "consumed_time"),
    8: .same(proto: "issuer"),
    9: .same(proto: "parent"),
    13: .same(proto: "stake"),
    14: .same(proto: "context"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _moniker: String = String()
    var _readonly: Bool = false
    var _transferrable: Bool = false
    var _ttl: UInt32 = 0
    var _consumedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _issuer: String = String()
    var _parent: String = String()
    var _stake: ForgeAbi_StakeContext? = nil
    var _context: ForgeAbi_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _moniker = source._moniker
      _readonly = source._readonly
      _transferrable = source._transferrable
      _ttl = source._ttl
      _consumedTime = source._consumedTime
      _issuer = source._issuer
      _parent = source._parent
      _stake = source._stake
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._owner)
        case 3: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._readonly)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._transferrable)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._ttl)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._consumedTime)
        case 8: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 9: try decoder.decodeSingularStringField(value: &_storage._parent)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._stake)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 50: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 3)
      }
      if _storage._readonly != false {
        try visitor.visitSingularBoolField(value: _storage._readonly, fieldNumber: 4)
      }
      if _storage._transferrable != false {
        try visitor.visitSingularBoolField(value: _storage._transferrable, fieldNumber: 5)
      }
      if _storage._ttl != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ttl, fieldNumber: 6)
      }
      if let v = _storage._consumedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 8)
      }
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 9)
      }
      if let v = _storage._stake {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_AssetState, rhs: ForgeAbi_AssetState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._readonly != rhs_storage._readonly {return false}
        if _storage._transferrable != rhs_storage._transferrable {return false}
        if _storage._ttl != rhs_storage._ttl {return false}
        if _storage._consumedTime != rhs_storage._consumedTime {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._stake != rhs_storage._stake {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_CoreProtocol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoreProtocol"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_CoreProtocol, rhs: ForgeAbi_CoreProtocol) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ForgeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "consensus"),
    3: .same(proto: "tasks"),
    4: .standard(proto: "stake_summary"),
    5: .same(proto: "version"),
    8: .same(proto: "token"),
    9: .standard(proto: "tx_config"),
    12: .same(proto: "protocols"),
    13: .same(proto: "gas"),
    14: .standard(proto: "upgrade_info"),
    16: .standard(proto: "account_config"),
    17: .standard(proto: "token_swap_config"),
    2047: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _consensus: ForgeAbi_ConsensusParams? = nil
    var _tasks: Dictionary<UInt64,ForgeAbi_UpgradeTasks> = [:]
    var _stakeSummary: Dictionary<UInt32,ForgeAbi_StakeSummary> = [:]
    var _version: String = String()
    var _token: ForgeAbi_ForgeToken? = nil
    var _txConfig: ForgeAbi_TransactionConfig? = nil
    var _protocols: [ForgeAbi_CoreProtocol] = []
    var _gas: Dictionary<String,UInt32> = [:]
    var _upgradeInfo: ForgeAbi_UpgradeInfo? = nil
    var _accountConfig: Dictionary<String,ForgeAbi_AccountConfig> = [:]
    var _tokenSwapConfig: ForgeAbi_TokenSwapConfig? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _consensus = source._consensus
      _tasks = source._tasks
      _stakeSummary = source._stakeSummary
      _version = source._version
      _token = source._token
      _txConfig = source._txConfig
      _protocols = source._protocols
      _gas = source._gas
      _upgradeInfo = source._upgradeInfo
      _accountConfig = source._accountConfig
      _tokenSwapConfig = source._tokenSwapConfig
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._consensus)
        case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt64,ForgeAbi_UpgradeTasks>.self, value: &_storage._tasks)
        case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,ForgeAbi_StakeSummary>.self, value: &_storage._stakeSummary)
        case 5: try decoder.decodeSingularStringField(value: &_storage._version)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._token)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._txConfig)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._protocols)
        case 13: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &_storage._gas)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._upgradeInfo)
        case 16: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,ForgeAbi_AccountConfig>.self, value: &_storage._accountConfig)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._tokenSwapConfig)
        case 2047: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._consensus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._tasks.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt64,ForgeAbi_UpgradeTasks>.self, value: _storage._tasks, fieldNumber: 3)
      }
      if !_storage._stakeSummary.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,ForgeAbi_StakeSummary>.self, value: _storage._stakeSummary, fieldNumber: 4)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 5)
      }
      if let v = _storage._token {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._txConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._protocols.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._protocols, fieldNumber: 12)
      }
      if !_storage._gas.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: _storage._gas, fieldNumber: 13)
      }
      if let v = _storage._upgradeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if !_storage._accountConfig.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,ForgeAbi_AccountConfig>.self, value: _storage._accountConfig, fieldNumber: 16)
      }
      if let v = _storage._tokenSwapConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2047)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ForgeState, rhs: ForgeAbi_ForgeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._consensus != rhs_storage._consensus {return false}
        if _storage._tasks != rhs_storage._tasks {return false}
        if _storage._stakeSummary != rhs_storage._stakeSummary {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._txConfig != rhs_storage._txConfig {return false}
        if _storage._protocols != rhs_storage._protocols {return false}
        if _storage._gas != rhs_storage._gas {return false}
        if _storage._upgradeInfo != rhs_storage._upgradeInfo {return false}
        if _storage._accountConfig != rhs_storage._accountConfig {return false}
        if _storage._tokenSwapConfig != rhs_storage._tokenSwapConfig {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_RootState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RootState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "account"),
    3: .same(proto: "asset"),
    4: .same(proto: "receipt"),
    5: .same(proto: "protocol"),
    6: .same(proto: "governance"),
    7: .same(proto: "custom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularBytesField(value: &self.account)
      case 3: try decoder.decodeSingularBytesField(value: &self.asset)
      case 4: try decoder.decodeSingularBytesField(value: &self.receipt)
      case 5: try decoder.decodeSingularBytesField(value: &self.`protocol`)
      case 6: try decoder.decodeSingularBytesField(value: &self.governance)
      case 7: try decoder.decodeSingularBytesField(value: &self.custom)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularBytesField(value: self.account, fieldNumber: 2)
    }
    if !self.asset.isEmpty {
      try visitor.visitSingularBytesField(value: self.asset, fieldNumber: 3)
    }
    if !self.receipt.isEmpty {
      try visitor.visitSingularBytesField(value: self.receipt, fieldNumber: 4)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularBytesField(value: self.`protocol`, fieldNumber: 5)
    }
    if !self.governance.isEmpty {
      try visitor.visitSingularBytesField(value: self.governance, fieldNumber: 6)
    }
    if !self.custom.isEmpty {
      try visitor.visitSingularBytesField(value: self.custom, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_RootState, rhs: ForgeAbi_RootState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.account != rhs.account {return false}
    if lhs.asset != rhs.asset {return false}
    if lhs.receipt != rhs.receipt {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.governance != rhs.governance {return false}
    if lhs.custom != rhs.custom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_StakeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "balance"),
    5: .same(proto: "message"),
    14: .same(proto: "context"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _from: String = String()
    var _to: String = String()
    var _balance: ForgeAbi_BigUint? = nil
    var _message: String = String()
    var _context: ForgeAbi_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _from = source._from
      _to = source._to
      _balance = source._balance
      _message = source._message
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._from)
        case 3: try decoder.decodeSingularStringField(value: &_storage._to)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 5: try decoder.decodeSingularStringField(value: &_storage._message)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._from.isEmpty {
        try visitor.visitSingularStringField(value: _storage._from, fieldNumber: 2)
      }
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 3)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 5)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_StakeState, rhs: ForgeAbi_StakeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_StatisticsState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatisticsState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "num_blocks"),
    3: .standard(proto: "num_txs"),
    4: .standard(proto: "num_stakes"),
    5: .standard(proto: "num_validators"),
    6: .standard(proto: "tx_statistics"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _numBlocks: UInt64 = 0
    var _numTxs: UInt64 = 0
    var _numStakes: ForgeAbi_BigUint? = nil
    var _numValidators: UInt32 = 0
    var _txStatistics: ForgeAbi_TxStatistics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _numBlocks = source._numBlocks
      _numTxs = source._numTxs
      _numStakes = source._numStakes
      _numValidators = source._numValidators
      _txStatistics = source._txStatistics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._numBlocks)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._numTxs)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._numStakes)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._numValidators)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._txStatistics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if _storage._numBlocks != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numBlocks, fieldNumber: 2)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numTxs, fieldNumber: 3)
      }
      if let v = _storage._numStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._numValidators != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numValidators, fieldNumber: 5)
      }
      if let v = _storage._txStatistics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_StatisticsState, rhs: ForgeAbi_StatisticsState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._numBlocks != rhs_storage._numBlocks {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._numStakes != rhs_storage._numStakes {return false}
        if _storage._numValidators != rhs_storage._numValidators {return false}
        if _storage._txStatistics != rhs_storage._txStatistics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_BlacklistState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlacklistState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitRepeatedStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_BlacklistState, rhs: ForgeAbi_BlacklistState) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ProtocolState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProtocolState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "itx"),
    3: .standard(proto: "root_hash"),
    4: .same(proto: "status"),
    12: .standard(proto: "migrated_to"),
    13: .standard(proto: "migrated_from"),
    14: .same(proto: "context"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _itx: ForgeAbi_DeployProtocolTx? = nil
    var _rootHash: Data = SwiftProtobuf.Internal.emptyData
    var _status: ForgeAbi_ProtocolStatus = .running
    var _migratedTo: [String] = []
    var _migratedFrom: [String] = []
    var _context: ForgeAbi_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _itx = source._itx
      _rootHash = source._rootHash
      _status = source._status
      _migratedTo = source._migratedTo
      _migratedFrom = source._migratedFrom
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._itx)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._rootHash)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 12: try decoder.decodeRepeatedStringField(value: &_storage._migratedTo)
        case 13: try decoder.decodeRepeatedStringField(value: &_storage._migratedFrom)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._itx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._rootHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rootHash, fieldNumber: 3)
      }
      if _storage._status != .running {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
      if !_storage._migratedTo.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migratedTo, fieldNumber: 12)
      }
      if !_storage._migratedFrom.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._migratedFrom, fieldNumber: 13)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ProtocolState, rhs: ForgeAbi_ProtocolState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._itx != rhs_storage._itx {return false}
        if _storage._rootHash != rhs_storage._rootHash {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._migratedTo != rhs_storage._migratedTo {return false}
        if _storage._migratedFrom != rhs_storage._migratedFrom {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_TetherState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TetherState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "available"),
    3: .same(proto: "custodian"),
    4: .same(proto: "depositor"),
    5: .same(proto: "withdrawer"),
    6: .same(proto: "value"),
    7: .same(proto: "commission"),
    8: .same(proto: "charge"),
    9: .same(proto: "target"),
    10: .same(proto: "locktime"),
    11: .same(proto: "address"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _available: Bool = false
    var _custodian: String = String()
    var _depositor: String = String()
    var _withdrawer: String = String()
    var _value: ForgeAbi_BigUint? = nil
    var _commission: ForgeAbi_BigUint? = nil
    var _charge: ForgeAbi_BigUint? = nil
    var _target: String = String()
    var _locktime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _address: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _available = source._available
      _custodian = source._custodian
      _depositor = source._depositor
      _withdrawer = source._withdrawer
      _value = source._value
      _commission = source._commission
      _charge = source._charge
      _target = source._target
      _locktime = source._locktime
      _address = source._address
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._hash)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._available)
        case 3: try decoder.decodeSingularStringField(value: &_storage._custodian)
        case 4: try decoder.decodeSingularStringField(value: &_storage._depositor)
        case 5: try decoder.decodeSingularStringField(value: &_storage._withdrawer)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._commission)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._charge)
        case 9: try decoder.decodeSingularStringField(value: &_storage._target)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._locktime)
        case 11: try decoder.decodeSingularStringField(value: &_storage._address)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if _storage._available != false {
        try visitor.visitSingularBoolField(value: _storage._available, fieldNumber: 2)
      }
      if !_storage._custodian.isEmpty {
        try visitor.visitSingularStringField(value: _storage._custodian, fieldNumber: 3)
      }
      if !_storage._depositor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._depositor, fieldNumber: 4)
      }
      if !_storage._withdrawer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._withdrawer, fieldNumber: 5)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._commission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._charge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._target.isEmpty {
        try visitor.visitSingularStringField(value: _storage._target, fieldNumber: 9)
      }
      if let v = _storage._locktime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_TetherState, rhs: ForgeAbi_TetherState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._available != rhs_storage._available {return false}
        if _storage._custodian != rhs_storage._custodian {return false}
        if _storage._depositor != rhs_storage._depositor {return false}
        if _storage._withdrawer != rhs_storage._withdrawer {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._commission != rhs_storage._commission {return false}
        if _storage._charge != rhs_storage._charge {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._locktime != rhs_storage._locktime {return false}
        if _storage._address != rhs_storage._address {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_TetherInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TetherInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "available"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.available)
      case 2: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.available != false {
      try visitor.visitSingularBoolField(value: self.available, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_TetherInfo, rhs: ForgeAbi_TetherInfo) -> Bool {
    if lhs.available != rhs.available {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_SwapState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwapState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "address"),
    3: .same(proto: "hashkey"),
    4: .same(proto: "sender"),
    5: .same(proto: "receiver"),
    6: .same(proto: "value"),
    7: .same(proto: "assets"),
    8: .same(proto: "locktime"),
    9: .same(proto: "hashlock"),
    10: .same(proto: "context"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _address: String = String()
    var _hashkey: Data = SwiftProtobuf.Internal.emptyData
    var _sender: String = String()
    var _receiver: String = String()
    var _value: ForgeAbi_BigUint? = nil
    var _assets: [String] = []
    var _locktime: UInt32 = 0
    var _hashlock: Data = SwiftProtobuf.Internal.emptyData
    var _context: ForgeAbi_StateContext? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _address = source._address
      _hashkey = source._hashkey
      _sender = source._sender
      _receiver = source._receiver
      _value = source._value
      _assets = source._assets
      _locktime = source._locktime
      _hashlock = source._hashlock
      _context = source._context
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._hash)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._hashkey)
        case 4: try decoder.decodeSingularStringField(value: &_storage._sender)
        case 5: try decoder.decodeSingularStringField(value: &_storage._receiver)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._locktime)
        case 9: try decoder.decodeSingularBytesField(value: &_storage._hashlock)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._context)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._hashkey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hashkey, fieldNumber: 3)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 4)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 5)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 7)
      }
      if _storage._locktime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._locktime, fieldNumber: 8)
      }
      if !_storage._hashlock.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hashlock, fieldNumber: 9)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_SwapState, rhs: ForgeAbi_SwapState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._hashkey != rhs_storage._hashkey {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._locktime != rhs_storage._locktime {return false}
        if _storage._hashlock != rhs_storage._hashlock {return false}
        if _storage._context != rhs_storage._context {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_DelegateOpState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateOpState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .standard(proto: "num_txs"),
    3: .standard(proto: "num_txs_delta"),
    4: .same(proto: "balance"),
    5: .standard(proto: "balance_delta"),
  ]

  fileprivate class _StorageClass {
    var _rule: String = String()
    var _numTxs: UInt64 = 0
    var _numTxsDelta: UInt64 = 0
    var _balance: ForgeAbi_BigUint? = nil
    var _balanceDelta: ForgeAbi_BigUint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rule = source._rule
      _numTxs = source._numTxs
      _numTxsDelta = source._numTxsDelta
      _balance = source._balance
      _balanceDelta = source._balanceDelta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._rule)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._numTxs)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._numTxsDelta)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._balanceDelta)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._rule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rule, fieldNumber: 1)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numTxs, fieldNumber: 2)
      }
      if _storage._numTxsDelta != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numTxsDelta, fieldNumber: 3)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._balanceDelta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_DelegateOpState, rhs: ForgeAbi_DelegateOpState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rule != rhs_storage._rule {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._numTxsDelta != rhs_storage._numTxsDelta {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._balanceDelta != rhs_storage._balanceDelta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_DelegateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "ops"),
    14: .same(proto: "context"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _ops: Dictionary<String,ForgeAbi_DelegateOpState> = [:]
    var _context: ForgeAbi_StateContext? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _ops = source._ops
      _context = source._context
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,ForgeAbi_DelegateOpState>.self, value: &_storage._ops)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._context)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._ops.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,ForgeAbi_DelegateOpState>.self, value: _storage._ops, fieldNumber: 2)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_DelegateState, rhs: ForgeAbi_DelegateState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._ops != rhs_storage._ops {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
