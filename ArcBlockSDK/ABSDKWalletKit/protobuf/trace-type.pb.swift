// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: trace-type.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Ocap_Direction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case mutual // = 0
  case oneWay // = 1
  case union // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .mutual
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mutual
    case 1: self = .oneWay
    case 2: self = .union
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .mutual: return 0
    case .oneWay: return 1
    case .union: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_Direction] = [
    .mutual,
    .oneWay,
    .union,
  ]
}

#endif  // swift(>=4.2)

public enum Ocap_Validity: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case both // = 0
  case valid // = 1
  case invalid // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .both
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .both
    case 1: self = .valid
    case 2: self = .invalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .both: return 0
    case .valid: return 1
    case .invalid: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ocap_Validity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Ocap_Validity] = [
    .both,
    .valid,
    .invalid,
  ]
}

#endif  // swift(>=4.2)

public struct Ocap_PageOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String = String()

  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_Page {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cursor: String = String()

  public var size: UInt32 = 0

  public var order: [Ocap_PageOrder] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TypeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var types: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AssetFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assets: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_FactoryFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var factories: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TokenFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokens: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_TimeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startDateTime: String = String()

  public var endDateTime: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AddressFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sender: String = String()

  public var receiver: String = String()

  public var direction: Ocap_Direction = .mutual

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_PageInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cursor: String = String()

  public var next: Bool = false

  public var total: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_IndexedTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  public var time: String {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var tx: Ocap_Transaction {
    get {return _storage._tx ?? Ocap_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  public var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  public mutating func clearTx() {_uniqueStorage()._tx = nil}

  public var valid: Bool {
    get {return _storage._valid}
    set {_uniqueStorage()._valid = newValue}
  }

  public var code: Ocap_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var tokenSymbols: [Ocap_TokenSymbol] {
    get {return _storage._tokenSymbols}
    set {_uniqueStorage()._tokenSymbols = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_TokenInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedAccountState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var numAssets: String {
    get {return _storage._numAssets}
    set {_uniqueStorage()._numAssets = newValue}
  }

  public var numTxs: String {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var nonce: String {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var migratedFrom: String {
    get {return _storage._migratedFrom}
    set {_uniqueStorage()._migratedFrom = newValue}
  }

  public var migratedTo: String {
    get {return _storage._migratedTo}
    set {_uniqueStorage()._migratedTo = newValue}
  }

  public var totalReceivedStakes: Ocap_BigUint {
    get {return _storage._totalReceivedStakes ?? Ocap_BigUint()}
    set {_uniqueStorage()._totalReceivedStakes = newValue}
  }
  /// Returns true if `totalReceivedStakes` has been explicitly set.
  public var hasTotalReceivedStakes: Bool {return _storage._totalReceivedStakes != nil}
  /// Clears the value of `totalReceivedStakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalReceivedStakes() {_uniqueStorage()._totalReceivedStakes = nil}

  public var totalStakes: Ocap_BigUint {
    get {return _storage._totalStakes ?? Ocap_BigUint()}
    set {_uniqueStorage()._totalStakes = newValue}
  }
  /// Returns true if `totalStakes` has been explicitly set.
  public var hasTotalStakes: Bool {return _storage._totalStakes != nil}
  /// Clears the value of `totalStakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalStakes() {_uniqueStorage()._totalStakes = nil}

  public var totalUnstakes: Ocap_BigUint {
    get {return _storage._totalUnstakes ?? Ocap_BigUint()}
    set {_uniqueStorage()._totalUnstakes = newValue}
  }
  /// Returns true if `totalUnstakes` has been explicitly set.
  public var hasTotalUnstakes: Bool {return _storage._totalUnstakes != nil}
  /// Clears the value of `totalUnstakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalUnstakes() {_uniqueStorage()._totalUnstakes = nil}

  public var recentNumTxs: [String] {
    get {return _storage._recentNumTxs}
    set {_uniqueStorage()._recentNumTxs = newValue}
  }

  public var tokens: [Ocap_TokenInfo] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedAssetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var readonly: Bool {
    get {return _storage._readonly}
    set {_uniqueStorage()._readonly = newValue}
  }

  public var consumedTime: String {
    get {return _storage._consumedTime}
    set {_uniqueStorage()._consumedTime = newValue}
  }

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  public var transferrable: Bool {
    get {return _storage._transferrable}
    set {_uniqueStorage()._transferrable = newValue}
  }

  public var ttl: String {
    get {return _storage._ttl}
    set {_uniqueStorage()._ttl = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedStakeState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var balance: Ocap_BigUint {
    get {return _storage._balance ?? Ocap_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var sender: String {
    get {return _storage._sender}
    set {_uniqueStorage()._sender = newValue}
  }

  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var type: UInt32 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: String = String()

  public var time: String = String()

  public var proposer: String = String()

  public var numTxs: String = String()

  public var numInvalidTxs: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_IndexedTokenState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  public var unit: String {
    get {return _storage._unit}
    set {_uniqueStorage()._unit = newValue}
  }

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  public var icon: String {
    get {return _storage._icon}
    set {_uniqueStorage()._icon = newValue}
  }

  public var totalSupply: String {
    get {return _storage._totalSupply}
    set {_uniqueStorage()._totalSupply = newValue}
  }

  public var faucetSupply: String {
    get {return _storage._faucetSupply}
    set {_uniqueStorage()._faucetSupply = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var erc20ContractAddress: String {
    get {return _storage._erc20ContractAddress}
    set {_uniqueStorage()._erc20ContractAddress = newValue}
  }

  /// forge won't touch this field. Only forge app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_IndexedFactoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var owner: String {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var settlement: String {
    get {return _storage._settlement}
    set {_uniqueStorage()._settlement = newValue}
  }

  public var limit: String {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  public var trustedIssuers: [String] {
    get {return _storage._trustedIssuers}
    set {_uniqueStorage()._trustedIssuers = newValue}
  }

  public var input: Ocap_AssetFactoryInput {
    get {return _storage._input ?? Ocap_AssetFactoryInput()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_uniqueStorage()._input = nil}

  public var output: Ocap_CreateAssetTx {
    get {return _storage._output ?? Ocap_CreateAssetTx()}
    set {_uniqueStorage()._output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return _storage._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {_uniqueStorage()._output = nil}

  public var hooks: [Ocap_AssetFactoryHook] {
    get {return _storage._hooks}
    set {_uniqueStorage()._hooks = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var balance: String {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  public var tokens: [Ocap_TokenInfo] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var numMinted: String {
    get {return _storage._numMinted}
    set {_uniqueStorage()._numMinted = newValue}
  }

  public var lastSettlement: String {
    get {return _storage._lastSettlement}
    set {_uniqueStorage()._lastSettlement = newValue}
  }

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var renaissanceTime: String {
    get {return _storage._renaissanceTime}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_HealthStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var consensus: Ocap_ConsensusStatus {
    get {return _storage._consensus ?? Ocap_ConsensusStatus()}
    set {_uniqueStorage()._consensus = newValue}
  }
  /// Returns true if `consensus` has been explicitly set.
  public var hasConsensus: Bool {return _storage._consensus != nil}
  /// Clears the value of `consensus`. Subsequent reads from it will return its default value.
  public mutating func clearConsensus() {_uniqueStorage()._consensus = nil}

  public var network: Ocap_NetworkStatus {
    get {return _storage._network ?? Ocap_NetworkStatus()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  public var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  public mutating func clearNetwork() {_uniqueStorage()._network = nil}

  public var storage: Ocap_StorageStatus {
    get {return _storage._storage ?? Ocap_StorageStatus()}
    set {_uniqueStorage()._storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  public var hasStorage: Bool {return _storage._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  public mutating func clearStorage() {_uniqueStorage()._storage = nil}

  public var forge: Ocap_ForgeStatus {
    get {return _storage._forge ?? Ocap_ForgeStatus()}
    set {_uniqueStorage()._forge = newValue}
  }
  /// Returns true if `forge` has been explicitly set.
  public var hasForge: Bool {return _storage._forge != nil}
  /// Clears the value of `forge`. Subsequent reads from it will return its default value.
  public mutating func clearForge() {_uniqueStorage()._forge = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ConsensusStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var health: Bool = false

  public var synced: Bool = false

  public var blockHeight: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_NetworkStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var health: Bool = false

  public var numPeers: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_StorageStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var health: Bool {
    get {return _storage._health}
    set {_uniqueStorage()._health = newValue}
  }

  public var indexerServer: String {
    get {return _storage._indexerServer}
    set {_uniqueStorage()._indexerServer = newValue}
  }

  public var stateDb: String {
    get {return _storage._stateDb}
    set {_uniqueStorage()._stateDb = newValue}
  }

  public var diskSpace: Ocap_DiskSpaceStatus {
    get {return _storage._diskSpace ?? Ocap_DiskSpaceStatus()}
    set {_uniqueStorage()._diskSpace = newValue}
  }
  /// Returns true if `diskSpace` has been explicitly set.
  public var hasDiskSpace: Bool {return _storage._diskSpace != nil}
  /// Clears the value of `diskSpace`. Subsequent reads from it will return its default value.
  public mutating func clearDiskSpace() {_uniqueStorage()._diskSpace = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_DiskSpaceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var forgeUsage: String = String()

  public var total: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ForgeStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var health: Bool {
    get {return _storage._health}
    set {_uniqueStorage()._health = newValue}
  }

  public var abiServer: String {
    get {return _storage._abiServer}
    set {_uniqueStorage()._abiServer = newValue}
  }

  public var forgeWeb: String {
    get {return _storage._forgeWeb}
    set {_uniqueStorage()._forgeWeb = newValue}
  }

  public var abciServer: Ocap_AbciServerStatus {
    get {return _storage._abciServer ?? Ocap_AbciServerStatus()}
    set {_uniqueStorage()._abciServer = newValue}
  }
  /// Returns true if `abciServer` has been explicitly set.
  public var hasAbciServer: Bool {return _storage._abciServer != nil}
  /// Clears the value of `abciServer`. Subsequent reads from it will return its default value.
  public mutating func clearAbciServer() {_uniqueStorage()._abciServer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_AbciServerStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var abciConsensus: String = String()

  public var abciInfo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ValidityFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var validity: Ocap_Validity = .both

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RangeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: String = String()

  public var to: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_AccountToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var symbol: String = String()

  public var balance: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUTUAL"),
    1: .same(proto: "ONE_WAY"),
    2: .same(proto: "UNION"),
  ]
}

extension Ocap_Validity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOTH"),
    1: .same(proto: "VALID"),
    2: .same(proto: "INVALID"),
  ]
}

extension Ocap_PageOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.field)
      case 2: try decoder.decodeSingularStringField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_PageOrder, rhs: Ocap_PageOrder) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_Page: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Page"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .same(proto: "size"),
    3: .same(proto: "order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cursor)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.size)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.order)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.order.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.order, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_Page, rhs: Ocap_Page) -> Bool {
    if lhs.cursor != rhs.cursor {return false}
    if lhs.size != rhs.size {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TypeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.types)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TypeFilter, rhs: Ocap_TypeFilter) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AssetFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssetFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.assets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AssetFilter, rhs: Ocap_AssetFilter) -> Bool {
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_FactoryFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FactoryFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "factories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.factories)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.factories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.factories, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_FactoryFilter, rhs: Ocap_FactoryFilter) -> Bool {
    if lhs.factories != rhs.factories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.tokens)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tokens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenFilter, rhs: Ocap_TokenFilter) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TimeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_date_time"),
    2: .standard(proto: "end_date_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.startDateTime)
      case 2: try decoder.decodeSingularStringField(value: &self.endDateTime)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startDateTime.isEmpty {
      try visitor.visitSingularStringField(value: self.startDateTime, fieldNumber: 1)
    }
    if !self.endDateTime.isEmpty {
      try visitor.visitSingularStringField(value: self.endDateTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TimeFilter, rhs: Ocap_TimeFilter) -> Bool {
    if lhs.startDateTime != rhs.startDateTime {return false}
    if lhs.endDateTime != rhs.endDateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AddressFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "receiver"),
    3: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sender)
      case 2: try decoder.decodeSingularStringField(value: &self.receiver)
      case 3: try decoder.decodeSingularEnumField(value: &self.direction)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.receiver.isEmpty {
      try visitor.visitSingularStringField(value: self.receiver, fieldNumber: 2)
    }
    if self.direction != .mutual {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AddressFilter, rhs: Ocap_AddressFilter) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.receiver != rhs.receiver {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_PageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .same(proto: "next"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cursor)
      case 2: try decoder.decodeSingularBoolField(value: &self.next)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.total)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 1)
    }
    if self.next != false {
      try visitor.visitSingularBoolField(value: self.next, fieldNumber: 2)
    }
    if self.total != 0 {
      try visitor.visitSingularUInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_PageInfo, rhs: Ocap_PageInfo) -> Bool {
    if lhs.cursor != rhs.cursor {return false}
    if lhs.next != rhs.next {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .same(proto: "time"),
    5: .same(proto: "type"),
    6: .same(proto: "tx"),
    20: .same(proto: "valid"),
    21: .same(proto: "code"),
    22: .standard(proto: "token_symbols"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _sender: String = String()
    var _receiver: String = String()
    var _time: String = String()
    var _type: String = String()
    var _tx: Ocap_Transaction? = nil
    var _valid: Bool = false
    var _code: Ocap_StatusCode = .ok
    var _tokenSymbols: [Ocap_TokenSymbol] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _sender = source._sender
      _receiver = source._receiver
      _time = source._time
      _type = source._type
      _tx = source._tx
      _valid = source._valid
      _code = source._code
      _tokenSymbols = source._tokenSymbols
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._hash)
        case 2: try decoder.decodeSingularStringField(value: &_storage._sender)
        case 3: try decoder.decodeSingularStringField(value: &_storage._receiver)
        case 4: try decoder.decodeSingularStringField(value: &_storage._time)
        case 5: try decoder.decodeSingularStringField(value: &_storage._type)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._tx)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._valid)
        case 21: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 22: try decoder.decodeRepeatedMessageField(value: &_storage._tokenSymbols)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 2)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 3)
      }
      if !_storage._time.isEmpty {
        try visitor.visitSingularStringField(value: _storage._time, fieldNumber: 4)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 5)
      }
      if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._valid != false {
        try visitor.visitSingularBoolField(value: _storage._valid, fieldNumber: 20)
      }
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 21)
      }
      if !_storage._tokenSymbols.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokenSymbols, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedTransaction, rhs: Ocap_IndexedTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._tx != rhs_storage._tx {return false}
        if _storage._valid != rhs_storage._valid {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._tokenSymbols != rhs_storage._tokenSymbols {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _balance: Ocap_BigUint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _balance = source._balance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._balance)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenInfo, rhs: Ocap_TokenInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._balance != rhs_storage._balance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedAccountState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedAccountState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
    3: .standard(proto: "num_assets"),
    4: .standard(proto: "num_txs"),
    5: .same(proto: "nonce"),
    6: .standard(proto: "genesis_time"),
    7: .standard(proto: "renaissance_time"),
    8: .same(proto: "moniker"),
    9: .standard(proto: "migrated_from"),
    10: .standard(proto: "migrated_to"),
    11: .standard(proto: "total_received_stakes"),
    12: .standard(proto: "total_stakes"),
    13: .standard(proto: "total_unstakes"),
    14: .standard(proto: "recent_num_txs"),
    15: .same(proto: "tokens"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _balance: Ocap_BigUint? = nil
    var _numAssets: String = String()
    var _numTxs: String = String()
    var _nonce: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _moniker: String = String()
    var _migratedFrom: String = String()
    var _migratedTo: String = String()
    var _totalReceivedStakes: Ocap_BigUint? = nil
    var _totalStakes: Ocap_BigUint? = nil
    var _totalUnstakes: Ocap_BigUint? = nil
    var _recentNumTxs: [String] = []
    var _tokens: [Ocap_TokenInfo] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _balance = source._balance
      _numAssets = source._numAssets
      _numTxs = source._numTxs
      _nonce = source._nonce
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _moniker = source._moniker
      _migratedFrom = source._migratedFrom
      _migratedTo = source._migratedTo
      _totalReceivedStakes = source._totalReceivedStakes
      _totalStakes = source._totalStakes
      _totalUnstakes = source._totalUnstakes
      _recentNumTxs = source._recentNumTxs
      _tokens = source._tokens
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 3: try decoder.decodeSingularStringField(value: &_storage._numAssets)
        case 4: try decoder.decodeSingularStringField(value: &_storage._numTxs)
        case 5: try decoder.decodeSingularStringField(value: &_storage._nonce)
        case 6: try decoder.decodeSingularStringField(value: &_storage._genesisTime)
        case 7: try decoder.decodeSingularStringField(value: &_storage._renaissanceTime)
        case 8: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 9: try decoder.decodeSingularStringField(value: &_storage._migratedFrom)
        case 10: try decoder.decodeSingularStringField(value: &_storage._migratedTo)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._totalReceivedStakes)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._totalStakes)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._totalUnstakes)
        case 14: try decoder.decodeRepeatedStringField(value: &_storage._recentNumTxs)
        case 15: try decoder.decodeRepeatedMessageField(value: &_storage._tokens)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._numAssets.isEmpty {
        try visitor.visitSingularStringField(value: _storage._numAssets, fieldNumber: 3)
      }
      if !_storage._numTxs.isEmpty {
        try visitor.visitSingularStringField(value: _storage._numTxs, fieldNumber: 4)
      }
      if !_storage._nonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nonce, fieldNumber: 5)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 6)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 7)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 8)
      }
      if !_storage._migratedFrom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._migratedFrom, fieldNumber: 9)
      }
      if !_storage._migratedTo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._migratedTo, fieldNumber: 10)
      }
      if let v = _storage._totalReceivedStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._totalStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._totalUnstakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._recentNumTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._recentNumTxs, fieldNumber: 14)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedAccountState, rhs: Ocap_IndexedAccountState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._numAssets != rhs_storage._numAssets {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._migratedFrom != rhs_storage._migratedFrom {return false}
        if _storage._migratedTo != rhs_storage._migratedTo {return false}
        if _storage._totalReceivedStakes != rhs_storage._totalReceivedStakes {return false}
        if _storage._totalStakes != rhs_storage._totalStakes {return false}
        if _storage._totalUnstakes != rhs_storage._totalUnstakes {return false}
        if _storage._recentNumTxs != rhs_storage._recentNumTxs {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedAssetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedAssetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .standard(proto: "genesis_time"),
    4: .standard(proto: "renaissance_time"),
    5: .same(proto: "moniker"),
    6: .same(proto: "readonly"),
    7: .standard(proto: "consumed_time"),
    8: .same(proto: "issuer"),
    9: .same(proto: "parent"),
    10: .same(proto: "transferrable"),
    11: .same(proto: "ttl"),
    50: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _moniker: String = String()
    var _readonly: Bool = false
    var _consumedTime: String = String()
    var _issuer: String = String()
    var _parent: String = String()
    var _transferrable: Bool = false
    var _ttl: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _moniker = source._moniker
      _readonly = source._readonly
      _consumedTime = source._consumedTime
      _issuer = source._issuer
      _parent = source._parent
      _transferrable = source._transferrable
      _ttl = source._ttl
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._owner)
        case 3: try decoder.decodeSingularStringField(value: &_storage._genesisTime)
        case 4: try decoder.decodeSingularStringField(value: &_storage._renaissanceTime)
        case 5: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._readonly)
        case 7: try decoder.decodeSingularStringField(value: &_storage._consumedTime)
        case 8: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 9: try decoder.decodeSingularStringField(value: &_storage._parent)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._transferrable)
        case 11: try decoder.decodeSingularStringField(value: &_storage._ttl)
        case 50: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 3)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 4)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 5)
      }
      if _storage._readonly != false {
        try visitor.visitSingularBoolField(value: _storage._readonly, fieldNumber: 6)
      }
      if !_storage._consumedTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._consumedTime, fieldNumber: 7)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 8)
      }
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 9)
      }
      if _storage._transferrable != false {
        try visitor.visitSingularBoolField(value: _storage._transferrable, fieldNumber: 10)
      }
      if !_storage._ttl.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ttl, fieldNumber: 11)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedAssetState, rhs: Ocap_IndexedAssetState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._readonly != rhs_storage._readonly {return false}
        if _storage._consumedTime != rhs_storage._consumedTime {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._transferrable != rhs_storage._transferrable {return false}
        if _storage._ttl != rhs_storage._ttl {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedStakeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedStakeState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "balance"),
    3: .same(proto: "sender"),
    4: .same(proto: "receiver"),
    5: .standard(proto: "genesis_time"),
    6: .standard(proto: "renaissance_time"),
    7: .same(proto: "message"),
    8: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _balance: Ocap_BigUint? = nil
    var _sender: String = String()
    var _receiver: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _message: String = String()
    var _type: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _balance = source._balance
      _sender = source._sender
      _receiver = source._receiver
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _message = source._message
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._balance)
        case 3: try decoder.decodeSingularStringField(value: &_storage._sender)
        case 4: try decoder.decodeSingularStringField(value: &_storage._receiver)
        case 5: try decoder.decodeSingularStringField(value: &_storage._genesisTime)
        case 6: try decoder.decodeSingularStringField(value: &_storage._renaissanceTime)
        case 7: try decoder.decodeSingularStringField(value: &_storage._message)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._type)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._sender.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sender, fieldNumber: 3)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 4)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 5)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 6)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 7)
      }
      if _storage._type != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._type, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedStakeState, rhs: Ocap_IndexedStakeState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "time"),
    3: .same(proto: "proposer"),
    4: .standard(proto: "num_txs"),
    5: .standard(proto: "num_invalid_txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.height)
      case 2: try decoder.decodeSingularStringField(value: &self.time)
      case 3: try decoder.decodeSingularStringField(value: &self.proposer)
      case 4: try decoder.decodeSingularStringField(value: &self.numTxs)
      case 5: try decoder.decodeSingularStringField(value: &self.numInvalidTxs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.height.isEmpty {
      try visitor.visitSingularStringField(value: self.height, fieldNumber: 1)
    }
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 2)
    }
    if !self.proposer.isEmpty {
      try visitor.visitSingularStringField(value: self.proposer, fieldNumber: 3)
    }
    if !self.numTxs.isEmpty {
      try visitor.visitSingularStringField(value: self.numTxs, fieldNumber: 4)
    }
    if !self.numInvalidTxs.isEmpty {
      try visitor.visitSingularStringField(value: self.numInvalidTxs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedBlock, rhs: Ocap_IndexedBlock) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.time != rhs.time {return false}
    if lhs.proposer != rhs.proposer {return false}
    if lhs.numTxs != rhs.numTxs {return false}
    if lhs.numInvalidTxs != rhs.numInvalidTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedTokenState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedTokenState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "symbol"),
    4: .same(proto: "unit"),
    5: .same(proto: "issuer"),
    6: .same(proto: "icon"),
    7: .standard(proto: "total_supply"),
    8: .standard(proto: "faucet_supply"),
    9: .same(proto: "address"),
    10: .standard(proto: "genesis_time"),
    11: .standard(proto: "renaissance_time"),
    12: .standard(proto: "erc20_contract_address"),
    20: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _symbol: String = String()
    var _unit: String = String()
    var _issuer: String = String()
    var _icon: String = String()
    var _totalSupply: String = String()
    var _faucetSupply: String = String()
    var _address: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()
    var _erc20ContractAddress: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _symbol = source._symbol
      _unit = source._unit
      _issuer = source._issuer
      _icon = source._icon
      _totalSupply = source._totalSupply
      _faucetSupply = source._faucetSupply
      _address = source._address
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
      _erc20ContractAddress = source._erc20ContractAddress
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 3: try decoder.decodeSingularStringField(value: &_storage._symbol)
        case 4: try decoder.decodeSingularStringField(value: &_storage._unit)
        case 5: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 6: try decoder.decodeSingularStringField(value: &_storage._icon)
        case 7: try decoder.decodeSingularStringField(value: &_storage._totalSupply)
        case 8: try decoder.decodeSingularStringField(value: &_storage._faucetSupply)
        case 9: try decoder.decodeSingularStringField(value: &_storage._address)
        case 10: try decoder.decodeSingularStringField(value: &_storage._genesisTime)
        case 11: try decoder.decodeSingularStringField(value: &_storage._renaissanceTime)
        case 12: try decoder.decodeSingularStringField(value: &_storage._erc20ContractAddress)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 3)
      }
      if !_storage._unit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unit, fieldNumber: 4)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 5)
      }
      if !_storage._icon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._icon, fieldNumber: 6)
      }
      if !_storage._totalSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalSupply, fieldNumber: 7)
      }
      if !_storage._faucetSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._faucetSupply, fieldNumber: 8)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 9)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 10)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 11)
      }
      if !_storage._erc20ContractAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._erc20ContractAddress, fieldNumber: 12)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedTokenState, rhs: Ocap_IndexedTokenState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        if _storage._unit != rhs_storage._unit {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._icon != rhs_storage._icon {return false}
        if _storage._totalSupply != rhs_storage._totalSupply {return false}
        if _storage._faucetSupply != rhs_storage._faucetSupply {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        if _storage._erc20ContractAddress != rhs_storage._erc20ContractAddress {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_IndexedFactoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndexedFactoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "owner"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "settlement"),
    6: .same(proto: "limit"),
    7: .standard(proto: "trusted_issuers"),
    8: .same(proto: "input"),
    9: .same(proto: "output"),
    10: .same(proto: "hooks"),
    11: .same(proto: "data"),
    13: .same(proto: "balance"),
    14: .same(proto: "tokens"),
    15: .standard(proto: "num_minted"),
    16: .standard(proto: "last_settlement"),
    17: .standard(proto: "genesis_time"),
    18: .standard(proto: "renaissance_time"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _owner: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _settlement: String = String()
    var _limit: String = String()
    var _trustedIssuers: [String] = []
    var _input: Ocap_AssetFactoryInput? = nil
    var _output: Ocap_CreateAssetTx? = nil
    var _hooks: [Ocap_AssetFactoryHook] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _balance: String = String()
    var _tokens: [Ocap_TokenInfo] = []
    var _numMinted: String = String()
    var _lastSettlement: String = String()
    var _genesisTime: String = String()
    var _renaissanceTime: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _owner = source._owner
      _name = source._name
      _description_p = source._description_p
      _settlement = source._settlement
      _limit = source._limit
      _trustedIssuers = source._trustedIssuers
      _input = source._input
      _output = source._output
      _hooks = source._hooks
      _data = source._data
      _balance = source._balance
      _tokens = source._tokens
      _numMinted = source._numMinted
      _lastSettlement = source._lastSettlement
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._owner)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 5: try decoder.decodeSingularStringField(value: &_storage._settlement)
        case 6: try decoder.decodeSingularStringField(value: &_storage._limit)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._trustedIssuers)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._input)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._output)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._hooks)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._data)
        case 13: try decoder.decodeSingularStringField(value: &_storage._balance)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._tokens)
        case 15: try decoder.decodeSingularStringField(value: &_storage._numMinted)
        case 16: try decoder.decodeSingularStringField(value: &_storage._lastSettlement)
        case 17: try decoder.decodeSingularStringField(value: &_storage._genesisTime)
        case 18: try decoder.decodeSingularStringField(value: &_storage._renaissanceTime)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if !_storage._settlement.isEmpty {
        try visitor.visitSingularStringField(value: _storage._settlement, fieldNumber: 5)
      }
      if !_storage._limit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._limit, fieldNumber: 6)
      }
      if !_storage._trustedIssuers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._trustedIssuers, fieldNumber: 7)
      }
      if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._output {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._hooks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hooks, fieldNumber: 10)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._balance.isEmpty {
        try visitor.visitSingularStringField(value: _storage._balance, fieldNumber: 13)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 14)
      }
      if !_storage._numMinted.isEmpty {
        try visitor.visitSingularStringField(value: _storage._numMinted, fieldNumber: 15)
      }
      if !_storage._lastSettlement.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastSettlement, fieldNumber: 16)
      }
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 17)
      }
      if !_storage._renaissanceTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTime, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_IndexedFactoryState, rhs: Ocap_IndexedFactoryState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._settlement != rhs_storage._settlement {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._trustedIssuers != rhs_storage._trustedIssuers {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._output != rhs_storage._output {return false}
        if _storage._hooks != rhs_storage._hooks {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._numMinted != rhs_storage._numMinted {return false}
        if _storage._lastSettlement != rhs_storage._lastSettlement {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_HealthStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consensus"),
    2: .same(proto: "network"),
    3: .same(proto: "storage"),
    4: .same(proto: "forge"),
  ]

  fileprivate class _StorageClass {
    var _consensus: Ocap_ConsensusStatus? = nil
    var _network: Ocap_NetworkStatus? = nil
    var _storage: Ocap_StorageStatus? = nil
    var _forge: Ocap_ForgeStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _consensus = source._consensus
      _network = source._network
      _storage = source._storage
      _forge = source._forge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._consensus)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._network)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._storage)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._forge)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._consensus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._storage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._forge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_HealthStatus, rhs: Ocap_HealthStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._consensus != rhs_storage._consensus {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._storage != rhs_storage._storage {return false}
        if _storage._forge != rhs_storage._forge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ConsensusStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsensusStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "health"),
    2: .same(proto: "synced"),
    3: .standard(proto: "block_height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.health)
      case 2: try decoder.decodeSingularBoolField(value: &self.synced)
      case 3: try decoder.decodeSingularStringField(value: &self.blockHeight)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.health != false {
      try visitor.visitSingularBoolField(value: self.health, fieldNumber: 1)
    }
    if self.synced != false {
      try visitor.visitSingularBoolField(value: self.synced, fieldNumber: 2)
    }
    if !self.blockHeight.isEmpty {
      try visitor.visitSingularStringField(value: self.blockHeight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ConsensusStatus, rhs: Ocap_ConsensusStatus) -> Bool {
    if lhs.health != rhs.health {return false}
    if lhs.synced != rhs.synced {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_NetworkStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "health"),
    2: .standard(proto: "num_peers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.health)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.numPeers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.health != false {
      try visitor.visitSingularBoolField(value: self.health, fieldNumber: 1)
    }
    if self.numPeers != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPeers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_NetworkStatus, rhs: Ocap_NetworkStatus) -> Bool {
    if lhs.health != rhs.health {return false}
    if lhs.numPeers != rhs.numPeers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_StorageStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "health"),
    2: .standard(proto: "indexer_server"),
    3: .standard(proto: "state_db"),
    4: .standard(proto: "disk_space"),
  ]

  fileprivate class _StorageClass {
    var _health: Bool = false
    var _indexerServer: String = String()
    var _stateDb: String = String()
    var _diskSpace: Ocap_DiskSpaceStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _health = source._health
      _indexerServer = source._indexerServer
      _stateDb = source._stateDb
      _diskSpace = source._diskSpace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._health)
        case 2: try decoder.decodeSingularStringField(value: &_storage._indexerServer)
        case 3: try decoder.decodeSingularStringField(value: &_storage._stateDb)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._diskSpace)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._health != false {
        try visitor.visitSingularBoolField(value: _storage._health, fieldNumber: 1)
      }
      if !_storage._indexerServer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._indexerServer, fieldNumber: 2)
      }
      if !_storage._stateDb.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDb, fieldNumber: 3)
      }
      if let v = _storage._diskSpace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_StorageStatus, rhs: Ocap_StorageStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._health != rhs_storage._health {return false}
        if _storage._indexerServer != rhs_storage._indexerServer {return false}
        if _storage._stateDb != rhs_storage._stateDb {return false}
        if _storage._diskSpace != rhs_storage._diskSpace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DiskSpaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiskSpaceStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "forge_usage"),
    2: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.forgeUsage)
      case 2: try decoder.decodeSingularStringField(value: &self.total)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.forgeUsage.isEmpty {
      try visitor.visitSingularStringField(value: self.forgeUsage, fieldNumber: 1)
    }
    if !self.total.isEmpty {
      try visitor.visitSingularStringField(value: self.total, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DiskSpaceStatus, rhs: Ocap_DiskSpaceStatus) -> Bool {
    if lhs.forgeUsage != rhs.forgeUsage {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ForgeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgeStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "health"),
    2: .standard(proto: "abi_server"),
    3: .standard(proto: "forge_web"),
    4: .standard(proto: "abci_server"),
  ]

  fileprivate class _StorageClass {
    var _health: Bool = false
    var _abiServer: String = String()
    var _forgeWeb: String = String()
    var _abciServer: Ocap_AbciServerStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _health = source._health
      _abiServer = source._abiServer
      _forgeWeb = source._forgeWeb
      _abciServer = source._abciServer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._health)
        case 2: try decoder.decodeSingularStringField(value: &_storage._abiServer)
        case 3: try decoder.decodeSingularStringField(value: &_storage._forgeWeb)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._abciServer)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._health != false {
        try visitor.visitSingularBoolField(value: _storage._health, fieldNumber: 1)
      }
      if !_storage._abiServer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._abiServer, fieldNumber: 2)
      }
      if !_storage._forgeWeb.isEmpty {
        try visitor.visitSingularStringField(value: _storage._forgeWeb, fieldNumber: 3)
      }
      if let v = _storage._abciServer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ForgeStatus, rhs: Ocap_ForgeStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._health != rhs_storage._health {return false}
        if _storage._abiServer != rhs_storage._abiServer {return false}
        if _storage._forgeWeb != rhs_storage._forgeWeb {return false}
        if _storage._abciServer != rhs_storage._abciServer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AbciServerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AbciServerStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "abci_consensus"),
    2: .standard(proto: "abci_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.abciConsensus)
      case 2: try decoder.decodeSingularStringField(value: &self.abciInfo)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.abciConsensus.isEmpty {
      try visitor.visitSingularStringField(value: self.abciConsensus, fieldNumber: 1)
    }
    if !self.abciInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.abciInfo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AbciServerStatus, rhs: Ocap_AbciServerStatus) -> Bool {
    if lhs.abciConsensus != rhs.abciConsensus {return false}
    if lhs.abciInfo != rhs.abciInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ValidityFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidityFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.validity)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.validity != .both {
      try visitor.visitSingularEnumField(value: self.validity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ValidityFilter, rhs: Ocap_ValidityFilter) -> Bool {
    if lhs.validity != rhs.validity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RangeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RangeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.from)
      case 2: try decoder.decodeSingularStringField(value: &self.to)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RangeFilter, rhs: Ocap_RangeFilter) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_AccountToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "symbol"),
    3: .same(proto: "balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularStringField(value: &self.balance)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.balance.isEmpty {
      try visitor.visitSingularStringField(value: self.balance, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AccountToken, rhs: Ocap_AccountToken) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
