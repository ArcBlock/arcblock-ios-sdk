// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// account
public struct Ocap_AccountMigrateTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// new public key
  public var pk: Data {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  /// new wallet type
  public var type: Ocap_WalletType {
    get {return _storage._type ?? Ocap_WalletType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// new wallet address
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_DeclareTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var issuer: String {
    get {return _storage._issuer}
    set {_uniqueStorage()._issuer = newValue}
  }

  /// ocap won't update data into state if app is interested in this tx.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_DelegateTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address of the delegation between sender and receiver
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// delegatee's address
  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  /// a list of operations permitted
  public var ops: [Ocap_DelegateOp] {
    get {return _storage._ops}
    set {_uniqueStorage()._ops = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// if rules are empty, signature for this type_url is entirely delegated
/// otherwise rules are checked one by one, relationship between rules is AND.
/// a rule is an expression defined in rule_parser
/// (github.com/arcblock/rule-parser) one can setup
public struct Ocap_DelegateOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typeURL: String = String()

  public var rules: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_RevokeDelegateTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address of the delegation between sender and receiver
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// delegatee's address
  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  public var typeUrls: [String] {
    get {return _storage._typeUrls}
    set {_uniqueStorage()._typeUrls = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// governance
public struct Ocap_UpdateConsensusParamsTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// new delegate config
  public var delegateConfig: Ocap_DelegateConfig {
    get {return _storage._delegateConfig ?? Ocap_DelegateConfig()}
    set {_uniqueStorage()._delegateConfig = newValue}
  }
  /// Returns true if `delegateConfig` has been explicitly set.
  public var hasDelegateConfig: Bool {return _storage._delegateConfig != nil}
  /// Clears the value of `delegateConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDelegateConfig() {_uniqueStorage()._delegateConfig = nil}

  /// new declare config
  public var declareConfig: Ocap_DeclareConfig {
    get {return _storage._declareConfig ?? Ocap_DeclareConfig()}
    set {_uniqueStorage()._declareConfig = newValue}
  }
  /// Returns true if `declareConfig` has been explicitly set.
  public var hasDeclareConfig: Bool {return _storage._declareConfig != nil}
  /// Clears the value of `declareConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDeclareConfig() {_uniqueStorage()._declareConfig = nil}

  /// new token swap config
  public var tokenSwapConfig: Ocap_TokenSwapConfig {
    get {return _storage._tokenSwapConfig ?? Ocap_TokenSwapConfig()}
    set {_uniqueStorage()._tokenSwapConfig = newValue}
  }
  /// Returns true if `tokenSwapConfig` has been explicitly set.
  public var hasTokenSwapConfig: Bool {return _storage._tokenSwapConfig != nil}
  /// Clears the value of `tokenSwapConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTokenSwapConfig() {_uniqueStorage()._tokenSwapConfig = nil}

  /// new moderator address
  public var moderatorConfig: Ocap_AccountConfig {
    get {return _storage._moderatorConfig ?? Ocap_AccountConfig()}
    set {_uniqueStorage()._moderatorConfig = newValue}
  }
  /// Returns true if `moderatorConfig` has been explicitly set.
  public var hasModeratorConfig: Bool {return _storage._moderatorConfig != nil}
  /// Clears the value of `moderatorConfig`. Subsequent reads from it will return its default value.
  public mutating func clearModeratorConfig() {_uniqueStorage()._moderatorConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_UpdateValidatorTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var candidates: [Ocap_Validator] {
    get {return _storage._candidates}
    set {_uniqueStorage()._candidates = newValue}
  }

  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_UpgradeNodeTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the height node will be stopped at.
  public var height: UInt64 = 0

  /// the version next release is expected
  public var version: String = String()

  /// override the existing upgrade settings if there's already one. Use it with
  /// cautious.
  public var override: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// misc
public struct Ocap_PokeTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type url: fg:x:poke
  public var date: String {
    get {return _storage._date}
    set {_uniqueStorage()._date = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_FaucetTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String {
    get {return _storage._date}
    set {_uniqueStorage()._date = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RefuelTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: String {
    get {return _storage._date}
    set {_uniqueStorage()._date = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// atomic swap
public struct Ocap_RetrieveSwapTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address of the swap state.
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// The origin value of the random number.
  public var hashkey: Data {
    get {return _storage._hashkey}
    set {_uniqueStorage()._hashkey = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RevokeSwapTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address of the swap state.
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_SetupSwapTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The amount of token to swap.
  public var value: Ocap_BigUint {
    get {return _storage._value ?? Ocap_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  /// The addresses of assets to swap.
  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  /// The address of the receiver who is the only one allowed to get the token
  /// and assets locktime.
  public var receiver: String {
    get {return _storage._receiver}
    set {_uniqueStorage()._receiver = newValue}
  }

  /// The sha3 value of the random number.
  public var hashlock: Data {
    get {return _storage._hashlock}
    set {_uniqueStorage()._hashlock = newValue}
  }

  /// The height of the block before which the swap is locked.
  public var locktime: UInt32 {
    get {return _storage._locktime}
    set {_uniqueStorage()._locktime = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// token swap
public struct Ocap_ApproveWithdrawTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the hash of withdraw tx
  public var withdrawTxHash: String {
    get {return _storage._withdrawTxHash}
    set {_uniqueStorage()._withdrawTxHash = newValue}
  }

  /// the evidence of the original transaction that
  public var evidence: Ocap_Evidence {
    get {return _storage._evidence ?? Ocap_Evidence()}
    set {_uniqueStorage()._evidence = newValue}
  }
  /// Returns true if `evidence` has been explicitly set.
  public var hasEvidence: Bool {return _storage._evidence != nil}
  /// Clears the value of `evidence`. Subsequent reads from it will return its default value.
  public mutating func clearEvidence() {_uniqueStorage()._evidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_DepositTokenTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// how many units to issue
  public var value: Ocap_BigUint {
    get {return _storage._value ?? Ocap_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  /// address of the controlled account on Forge
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// the evidence of the original transaction
  public var evidence: Ocap_Evidence {
    get {return _storage._evidence ?? Ocap_Evidence()}
    set {_uniqueStorage()._evidence = newValue}
  }
  /// Returns true if `evidence` has been explicitly set.
  public var hasEvidence: Bool {return _storage._evidence != nil}
  /// Clears the value of `evidence`. Subsequent reads from it will return its default value.
  public mutating func clearEvidence() {_uniqueStorage()._evidence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_RevokeWithdrawTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the hash of withdraw tx
  public var withdrawTxHash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_WithdrawTokenTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// how many units to revokes
  public var value: Ocap_BigUint {
    get {return _storage._value ?? Ocap_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  /// foreign address to withdraw token to.
  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  /// type of the chain currently only "eth"
  public var chainType: String {
    get {return _storage._chainType}
    set {_uniqueStorage()._chainType = newValue}
  }

  /// chain id of the chain. Could be testnet or mainnet.
  public var chainID: String {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  /// the time that a withdraw token tx would expire so user can unlock her tokens from intermediate state
  public var ttl: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._ttl ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._ttl = newValue}
  }
  /// Returns true if `ttl` has been explicitly set.
  public var hasTtl: Bool {return _storage._ttl != nil}
  /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
  public mutating func clearTtl() {_uniqueStorage()._ttl = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// trade
public struct Ocap_ExchangeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Ocap_BigUint {
    get {return _storage._value ?? Ocap_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_TokenPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ocap_ExchangeInfoV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Ocap_BigUint {
    get {return _storage._value ?? Ocap_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  public var tokens: [Ocap_TokenPayload] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// we could support these cases (and vise versa):
/// 1. sender fungible token <-> receiver one or more assets
/// 2. sender fungible token + asset <-> receiver one or more assets
/// 3. sender one or more assets <-> receiver one or more assets
public struct Ocap_ExchangeTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  public var sender: Ocap_ExchangeInfo {
    get {return _storage._sender ?? Ocap_ExchangeInfo()}
    set {_uniqueStorage()._sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return _storage._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {_uniqueStorage()._sender = nil}

  public var receiver: Ocap_ExchangeInfo {
    get {return _storage._receiver ?? Ocap_ExchangeInfo()}
    set {_uniqueStorage()._receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  public var hasReceiver: Bool {return _storage._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  public mutating func clearReceiver() {_uniqueStorage()._receiver = nil}

  public var expiredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiredAt = newValue}
  }
  /// Returns true if `expiredAt` has been explicitly set.
  public var hasExpiredAt: Bool {return _storage._expiredAt != nil}
  /// Clears the value of `expiredAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiredAt() {_uniqueStorage()._expiredAt = nil}

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ExchangeV2Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  public var sender: Ocap_ExchangeInfoV2 {
    get {return _storage._sender ?? Ocap_ExchangeInfoV2()}
    set {_uniqueStorage()._sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return _storage._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {_uniqueStorage()._sender = nil}

  public var receiver: Ocap_ExchangeInfoV2 {
    get {return _storage._receiver ?? Ocap_ExchangeInfoV2()}
    set {_uniqueStorage()._receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  public var hasReceiver: Bool {return _storage._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  public mutating func clearReceiver() {_uniqueStorage()._receiver = nil}

  public var expiredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiredAt = newValue}
  }
  /// Returns true if `expiredAt` has been explicitly set.
  public var hasExpiredAt: Bool {return _storage._expiredAt != nil}
  /// Clears the value of `expiredAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiredAt() {_uniqueStorage()._expiredAt = nil}

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_TransferTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  public var value: Ocap_BigUint {
    get {return _storage._value ?? Ocap_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_TransferV2Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var to: String {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  public var value: Ocap_BigUint {
    get {return _storage._value ?? Ocap_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var assets: [String] {
    get {return _storage._assets}
    set {_uniqueStorage()._assets = newValue}
  }

  public var tokens: [Ocap_TokenPayload] {
    get {return _storage._tokens}
    set {_uniqueStorage()._tokens = newValue}
  }

  /// ocap won't touch this field. Only ocap app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_CreateTokenTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  public var unit: String {
    get {return _storage._unit}
    set {_uniqueStorage()._unit = newValue}
  }

  public var icon: String {
    get {return _storage._icon}
    set {_uniqueStorage()._icon = newValue}
  }

  public var totalSupply: String {
    get {return _storage._totalSupply}
    set {_uniqueStorage()._totalSupply = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var faucetSupply: String {
    get {return _storage._faucetSupply}
    set {_uniqueStorage()._faucetSupply = newValue}
  }

  public var erc20ContractAddress: String {
    get {return _storage._erc20ContractAddress}
    set {_uniqueStorage()._erc20ContractAddress = newValue}
  }

  /// forge won't touch this field. Only forge app shall handle it.
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocap_ItxStub {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var declare: Ocap_DeclareTx {
    get {
      if case .declare(let v)? = _storage._value {return v}
      return Ocap_DeclareTx()
    }
    set {_uniqueStorage()._value = .declare(newValue)}
  }

  public var delegate: Ocap_DelegateTx {
    get {
      if case .delegate(let v)? = _storage._value {return v}
      return Ocap_DelegateTx()
    }
    set {_uniqueStorage()._value = .delegate(newValue)}
  }

  public var revokeDelegate: Ocap_RevokeDelegateTx {
    get {
      if case .revokeDelegate(let v)? = _storage._value {return v}
      return Ocap_RevokeDelegateTx()
    }
    set {_uniqueStorage()._value = .revokeDelegate(newValue)}
  }

  public var accountMigrate: Ocap_AccountMigrateTx {
    get {
      if case .accountMigrate(let v)? = _storage._value {return v}
      return Ocap_AccountMigrateTx()
    }
    set {_uniqueStorage()._value = .accountMigrate(newValue)}
  }

  public var createAsset: Ocap_CreateAssetTx {
    get {
      if case .createAsset(let v)? = _storage._value {return v}
      return Ocap_CreateAssetTx()
    }
    set {_uniqueStorage()._value = .createAsset(newValue)}
  }

  public var consumeAsset: Ocap_ConsumeAssetTx {
    get {
      if case .consumeAsset(let v)? = _storage._value {return v}
      return Ocap_ConsumeAssetTx()
    }
    set {_uniqueStorage()._value = .consumeAsset(newValue)}
  }

  public var acquireAsset: Ocap_AcquireAssetTx {
    get {
      if case .acquireAsset(let v)? = _storage._value {return v}
      return Ocap_AcquireAssetTx()
    }
    set {_uniqueStorage()._value = .acquireAsset(newValue)}
  }

  public var updateAsset: Ocap_UpdateAssetTx {
    get {
      if case .updateAsset(let v)? = _storage._value {return v}
      return Ocap_UpdateAssetTx()
    }
    set {_uniqueStorage()._value = .updateAsset(newValue)}
  }

  public var exchange: Ocap_ExchangeTx {
    get {
      if case .exchange(let v)? = _storage._value {return v}
      return Ocap_ExchangeTx()
    }
    set {_uniqueStorage()._value = .exchange(newValue)}
  }

  public var exchangeV2: Ocap_ExchangeV2Tx {
    get {
      if case .exchangeV2(let v)? = _storage._value {return v}
      return Ocap_ExchangeV2Tx()
    }
    set {_uniqueStorage()._value = .exchangeV2(newValue)}
  }

  public var transfer: Ocap_TransferTx {
    get {
      if case .transfer(let v)? = _storage._value {return v}
      return Ocap_TransferTx()
    }
    set {_uniqueStorage()._value = .transfer(newValue)}
  }

  public var transferV2: Ocap_TransferV2Tx {
    get {
      if case .transferV2(let v)? = _storage._value {return v}
      return Ocap_TransferV2Tx()
    }
    set {_uniqueStorage()._value = .transferV2(newValue)}
  }

  public var poke: Ocap_PokeTx {
    get {
      if case .poke(let v)? = _storage._value {return v}
      return Ocap_PokeTx()
    }
    set {_uniqueStorage()._value = .poke(newValue)}
  }

  public var faucet: Ocap_FaucetTx {
    get {
      if case .faucet(let v)? = _storage._value {return v}
      return Ocap_FaucetTx()
    }
    set {_uniqueStorage()._value = .faucet(newValue)}
  }

  public var upgradeNode: Ocap_UpgradeNodeTx {
    get {
      if case .upgradeNode(let v)? = _storage._value {return v}
      return Ocap_UpgradeNodeTx()
    }
    set {_uniqueStorage()._value = .upgradeNode(newValue)}
  }

  public var revokeSwap: Ocap_RevokeSwapTx {
    get {
      if case .revokeSwap(let v)? = _storage._value {return v}
      return Ocap_RevokeSwapTx()
    }
    set {_uniqueStorage()._value = .revokeSwap(newValue)}
  }

  public var retrieveSwap: Ocap_RetrieveSwapTx {
    get {
      if case .retrieveSwap(let v)? = _storage._value {return v}
      return Ocap_RetrieveSwapTx()
    }
    set {_uniqueStorage()._value = .retrieveSwap(newValue)}
  }

  public var setupSwap: Ocap_SetupSwapTx {
    get {
      if case .setupSwap(let v)? = _storage._value {return v}
      return Ocap_SetupSwapTx()
    }
    set {_uniqueStorage()._value = .setupSwap(newValue)}
  }

  public var createToken: Ocap_CreateTokenTx {
    get {
      if case .createToken(let v)? = _storage._value {return v}
      return Ocap_CreateTokenTx()
    }
    set {_uniqueStorage()._value = .createToken(newValue)}
  }

  public var acquireAssetV2: Ocap_AcquireAssetV2Tx {
    get {
      if case .acquireAssetV2(let v)? = _storage._value {return v}
      return Ocap_AcquireAssetV2Tx()
    }
    set {_uniqueStorage()._value = .acquireAssetV2(newValue)}
  }

  public var mintAsset: Ocap_MintAssetTx {
    get {
      if case .mintAsset(let v)? = _storage._value {return v}
      return Ocap_MintAssetTx()
    }
    set {_uniqueStorage()._value = .mintAsset(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case declare(Ocap_DeclareTx)
    case delegate(Ocap_DelegateTx)
    case revokeDelegate(Ocap_RevokeDelegateTx)
    case accountMigrate(Ocap_AccountMigrateTx)
    case createAsset(Ocap_CreateAssetTx)
    case consumeAsset(Ocap_ConsumeAssetTx)
    case acquireAsset(Ocap_AcquireAssetTx)
    case updateAsset(Ocap_UpdateAssetTx)
    case exchange(Ocap_ExchangeTx)
    case exchangeV2(Ocap_ExchangeV2Tx)
    case transfer(Ocap_TransferTx)
    case transferV2(Ocap_TransferV2Tx)
    case poke(Ocap_PokeTx)
    case faucet(Ocap_FaucetTx)
    case upgradeNode(Ocap_UpgradeNodeTx)
    case revokeSwap(Ocap_RevokeSwapTx)
    case retrieveSwap(Ocap_RetrieveSwapTx)
    case setupSwap(Ocap_SetupSwapTx)
    case createToken(Ocap_CreateTokenTx)
    case acquireAssetV2(Ocap_AcquireAssetV2Tx)
    case mintAsset(Ocap_MintAssetTx)

  #if !swift(>=4.1)
    public static func ==(lhs: Ocap_ItxStub.OneOf_Value, rhs: Ocap_ItxStub.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.declare(let l), .declare(let r)): return l == r
      case (.delegate(let l), .delegate(let r)): return l == r
      case (.revokeDelegate(let l), .revokeDelegate(let r)): return l == r
      case (.accountMigrate(let l), .accountMigrate(let r)): return l == r
      case (.createAsset(let l), .createAsset(let r)): return l == r
      case (.consumeAsset(let l), .consumeAsset(let r)): return l == r
      case (.acquireAsset(let l), .acquireAsset(let r)): return l == r
      case (.updateAsset(let l), .updateAsset(let r)): return l == r
      case (.exchange(let l), .exchange(let r)): return l == r
      case (.exchangeV2(let l), .exchangeV2(let r)): return l == r
      case (.transfer(let l), .transfer(let r)): return l == r
      case (.transferV2(let l), .transferV2(let r)): return l == r
      case (.poke(let l), .poke(let r)): return l == r
      case (.faucet(let l), .faucet(let r)): return l == r
      case (.upgradeNode(let l), .upgradeNode(let r)): return l == r
      case (.revokeSwap(let l), .revokeSwap(let r)): return l == r
      case (.retrieveSwap(let l), .retrieveSwap(let r)): return l == r
      case (.setupSwap(let l), .setupSwap(let r)): return l == r
      case (.createToken(let l), .createToken(let r)): return l == r
      case (.acquireAssetV2(let l), .acquireAssetV2(let r)): return l == r
      case (.mintAsset(let l), .mintAsset(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ocap"

extension Ocap_AccountMigrateTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountMigrateTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pk"),
    2: .same(proto: "type"),
    3: .same(proto: "address"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _pk: Data = SwiftProtobuf.Internal.emptyData
    var _type: Ocap_WalletType? = nil
    var _address: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pk = source._pk
      _type = source._type
      _address = source._address
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._pk)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 3: try decoder.decodeSingularStringField(value: &_storage._address)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._pk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pk, fieldNumber: 1)
      }
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 3)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_AccountMigrateTx, rhs: Ocap_AccountMigrateTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DeclareTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeclareTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moniker"),
    2: .same(proto: "issuer"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _moniker: String = String()
    var _issuer: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _moniker = source._moniker
      _issuer = source._issuer
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 2: try decoder.decodeSingularStringField(value: &_storage._issuer)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 1)
      }
      if !_storage._issuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuer, fieldNumber: 2)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DeclareTx, rhs: Ocap_DeclareTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._issuer != rhs_storage._issuer {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegateTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "to"),
    3: .same(proto: "ops"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _to: String = String()
    var _ops: [Ocap_DelegateOp] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _to = source._to
      _ops = source._ops
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._to)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._ops)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 2)
      }
      if !_storage._ops.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ops, fieldNumber: 3)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegateTx, rhs: Ocap_DelegateTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._ops != rhs_storage._ops {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DelegateOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateOp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_url"),
    2: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.typeURL)
      case 2: try decoder.decodeRepeatedStringField(value: &self.rules)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.typeURL, fieldNumber: 1)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DelegateOp, rhs: Ocap_DelegateOp) -> Bool {
    if lhs.typeURL != rhs.typeURL {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RevokeDelegateTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeDelegateTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "to"),
    3: .standard(proto: "type_urls"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _to: String = String()
    var _typeUrls: [String] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _to = source._to
      _typeUrls = source._typeUrls
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularStringField(value: &_storage._to)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._typeUrls)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 2)
      }
      if !_storage._typeUrls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._typeUrls, fieldNumber: 3)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RevokeDelegateTx, rhs: Ocap_RevokeDelegateTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._typeUrls != rhs_storage._typeUrls {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UpdateConsensusParamsTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConsensusParamsTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegate_config"),
    2: .standard(proto: "declare_config"),
    3: .standard(proto: "token_swap_config"),
    4: .standard(proto: "moderator_config"),
  ]

  fileprivate class _StorageClass {
    var _delegateConfig: Ocap_DelegateConfig? = nil
    var _declareConfig: Ocap_DeclareConfig? = nil
    var _tokenSwapConfig: Ocap_TokenSwapConfig? = nil
    var _moderatorConfig: Ocap_AccountConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _delegateConfig = source._delegateConfig
      _declareConfig = source._declareConfig
      _tokenSwapConfig = source._tokenSwapConfig
      _moderatorConfig = source._moderatorConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._delegateConfig)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._declareConfig)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._tokenSwapConfig)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._moderatorConfig)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._delegateConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._declareConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._tokenSwapConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._moderatorConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UpdateConsensusParamsTx, rhs: Ocap_UpdateConsensusParamsTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._delegateConfig != rhs_storage._delegateConfig {return false}
        if _storage._declareConfig != rhs_storage._declareConfig {return false}
        if _storage._tokenSwapConfig != rhs_storage._tokenSwapConfig {return false}
        if _storage._moderatorConfig != rhs_storage._moderatorConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UpdateValidatorTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateValidatorTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candidates"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _candidates: [Ocap_Validator] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _candidates = source._candidates
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._candidates)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._candidates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._candidates, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UpdateValidatorTx, rhs: Ocap_UpdateValidatorTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._candidates != rhs_storage._candidates {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_UpgradeNodeTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeNodeTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "version"),
    3: .same(proto: "override"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.height)
      case 2: try decoder.decodeSingularStringField(value: &self.version)
      case 3: try decoder.decodeSingularBoolField(value: &self.override)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.override != false {
      try visitor.visitSingularBoolField(value: self.override, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_UpgradeNodeTx, rhs: Ocap_UpgradeNodeTx) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.version != rhs.version {return false}
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_PokeTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PokeTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "address"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _date: String = String()
    var _address: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _date = source._date
      _address = source._address
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._date)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._date.isEmpty {
        try visitor.visitSingularStringField(value: _storage._date, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_PokeTx, rhs: Ocap_PokeTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._date != rhs_storage._date {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_FaucetTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaucetTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "address"),
    3: .same(proto: "token"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _date: String = String()
    var _address: String = String()
    var _token: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _date = source._date
      _address = source._address
      _token = source._token
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._date)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 3: try decoder.decodeSingularStringField(value: &_storage._token)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._date.isEmpty {
        try visitor.visitSingularStringField(value: _storage._date, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 3)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_FaucetTx, rhs: Ocap_FaucetTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._date != rhs_storage._date {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RefuelTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefuelTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _date: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _date = source._date
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._date)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._date.isEmpty {
        try visitor.visitSingularStringField(value: _storage._date, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RefuelTx, rhs: Ocap_RefuelTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._date != rhs_storage._date {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RetrieveSwapTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetrieveSwapTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "hashkey"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _hashkey: Data = SwiftProtobuf.Internal.emptyData
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _hashkey = source._hashkey
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._hashkey)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._hashkey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hashkey, fieldNumber: 2)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RetrieveSwapTx, rhs: Ocap_RetrieveSwapTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._hashkey != rhs_storage._hashkey {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RevokeSwapTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeSwapTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RevokeSwapTx, rhs: Ocap_RevokeSwapTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_SetupSwapTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetupSwapTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "assets"),
    3: .same(proto: "receiver"),
    4: .same(proto: "hashlock"),
    5: .same(proto: "locktime"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _value: Ocap_BigUint? = nil
    var _assets: [String] = []
    var _receiver: String = String()
    var _hashlock: Data = SwiftProtobuf.Internal.emptyData
    var _locktime: UInt32 = 0
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _assets = source._assets
      _receiver = source._receiver
      _hashlock = source._hashlock
      _locktime = source._locktime
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        case 3: try decoder.decodeSingularStringField(value: &_storage._receiver)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._hashlock)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._locktime)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 2)
      }
      if !_storage._receiver.isEmpty {
        try visitor.visitSingularStringField(value: _storage._receiver, fieldNumber: 3)
      }
      if !_storage._hashlock.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._hashlock, fieldNumber: 4)
      }
      if _storage._locktime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._locktime, fieldNumber: 5)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_SetupSwapTx, rhs: Ocap_SetupSwapTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._hashlock != rhs_storage._hashlock {return false}
        if _storage._locktime != rhs_storage._locktime {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ApproveWithdrawTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApproveWithdrawTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "withdraw_tx_hash"),
    2: .same(proto: "evidence"),
  ]

  fileprivate class _StorageClass {
    var _withdrawTxHash: String = String()
    var _evidence: Ocap_Evidence? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _withdrawTxHash = source._withdrawTxHash
      _evidence = source._evidence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._withdrawTxHash)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._evidence)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._withdrawTxHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._withdrawTxHash, fieldNumber: 1)
      }
      if let v = _storage._evidence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ApproveWithdrawTx, rhs: Ocap_ApproveWithdrawTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._withdrawTxHash != rhs_storage._withdrawTxHash {return false}
        if _storage._evidence != rhs_storage._evidence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_DepositTokenTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepositTokenTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "address"),
    3: .same(proto: "evidence"),
  ]

  fileprivate class _StorageClass {
    var _value: Ocap_BigUint? = nil
    var _address: String = String()
    var _evidence: Ocap_Evidence? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _address = source._address
      _evidence = source._evidence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 2: try decoder.decodeSingularStringField(value: &_storage._address)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._evidence)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 2)
      }
      if let v = _storage._evidence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_DepositTokenTx, rhs: Ocap_DepositTokenTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._evidence != rhs_storage._evidence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_RevokeWithdrawTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeWithdrawTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "withdraw_tx_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.withdrawTxHash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.withdrawTxHash.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawTxHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_RevokeWithdrawTx, rhs: Ocap_RevokeWithdrawTx) -> Bool {
    if lhs.withdrawTxHash != rhs.withdrawTxHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_WithdrawTokenTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawTokenTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "to"),
    3: .standard(proto: "chain_type"),
    4: .standard(proto: "chain_id"),
    5: .same(proto: "ttl"),
  ]

  fileprivate class _StorageClass {
    var _value: Ocap_BigUint? = nil
    var _to: String = String()
    var _chainType: String = String()
    var _chainID: String = String()
    var _ttl: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _to = source._to
      _chainType = source._chainType
      _chainID = source._chainID
      _ttl = source._ttl
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 2: try decoder.decodeSingularStringField(value: &_storage._to)
        case 3: try decoder.decodeSingularStringField(value: &_storage._chainType)
        case 4: try decoder.decodeSingularStringField(value: &_storage._chainID)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._ttl)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 2)
      }
      if !_storage._chainType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainType, fieldNumber: 3)
      }
      if !_storage._chainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 4)
      }
      if let v = _storage._ttl {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_WithdrawTokenTx, rhs: Ocap_WithdrawTokenTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._chainType != rhs_storage._chainType {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._ttl != rhs_storage._ttl {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ExchangeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "assets"),
  ]

  fileprivate class _StorageClass {
    var _value: Ocap_BigUint? = nil
    var _assets: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _assets = source._assets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ExchangeInfo, rhs: Ocap_ExchangeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._assets != rhs_storage._assets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TokenPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TokenPayload, rhs: Ocap_TokenPayload) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ExchangeInfoV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeInfoV2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "assets"),
    3: .same(proto: "tokens"),
  ]

  fileprivate class _StorageClass {
    var _value: Ocap_BigUint? = nil
    var _assets: [String] = []
    var _tokens: [Ocap_TokenPayload] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _assets = source._assets
      _tokens = source._tokens
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._tokens)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 2)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ExchangeInfoV2, rhs: Ocap_ExchangeInfoV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ExchangeTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .standard(proto: "expired_at"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _to: String = String()
    var _sender: Ocap_ExchangeInfo? = nil
    var _receiver: Ocap_ExchangeInfo? = nil
    var _expiredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _to = source._to
      _sender = source._sender
      _receiver = source._receiver
      _expiredAt = source._expiredAt
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._to)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sender)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._receiver)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._expiredAt)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 1)
      }
      if let v = _storage._sender {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._receiver {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._expiredAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ExchangeTx, rhs: Ocap_ExchangeTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._to != rhs_storage._to {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._expiredAt != rhs_storage._expiredAt {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ExchangeV2Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeV2Tx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "sender"),
    3: .same(proto: "receiver"),
    4: .standard(proto: "expired_at"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _to: String = String()
    var _sender: Ocap_ExchangeInfoV2? = nil
    var _receiver: Ocap_ExchangeInfoV2? = nil
    var _expiredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _to = source._to
      _sender = source._sender
      _receiver = source._receiver
      _expiredAt = source._expiredAt
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._to)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sender)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._receiver)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._expiredAt)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 1)
      }
      if let v = _storage._sender {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._receiver {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._expiredAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ExchangeV2Tx, rhs: Ocap_ExchangeV2Tx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._to != rhs_storage._to {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._expiredAt != rhs_storage._expiredAt {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TransferTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "value"),
    3: .same(proto: "assets"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _to: String = String()
    var _value: Ocap_BigUint? = nil
    var _assets: [String] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _to = source._to
      _value = source._value
      _assets = source._assets
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._to)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 3)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TransferTx, rhs: Ocap_TransferTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._to != rhs_storage._to {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_TransferV2Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferV2Tx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "to"),
    2: .same(proto: "value"),
    3: .same(proto: "assets"),
    4: .same(proto: "tokens"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _to: String = String()
    var _value: Ocap_BigUint? = nil
    var _assets: [String] = []
    var _tokens: [Ocap_TokenPayload] = []
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _to = source._to
      _value = source._value
      _assets = source._assets
      _tokens = source._tokens
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._to)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._value)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._assets)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._tokens)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._to.isEmpty {
        try visitor.visitSingularStringField(value: _storage._to, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._assets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._assets, fieldNumber: 3)
      }
      if !_storage._tokens.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tokens, fieldNumber: 4)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_TransferV2Tx, rhs: Ocap_TransferV2Tx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._to != rhs_storage._to {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._assets != rhs_storage._assets {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_CreateTokenTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTokenTx"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "symbol"),
    4: .same(proto: "unit"),
    5: .same(proto: "icon"),
    6: .standard(proto: "total_supply"),
    7: .same(proto: "address"),
    8: .standard(proto: "faucet_supply"),
    15: .standard(proto: "erc20_contract_address"),
    20: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _symbol: String = String()
    var _unit: String = String()
    var _icon: String = String()
    var _totalSupply: String = String()
    var _address: String = String()
    var _faucetSupply: String = String()
    var _erc20ContractAddress: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _symbol = source._symbol
      _unit = source._unit
      _icon = source._icon
      _totalSupply = source._totalSupply
      _address = source._address
      _faucetSupply = source._faucetSupply
      _erc20ContractAddress = source._erc20ContractAddress
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 3: try decoder.decodeSingularStringField(value: &_storage._symbol)
        case 4: try decoder.decodeSingularStringField(value: &_storage._unit)
        case 5: try decoder.decodeSingularStringField(value: &_storage._icon)
        case 6: try decoder.decodeSingularStringField(value: &_storage._totalSupply)
        case 7: try decoder.decodeSingularStringField(value: &_storage._address)
        case 8: try decoder.decodeSingularStringField(value: &_storage._faucetSupply)
        case 15: try decoder.decodeSingularStringField(value: &_storage._erc20ContractAddress)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 3)
      }
      if !_storage._unit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unit, fieldNumber: 4)
      }
      if !_storage._icon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._icon, fieldNumber: 5)
      }
      if !_storage._totalSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._totalSupply, fieldNumber: 6)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 7)
      }
      if !_storage._faucetSupply.isEmpty {
        try visitor.visitSingularStringField(value: _storage._faucetSupply, fieldNumber: 8)
      }
      if !_storage._erc20ContractAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._erc20ContractAddress, fieldNumber: 15)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_CreateTokenTx, rhs: Ocap_CreateTokenTx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        if _storage._unit != rhs_storage._unit {return false}
        if _storage._icon != rhs_storage._icon {return false}
        if _storage._totalSupply != rhs_storage._totalSupply {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._faucetSupply != rhs_storage._faucetSupply {return false}
        if _storage._erc20ContractAddress != rhs_storage._erc20ContractAddress {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocap_ItxStub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ItxStub"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "declare"),
    2: .same(proto: "delegate"),
    3: .standard(proto: "revoke_delegate"),
    4: .standard(proto: "account_migrate"),
    5: .standard(proto: "create_asset"),
    6: .standard(proto: "consume_asset"),
    7: .standard(proto: "acquire_asset"),
    8: .standard(proto: "update_asset"),
    9: .same(proto: "exchange"),
    10: .standard(proto: "exchange_v2"),
    11: .same(proto: "transfer"),
    12: .standard(proto: "transfer_v2"),
    13: .same(proto: "poke"),
    14: .same(proto: "faucet"),
    15: .standard(proto: "upgrade_node"),
    16: .standard(proto: "revoke_swap"),
    17: .standard(proto: "retrieve_swap"),
    18: .standard(proto: "setup_swap"),
    19: .standard(proto: "create_token"),
    20: .standard(proto: "acquire_asset_v2"),
    21: .standard(proto: "mint_asset"),
  ]

  fileprivate class _StorageClass {
    var _value: Ocap_ItxStub.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Ocap_DeclareTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .declare(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .declare(v)}
        case 2:
          var v: Ocap_DelegateTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .delegate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .delegate(v)}
        case 3:
          var v: Ocap_RevokeDelegateTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .revokeDelegate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .revokeDelegate(v)}
        case 4:
          var v: Ocap_AccountMigrateTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .accountMigrate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .accountMigrate(v)}
        case 5:
          var v: Ocap_CreateAssetTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .createAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .createAsset(v)}
        case 6:
          var v: Ocap_ConsumeAssetTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .consumeAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .consumeAsset(v)}
        case 7:
          var v: Ocap_AcquireAssetTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .acquireAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .acquireAsset(v)}
        case 8:
          var v: Ocap_UpdateAssetTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .updateAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .updateAsset(v)}
        case 9:
          var v: Ocap_ExchangeTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .exchange(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .exchange(v)}
        case 10:
          var v: Ocap_ExchangeV2Tx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .exchangeV2(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .exchangeV2(v)}
        case 11:
          var v: Ocap_TransferTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .transfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .transfer(v)}
        case 12:
          var v: Ocap_TransferV2Tx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .transferV2(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .transferV2(v)}
        case 13:
          var v: Ocap_PokeTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .poke(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .poke(v)}
        case 14:
          var v: Ocap_FaucetTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .faucet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .faucet(v)}
        case 15:
          var v: Ocap_UpgradeNodeTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .upgradeNode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .upgradeNode(v)}
        case 16:
          var v: Ocap_RevokeSwapTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .revokeSwap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .revokeSwap(v)}
        case 17:
          var v: Ocap_RetrieveSwapTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .retrieveSwap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .retrieveSwap(v)}
        case 18:
          var v: Ocap_SetupSwapTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .setupSwap(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .setupSwap(v)}
        case 19:
          var v: Ocap_CreateTokenTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .createToken(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .createToken(v)}
        case 20:
          var v: Ocap_AcquireAssetV2Tx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .acquireAssetV2(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .acquireAssetV2(v)}
        case 21:
          var v: Ocap_MintAssetTx?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .mintAsset(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .mintAsset(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._value {
      case .declare(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .delegate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .revokeDelegate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .accountMigrate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .createAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .consumeAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .acquireAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .updateAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .exchange(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .exchangeV2(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .transfer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .transferV2(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .poke(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .faucet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .upgradeNode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .revokeSwap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .retrieveSwap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .setupSwap(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .createToken(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .acquireAssetV2(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .mintAsset(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocap_ItxStub, rhs: Ocap_ItxStub) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
