// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: type.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct ForgeAbi_BigUint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_BigSint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Data = SwiftProtobuf.Internal.emptyData

  public var minus: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_WalletType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pk: ForgeAbi_KeyType = .ed25519

  public var hash: ForgeAbi_HashType = .keccak

  public var address: ForgeAbi_EncodingType = .base16

  public var role: ForgeAbi_RoleType = .roleAccount

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_WalletInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: ForgeAbi_WalletType {
    get {return _storage._type ?? ForgeAbi_WalletType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var sk: Data {
    get {return _storage._sk}
    set {_uniqueStorage()._sk = newValue}
  }

  public var pk: Data {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ChainInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// node id.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// which network the node belongs to.
  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  /// name of the node.
  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  /// consensus engine version for this node.
  public var consensusVersion: String {
    get {return _storage._consensusVersion}
    set {_uniqueStorage()._consensusVersion = newValue}
  }

  /// indicate if this node is fully synced.
  public var synced: Bool {
    get {return _storage._synced}
    set {_uniqueStorage()._synced = newValue}
  }

  /// current application hash.
  public var appHash: Data {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  /// current block hash.
  public var blockHash: Data {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  /// latest block height, in integer.
  public var blockHeight: UInt64 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  /// latest block time.
  public var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  public var hasBlockTime: Bool {return _storage._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  public mutating func clearBlockTime() {_uniqueStorage()._blockTime = nil}

  /// the address of the node.
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// the voting power of the node, in integer.
  public var votingPower: UInt64 {
    get {return _storage._votingPower}
    set {_uniqueStorage()._votingPower = newValue}
  }

  /// total number of txs up to the latest block
  public var totalTxs: UInt64 {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  /// current forge version
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  ///  string data_version = 14;  current data version deprecated
  public var forgeAppsVersion: Dictionary<String,String> {
    get {return _storage._forgeAppsVersion}
    set {_uniqueStorage()._forgeAppsVersion = newValue}
  }

  public var supportedTxs: [String] {
    get {return _storage._supportedTxs}
    set {_uniqueStorage()._supportedTxs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// node id.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// which network the node belongs to.
  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  /// name of the node.
  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  /// consensus engine version for this node.
  public var consensusVersion: String {
    get {return _storage._consensusVersion}
    set {_uniqueStorage()._consensusVersion = newValue}
  }

  /// indicate if this node is fully synced.
  public var synced: Bool {
    get {return _storage._synced}
    set {_uniqueStorage()._synced = newValue}
  }

  /// current application hash.
  public var appHash: Data {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  /// current block hash.
  public var blockHash: Data {
    get {return _storage._blockHash}
    set {_uniqueStorage()._blockHash = newValue}
  }

  /// latest block height, in integer.
  public var blockHeight: UInt64 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  /// latest block time.
  public var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  public var hasBlockTime: Bool {return _storage._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  public mutating func clearBlockTime() {_uniqueStorage()._blockTime = nil}

  /// the address of the node.
  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// the voting power of the node, in integer.
  public var votingPower: UInt64 {
    get {return _storage._votingPower}
    set {_uniqueStorage()._votingPower = newValue}
  }

  /// total number of txs up to the latest block
  public var totalTxs: UInt64 {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  /// current forge version
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// string data_version = 14;  current data version deprecated
  public var forgeAppsVersion: Dictionary<String,String> {
    get {return _storage._forgeAppsVersion}
    set {_uniqueStorage()._forgeAppsVersion = newValue}
  }

  public var supportedTxs: [String] {
    get {return _storage._supportedTxs}
    set {_uniqueStorage()._supportedTxs = newValue}
  }

  /// self node ip
  public var ip: String {
    get {return _storage._ip}
    set {_uniqueStorage()._ip = newValue}
  }

  /// self node geo info
  public var geoInfo: ForgeAbi_GeoInfo {
    get {return _storage._geoInfo ?? ForgeAbi_GeoInfo()}
    set {_uniqueStorage()._geoInfo = newValue}
  }
  /// Returns true if `geoInfo` has been explicitly set.
  public var hasGeoInfo: Bool {return _storage._geoInfo != nil}
  /// Clears the value of `geoInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGeoInfo() {_uniqueStorage()._geoInfo = nil}

  /// id@ip:port
  public var p2PAddress: String {
    get {return _storage._p2PAddress}
    set {_uniqueStorage()._p2PAddress = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  /// setting power to 0 will remove existing address from validator
  public var power: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ConsensusParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maxBytes: UInt64 = 0

  public var maxGas: Int64 = 0

  /// we keep max_validators + max_candidates items in validator list, and only
  /// use max_validators items for the validators.
  public var maxValidators: UInt32 = 0

  public var maxCandidates: UInt32 = 0

  public var pubKeyTypes: [String] = []

  public var validators: [ForgeAbi_Validator] = []

  public var validatorChanged: Bool = false

  public var paramChanged: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// a deferred task (need more consideration)
public struct ForgeAbi_UpgradeTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: ForgeAbi_UpgradeType = .configApp

  /// data shall be first put into IPFS
  public var dataHash: String = String()

  /// actions
  public var actions: [ForgeAbi_UpgradeAction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_UpgradeTasks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: [ForgeAbi_UpgradeTask] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_AbciContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the hash of the transaction that being handled. Application can record this
  /// in their state as a reference.
  public var txHash: String {
    get {return _storage._txHash}
    set {_uniqueStorage()._txHash = newValue}
  }

  /// the height of the current block.
  public var blockHeight: UInt64 {
    get {return _storage._blockHeight}
    set {_uniqueStorage()._blockHeight = newValue}
  }

  /// the deterministic time of the current block.
  public var blockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._blockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._blockTime = newValue}
  }
  /// Returns true if `blockTime` has been explicitly set.
  public var hasBlockTime: Bool {return _storage._blockTime != nil}
  /// Clears the value of `blockTime`. Subsequent reads from it will return its default value.
  public mutating func clearBlockTime() {_uniqueStorage()._blockTime = nil}

  /// the total txs of the chain.
  public var totalTxs: UInt64 {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  /// tx statistics
  public var txStatistics: ForgeAbi_TxStatistics {
    get {return _storage._txStatistics ?? ForgeAbi_TxStatistics()}
    set {_uniqueStorage()._txStatistics = newValue}
  }
  /// Returns true if `txStatistics` has been explicitly set.
  public var hasTxStatistics: Bool {return _storage._txStatistics != nil}
  /// Clears the value of `txStatistics`. Subsequent reads from it will return its default value.
  public mutating func clearTxStatistics() {_uniqueStorage()._txStatistics = nil}

  public var txIndex: UInt32 {
    get {return _storage._txIndex}
    set {_uniqueStorage()._txIndex = newValue}
  }

  /// the deterministic time of the last block.
  public var lastBlockTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastBlockTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastBlockTime = newValue}
  }
  /// Returns true if `lastBlockTime` has been explicitly set.
  public var hasLastBlockTime: Bool {return _storage._lastBlockTime != nil}
  /// Clears the value of `lastBlockTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastBlockTime() {_uniqueStorage()._lastBlockTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_Multisig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// signer address
  public var signer: String {
    get {return _storage._signer}
    set {_uniqueStorage()._signer = newValue}
  }

  /// public key for signer
  public var pk: Data {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  /// signature
  public var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  /// delegator
  public var delegator: String {
    get {return _storage._delegator}
    set {_uniqueStorage()._delegator = newValue}
  }

  /// extra data
  public var data: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._data ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: String {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  public var nonce: UInt64 {
    get {return _storage._nonce}
    set {_uniqueStorage()._nonce = newValue}
  }

  /// use DID for the chain. "did:" prefix is omitted
  public var chainID: String {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  /// public key of the sender
  public var pk: Data {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  /// gas required for this tx
  public var gas: UInt32 {
    get {return _storage._gas}
    set {_uniqueStorage()._gas = newValue}
  }

  /// delegator
  public var delegator: String {
    get {return _storage._delegator}
    set {_uniqueStorage()._delegator = newValue}
  }

  /// signature of the transaction
  public var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  public var signatures: [ForgeAbi_Multisig] {
    get {return _storage._signatures}
    set {_uniqueStorage()._signatures = newValue}
  }

  public var itx: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._itx ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._itx = newValue}
  }
  /// Returns true if `itx` has been explicitly set.
  public var hasItx: Bool {return _storage._itx != nil}
  /// Clears the value of `itx`. Subsequent reads from it will return its default value.
  public mutating func clearItx() {_uniqueStorage()._itx = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tx: ForgeAbi_Transaction {
    get {return _storage._tx ?? ForgeAbi_Transaction()}
    set {_uniqueStorage()._tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  public var hasTx: Bool {return _storage._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  public mutating func clearTx() {_uniqueStorage()._tx = nil}

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var index: UInt32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var tags: [AbciVendor_KVPair] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var code: ForgeAbi_StatusCode {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_DeclareConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var restricted: Bool = false

  public var hierarchy: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_DelegateConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the interval used for calculate the num_txs_delta / num_tokens_delta
  public var deltaInterval: UInt32 = 0

  /// a list of type_urls that are allowed for delegation
  public var typeUrls: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_TransactionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maxAssetSize: UInt32 {
    get {return _storage._maxAssetSize}
    set {_uniqueStorage()._maxAssetSize = newValue}
  }

  public var maxListSize: UInt32 {
    get {return _storage._maxListSize}
    set {_uniqueStorage()._maxListSize = newValue}
  }

  public var maxMultisig: UInt32 {
    get {return _storage._maxMultisig}
    set {_uniqueStorage()._maxMultisig = newValue}
  }

  public var minimumStake: UInt64 {
    get {return _storage._minimumStake}
    set {_uniqueStorage()._minimumStake = newValue}
  }

  public var declare: ForgeAbi_DeclareConfig {
    get {return _storage._declare ?? ForgeAbi_DeclareConfig()}
    set {_uniqueStorage()._declare = newValue}
  }
  /// Returns true if `declare` has been explicitly set.
  public var hasDeclare: Bool {return _storage._declare != nil}
  /// Clears the value of `declare`. Subsequent reads from it will return its default value.
  public mutating func clearDeclare() {_uniqueStorage()._declare = nil}

  public var delegate: ForgeAbi_DelegateConfig {
    get {return _storage._delegate ?? ForgeAbi_DelegateConfig()}
    set {_uniqueStorage()._delegate = newValue}
  }
  /// Returns true if `delegate` has been explicitly set.
  public var hasDelegate: Bool {return _storage._delegate != nil}
  /// Clears the value of `delegate`. Subsequent reads from it will return its default value.
  public mutating func clearDelegate() {_uniqueStorage()._delegate = nil}

  public var poke: ForgeAbi_PokeConfig {
    get {return _storage._poke ?? ForgeAbi_PokeConfig()}
    set {_uniqueStorage()._poke = newValue}
  }
  /// Returns true if `poke` has been explicitly set.
  public var hasPoke: Bool {return _storage._poke != nil}
  /// Clears the value of `poke`. Subsequent reads from it will return its default value.
  public mutating func clearPoke() {_uniqueStorage()._poke = nil}

  public var stake: ForgeAbi_StakeConfig {
    get {return _storage._stake ?? ForgeAbi_StakeConfig()}
    set {_uniqueStorage()._stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  public var hasStake: Bool {return _storage._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  public mutating func clearStake() {_uniqueStorage()._stake = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_BlockInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var numTxs: UInt32 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var appHash: Data {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  public var proposer: Data {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  public var txs: [ForgeAbi_TransactionInfo] {
    get {return _storage._txs}
    set {_uniqueStorage()._txs = newValue}
  }

  public var totalTxs: UInt64 {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  public var invalidTxs: [ForgeAbi_TransactionInfo] {
    get {return _storage._invalidTxs}
    set {_uniqueStorage()._invalidTxs = newValue}
  }

  public var txsHashes: [String] {
    get {return _storage._txsHashes}
    set {_uniqueStorage()._txsHashes = newValue}
  }

  public var invalidTxsHashes: [String] {
    get {return _storage._invalidTxsHashes}
    set {_uniqueStorage()._invalidTxsHashes = newValue}
  }

  public var consensusHash: Data {
    get {return _storage._consensusHash}
    set {_uniqueStorage()._consensusHash = newValue}
  }

  public var dataHash: Data {
    get {return _storage._dataHash}
    set {_uniqueStorage()._dataHash = newValue}
  }

  public var evidenceHash: Data {
    get {return _storage._evidenceHash}
    set {_uniqueStorage()._evidenceHash = newValue}
  }

  public var lastCommitHash: Data {
    get {return _storage._lastCommitHash}
    set {_uniqueStorage()._lastCommitHash = newValue}
  }

  public var lastResultsHash: Data {
    get {return _storage._lastResultsHash}
    set {_uniqueStorage()._lastResultsHash = newValue}
  }

  public var nextValidatorsHash: Data {
    get {return _storage._nextValidatorsHash}
    set {_uniqueStorage()._nextValidatorsHash = newValue}
  }

  public var validatorsHash: Data {
    get {return _storage._validatorsHash}
    set {_uniqueStorage()._validatorsHash = newValue}
  }

  public var version: AbciVendor_Version {
    get {return _storage._version ?? AbciVendor_Version()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {_uniqueStorage()._version = nil}

  public var lastBlockID: AbciVendor_BlockID {
    get {return _storage._lastBlockID ?? AbciVendor_BlockID()}
    set {_uniqueStorage()._lastBlockID = newValue}
  }
  /// Returns true if `lastBlockID` has been explicitly set.
  public var hasLastBlockID: Bool {return _storage._lastBlockID != nil}
  /// Clears the value of `lastBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearLastBlockID() {_uniqueStorage()._lastBlockID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_BlockInfoSimple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var numTxs: UInt32 {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return _storage._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {_uniqueStorage()._time = nil}

  public var appHash: Data {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  public var proposer: Data {
    get {return _storage._proposer}
    set {_uniqueStorage()._proposer = newValue}
  }

  public var totalTxs: UInt64 {
    get {return _storage._totalTxs}
    set {_uniqueStorage()._totalTxs = newValue}
  }

  public var txsHashes: [String] {
    get {return _storage._txsHashes}
    set {_uniqueStorage()._txsHashes = newValue}
  }

  public var invalidTxsHashes: [String] {
    get {return _storage._invalidTxsHashes}
    set {_uniqueStorage()._invalidTxsHashes = newValue}
  }

  public var consensusHash: Data {
    get {return _storage._consensusHash}
    set {_uniqueStorage()._consensusHash = newValue}
  }

  public var dataHash: Data {
    get {return _storage._dataHash}
    set {_uniqueStorage()._dataHash = newValue}
  }

  public var evidenceHash: Data {
    get {return _storage._evidenceHash}
    set {_uniqueStorage()._evidenceHash = newValue}
  }

  public var lastCommitHash: Data {
    get {return _storage._lastCommitHash}
    set {_uniqueStorage()._lastCommitHash = newValue}
  }

  public var lastResultsHash: Data {
    get {return _storage._lastResultsHash}
    set {_uniqueStorage()._lastResultsHash = newValue}
  }

  public var nextValidatorsHash: Data {
    get {return _storage._nextValidatorsHash}
    set {_uniqueStorage()._nextValidatorsHash = newValue}
  }

  public var validatorsHash: Data {
    get {return _storage._validatorsHash}
    set {_uniqueStorage()._validatorsHash = newValue}
  }

  public var version: AbciVendor_Version {
    get {return _storage._version ?? AbciVendor_Version()}
    set {_uniqueStorage()._version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return _storage._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {_uniqueStorage()._version = nil}

  public var lastBlockID: AbciVendor_BlockID {
    get {return _storage._lastBlockID ?? AbciVendor_BlockID()}
    set {_uniqueStorage()._lastBlockID = newValue}
  }
  /// Returns true if `lastBlockID` has been explicitly set.
  public var hasLastBlockID: Bool {return _storage._lastBlockID != nil}
  /// Clears the value of `lastBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearLastBlockID() {_uniqueStorage()._lastBlockID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_TxStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: ForgeAbi_StatusCode = .ok

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_CircularQueue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// each item is the value of the Any
  public var items: [Data] = []

  /// data inserted into the queue shall have same type_url
  public var typeURL: String = String()

  /// if max_items is 0, meaning the queue has no size limit (use it cautious).
  /// Otherwise when queue is full, we either will not be able to add item
  /// (circular = false), or (circlar = true) replace an item (based on fifo).
  public var maxItems: UInt32 = 0

  public var circular: Bool = false

  /// default is false, meaning LIFO (last in first out). new items are prepend
  /// to the queue and when we drop items we drop the tail item. When it is true,
  /// new items are append to the tail, and when we drop items we drop the head.
  public var fifo: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_StateContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var genesisTx: String {
    get {return _storage._genesisTx}
    set {_uniqueStorage()._genesisTx = newValue}
  }

  public var renaissanceTx: String {
    get {return _storage._renaissanceTx}
    set {_uniqueStorage()._renaissanceTx = newValue}
  }

  public var genesisTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._genesisTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._genesisTime = newValue}
  }
  /// Returns true if `genesisTime` has been explicitly set.
  public var hasGenesisTime: Bool {return _storage._genesisTime != nil}
  /// Clears the value of `genesisTime`. Subsequent reads from it will return its default value.
  public mutating func clearGenesisTime() {_uniqueStorage()._genesisTime = nil}

  public var renaissanceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._renaissanceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._renaissanceTime = newValue}
  }
  /// Returns true if `renaissanceTime` has been explicitly set.
  public var hasRenaissanceTime: Bool {return _storage._renaissanceTime != nil}
  /// Clears the value of `renaissanceTime`. Subsequent reads from it will return its default value.
  public mutating func clearRenaissanceTime() {_uniqueStorage()._renaissanceTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_StakeContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total tokens staked for others
  public var totalStakes: ForgeAbi_BigUint {
    get {return _storage._totalStakes ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._totalStakes = newValue}
  }
  /// Returns true if `totalStakes` has been explicitly set.
  public var hasTotalStakes: Bool {return _storage._totalStakes != nil}
  /// Clears the value of `totalStakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalStakes() {_uniqueStorage()._totalStakes = nil}

  public var totalUnstakes: ForgeAbi_BigUint {
    get {return _storage._totalUnstakes ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._totalUnstakes = newValue}
  }
  /// Returns true if `totalUnstakes` has been explicitly set.
  public var hasTotalUnstakes: Bool {return _storage._totalUnstakes != nil}
  /// Clears the value of `totalUnstakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalUnstakes() {_uniqueStorage()._totalUnstakes = nil}

  /// total tokens being staked
  public var totalReceivedStakes: ForgeAbi_BigUint {
    get {return _storage._totalReceivedStakes ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._totalReceivedStakes = newValue}
  }
  /// Returns true if `totalReceivedStakes` has been explicitly set.
  public var hasTotalReceivedStakes: Bool {return _storage._totalReceivedStakes != nil}
  /// Clears the value of `totalReceivedStakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalReceivedStakes() {_uniqueStorage()._totalReceivedStakes = nil}

  /// keep a list of stake address. Only store recent N (e.g. 128) stakes.
  public var recentStakes: ForgeAbi_CircularQueue {
    get {return _storage._recentStakes ?? ForgeAbi_CircularQueue()}
    set {_uniqueStorage()._recentStakes = newValue}
  }
  /// Returns true if `recentStakes` has been explicitly set.
  public var hasRecentStakes: Bool {return _storage._recentStakes != nil}
  /// Clears the value of `recentStakes`. Subsequent reads from it will return its default value.
  public mutating func clearRecentStakes() {_uniqueStorage()._recentStakes = nil}

  /// keep a list of received stake address. Only store recent N (e.g. 128)
  /// stakes.
  public var recentReceivedStakes: ForgeAbi_CircularQueue {
    get {return _storage._recentReceivedStakes ?? ForgeAbi_CircularQueue()}
    set {_uniqueStorage()._recentReceivedStakes = newValue}
  }
  /// Returns true if `recentReceivedStakes` has been explicitly set.
  public var hasRecentReceivedStakes: Bool {return _storage._recentReceivedStakes != nil}
  /// Clears the value of `recentReceivedStakes`. Subsequent reads from it will return its default value.
  public mutating func clearRecentReceivedStakes() {_uniqueStorage()._recentReceivedStakes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_StakeSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalStakes: ForgeAbi_BigUint {
    get {return _storage._totalStakes ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._totalStakes = newValue}
  }
  /// Returns true if `totalStakes` has been explicitly set.
  public var hasTotalStakes: Bool {return _storage._totalStakes != nil}
  /// Clears the value of `totalStakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalStakes() {_uniqueStorage()._totalStakes = nil}

  public var totalUnstakes: ForgeAbi_BigUint {
    get {return _storage._totalUnstakes ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._totalUnstakes = newValue}
  }
  /// Returns true if `totalUnstakes` has been explicitly set.
  public var hasTotalUnstakes: Bool {return _storage._totalUnstakes != nil}
  /// Clears the value of `totalUnstakes`. Subsequent reads from it will return its default value.
  public mutating func clearTotalUnstakes() {_uniqueStorage()._totalUnstakes = nil}

  public var context: ForgeAbi_StateContext {
    get {return _storage._context ?? ForgeAbi_StateContext()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_StakeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeoutGeneral: UInt32 = 0

  public var timeoutStakeForNode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_UnconfirmedTxs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nTxs: UInt32 = 0

  public var txs: [ForgeAbi_Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_NetInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var listening: Bool = false

  public var listeners: [String] = []

  public var nPeers: UInt32 = 0

  public var peers: [ForgeAbi_PeerInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_GeoInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var city: String = String()

  public var country: String = String()

  public var latitude: Float = 0

  public var longitude: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_PeerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  public var consensusVersion: String {
    get {return _storage._consensusVersion}
    set {_uniqueStorage()._consensusVersion = newValue}
  }

  public var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  public var ip: String {
    get {return _storage._ip}
    set {_uniqueStorage()._ip = newValue}
  }

  public var geoInfo: ForgeAbi_GeoInfo {
    get {return _storage._geoInfo ?? ForgeAbi_GeoInfo()}
    set {_uniqueStorage()._geoInfo = newValue}
  }
  /// Returns true if `geoInfo` has been explicitly set.
  public var hasGeoInfo: Bool {return _storage._geoInfo != nil}
  /// Clears the value of `geoInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGeoInfo() {_uniqueStorage()._geoInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ValidatorsInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockHeight: UInt64 = 0

  public var validators: [ForgeAbi_ValidatorInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ValidatorInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var pubKey: AbciVendor_PubKey {
    get {return _storage._pubKey ?? AbciVendor_PubKey()}
    set {_uniqueStorage()._pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  public var hasPubKey: Bool {return _storage._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  public mutating func clearPubKey() {_uniqueStorage()._pubKey = nil}

  public var votingPower: UInt64 {
    get {return _storage._votingPower}
    set {_uniqueStorage()._votingPower = newValue}
  }

  public var proposerPriority: String {
    get {return _storage._proposerPriority}
    set {_uniqueStorage()._proposerPriority = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// validator geo info
  public var geoInfo: ForgeAbi_GeoInfo {
    get {return _storage._geoInfo ?? ForgeAbi_GeoInfo()}
    set {_uniqueStorage()._geoInfo = newValue}
  }
  /// Returns true if `geoInfo` has been explicitly set.
  public var hasGeoInfo: Bool {return _storage._geoInfo != nil}
  /// Clears the value of `geoInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGeoInfo() {_uniqueStorage()._geoInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_GenesisInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var genesisTime: String {
    get {return _storage._genesisTime}
    set {_uniqueStorage()._genesisTime = newValue}
  }

  public var chainID: String {
    get {return _storage._chainID}
    set {_uniqueStorage()._chainID = newValue}
  }

  public var consensusParams: AbciVendor_ConsensusParams {
    get {return _storage._consensusParams ?? AbciVendor_ConsensusParams()}
    set {_uniqueStorage()._consensusParams = newValue}
  }
  /// Returns true if `consensusParams` has been explicitly set.
  public var hasConsensusParams: Bool {return _storage._consensusParams != nil}
  /// Clears the value of `consensusParams`. Subsequent reads from it will return its default value.
  public mutating func clearConsensusParams() {_uniqueStorage()._consensusParams = nil}

  public var validators: [ForgeAbi_ValidatorInfo] {
    get {return _storage._validators}
    set {_uniqueStorage()._validators = newValue}
  }

  public var appHash: String {
    get {return _storage._appHash}
    set {_uniqueStorage()._appHash = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_ForgeStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numBlocks: [UInt64] {
    get {return _storage._numBlocks}
    set {_uniqueStorage()._numBlocks = newValue}
  }

  public var numTxs: [UInt64] {
    get {return _storage._numTxs}
    set {_uniqueStorage()._numTxs = newValue}
  }

  public var numStakes: [ForgeAbi_BigUint] {
    get {return _storage._numStakes}
    set {_uniqueStorage()._numStakes = newValue}
  }

  public var numValidators: [UInt32] {
    get {return _storage._numValidators}
    set {_uniqueStorage()._numValidators = newValue}
  }

  public var numAccountMigrateTxs: [UInt64] {
    get {return _storage._numAccountMigrateTxs}
    set {_uniqueStorage()._numAccountMigrateTxs = newValue}
  }

  public var numCreateAssetTxs: [UInt64] {
    get {return _storage._numCreateAssetTxs}
    set {_uniqueStorage()._numCreateAssetTxs = newValue}
  }

  public var numConsensusUpgradeTxs: [UInt32] {
    get {return _storage._numConsensusUpgradeTxs}
    set {_uniqueStorage()._numConsensusUpgradeTxs = newValue}
  }

  public var numDeclareTxs: [UInt64] {
    get {return _storage._numDeclareTxs}
    set {_uniqueStorage()._numDeclareTxs = newValue}
  }

  public var numDeclareFileTxs: [UInt64] {
    get {return _storage._numDeclareFileTxs}
    set {_uniqueStorage()._numDeclareFileTxs = newValue}
  }

  public var numExchangeTxs: [UInt64] {
    get {return _storage._numExchangeTxs}
    set {_uniqueStorage()._numExchangeTxs = newValue}
  }

  public var numStakeTxs: [UInt64] {
    get {return _storage._numStakeTxs}
    set {_uniqueStorage()._numStakeTxs = newValue}
  }

  public var numSysUpgradeTxs: [UInt32] {
    get {return _storage._numSysUpgradeTxs}
    set {_uniqueStorage()._numSysUpgradeTxs = newValue}
  }

  public var numTransferTxs: [UInt64] {
    get {return _storage._numTransferTxs}
    set {_uniqueStorage()._numTransferTxs = newValue}
  }

  public var numUpdateAssetTxs: [UInt64] {
    get {return _storage._numUpdateAssetTxs}
    set {_uniqueStorage()._numUpdateAssetTxs = newValue}
  }

  public var numConsumeAssetTxs: [UInt64] {
    get {return _storage._numConsumeAssetTxs}
    set {_uniqueStorage()._numConsumeAssetTxs = newValue}
  }

  public var numPokeTxs: [UInt64] {
    get {return _storage._numPokeTxs}
    set {_uniqueStorage()._numPokeTxs = newValue}
  }

  public var tps: [UInt32] {
    get {return _storage._tps}
    set {_uniqueStorage()._tps = newValue}
  }

  /// maximum tps in given time range
  public var maxTps: UInt32 {
    get {return _storage._maxTps}
    set {_uniqueStorage()._maxTps = newValue}
  }

  /// average tps in given time range
  public var avgTps: UInt32 {
    get {return _storage._avgTps}
    set {_uniqueStorage()._avgTps = newValue}
  }

  /// average blocks in given time range
  public var avgBlockTime: Float {
    get {return _storage._avgBlockTime}
    set {_uniqueStorage()._avgBlockTime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_TxStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numAccountMigrateTxs: UInt64 = 0

  public var numCreateAssetTxs: UInt64 = 0

  public var numConsensusUpgradeTxs: UInt32 = 0

  public var numDeclareTxs: UInt64 = 0

  public var numDeclareFileTxs: UInt64 = 0

  public var numExchangeTxs: UInt64 = 0

  public var numStakeTxs: UInt64 = 0

  public var numSysUpgradeTxs: UInt32 = 0

  public var numTransferTxs: UInt64 = 0

  public var numUpdateAssetTxs: UInt64 = 0

  public var numConsumeAssetTxs: UInt64 = 0

  public var numPokeTxs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_ForgeToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token name
  public var name: String = String()

  /// token symbol
  public var symbol: String = String()

  /// token smallest unit
  public var unit: String = String()

  /// token description
  public var description_p: String = String()

  /// token icon file in bytes
  public var icon: Data = SwiftProtobuf.Internal.emptyData

  /// token decimal
  public var decimal: UInt32 = 0

  /// token initial supply amount
  public var initialSupply: UInt64 = 0

  /// token total supply amount
  public var totalSupply: UInt64 = 0

  /// token inflation rate in integer
  public var inflationRate: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_PokeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// poke daily supply amount
  public var dailyLimit: ForgeAbi_BigUint {
    get {return _storage._dailyLimit ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._dailyLimit = newValue}
  }
  /// Returns true if `dailyLimit` has been explicitly set.
  public var hasDailyLimit: Bool {return _storage._dailyLimit != nil}
  /// Clears the value of `dailyLimit`. Subsequent reads from it will return its default value.
  public mutating func clearDailyLimit() {_uniqueStorage()._dailyLimit = nil}

  /// remaining poke daily supply amount
  public var leftover: ForgeAbi_BigUint {
    get {return _storage._leftover ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._leftover = newValue}
  }
  /// Returns true if `leftover` has been explicitly set.
  public var hasLeftover: Bool {return _storage._leftover != nil}
  /// Clears the value of `leftover`. Subsequent reads from it will return its default value.
  public mutating func clearLeftover() {_uniqueStorage()._leftover = nil}

  /// poke once supply amount
  public var amount: ForgeAbi_BigUint {
    get {return _storage._amount ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_PokeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// string address = 1; deprecated
  public var dailyLimit: UInt64 = 0

  /// uint64 balance = 3; deprecated
  public var amount: UInt64 = 0

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_UpgradeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var height: UInt64 = 0

  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ForgeAbi_WithdrawItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: String {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var value: ForgeAbi_BigUint {
    get {return _storage._value ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_AccountConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var pk: Data {
    get {return _storage._pk}
    set {_uniqueStorage()._pk = newValue}
  }

  public var balance: ForgeAbi_BigUint {
    get {return _storage._balance ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_TokenSwapConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commissionHolderAddress: String {
    get {return _storage._commissionHolderAddress}
    set {_uniqueStorage()._commissionHolderAddress = newValue}
  }

  public var withdrawInterval: UInt32 {
    get {return _storage._withdrawInterval}
    set {_uniqueStorage()._withdrawInterval = newValue}
  }

  public var commission: ForgeAbi_BigUint {
    get {return _storage._commission ?? ForgeAbi_BigUint()}
    set {_uniqueStorage()._commission = newValue}
  }
  /// Returns true if `commission` has been explicitly set.
  public var hasCommission: Bool {return _storage._commission != nil}
  /// Clears the value of `commission`. Subsequent reads from it will return its default value.
  public mutating func clearCommission() {_uniqueStorage()._commission = nil}

  public var commissionRate: UInt32 {
    get {return _storage._commissionRate}
    set {_uniqueStorage()._commissionRate = newValue}
  }

  public var revokeCommission: UInt32 {
    get {return _storage._revokeCommission}
    set {_uniqueStorage()._revokeCommission = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ForgeAbi_Evidence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tx hash from a foreign chain
  public var hash: String = String()

  /// type of the chain, currently only "eth"
  public var chainType: String = String()

  /// chain id of the chain. Could be testnet or mainnet.
  public var chainID: String = String()

  /// the binary for the original tx
  public var originalTx: Data = SwiftProtobuf.Internal.emptyData

  /// the address of the receiver (can only be controlled account)
  public var receiverAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "forge_abi"

extension ForgeAbi_BigUint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigUint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_BigUint, rhs: ForgeAbi_BigUint) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_BigSint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigSint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "minus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.value)
      case 2: try decoder.decodeSingularBoolField(value: &self.minus)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    if self.minus != false {
      try visitor.visitSingularBoolField(value: self.minus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_BigSint, rhs: ForgeAbi_BigSint) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.minus != rhs.minus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_WalletType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalletType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pk"),
    2: .same(proto: "hash"),
    3: .same(proto: "address"),
    4: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.pk)
      case 2: try decoder.decodeSingularEnumField(value: &self.hash)
      case 3: try decoder.decodeSingularEnumField(value: &self.address)
      case 4: try decoder.decodeSingularEnumField(value: &self.role)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pk != .ed25519 {
      try visitor.visitSingularEnumField(value: self.pk, fieldNumber: 1)
    }
    if self.hash != .keccak {
      try visitor.visitSingularEnumField(value: self.hash, fieldNumber: 2)
    }
    if self.address != .base16 {
      try visitor.visitSingularEnumField(value: self.address, fieldNumber: 3)
    }
    if self.role != .roleAccount {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_WalletType, rhs: ForgeAbi_WalletType) -> Bool {
    if lhs.pk != rhs.pk {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.address != rhs.address {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_WalletInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalletInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "sk"),
    3: .same(proto: "pk"),
    4: .same(proto: "address"),
  ]

  fileprivate class _StorageClass {
    var _type: ForgeAbi_WalletType? = nil
    var _sk: Data = SwiftProtobuf.Internal.emptyData
    var _pk: Data = SwiftProtobuf.Internal.emptyData
    var _address: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _sk = source._sk
      _pk = source._pk
      _address = source._address
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._sk)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._pk)
        case 4: try decoder.decodeSingularStringField(value: &_storage._address)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._sk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._sk, fieldNumber: 2)
      }
      if !_storage._pk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pk, fieldNumber: 3)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_WalletInfo, rhs: ForgeAbi_WalletInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._sk != rhs_storage._sk {return false}
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._address != rhs_storage._address {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "network"),
    3: .same(proto: "moniker"),
    4: .standard(proto: "consensus_version"),
    5: .same(proto: "synced"),
    6: .standard(proto: "app_hash"),
    7: .standard(proto: "block_hash"),
    8: .standard(proto: "block_height"),
    9: .standard(proto: "block_time"),
    10: .same(proto: "address"),
    11: .standard(proto: "voting_power"),
    12: .standard(proto: "total_txs"),
    13: .same(proto: "version"),
    15: .standard(proto: "forge_apps_version"),
    16: .standard(proto: "supported_txs"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _network: String = String()
    var _moniker: String = String()
    var _consensusVersion: String = String()
    var _synced: Bool = false
    var _appHash: Data = SwiftProtobuf.Internal.emptyData
    var _blockHash: Data = SwiftProtobuf.Internal.emptyData
    var _blockHeight: UInt64 = 0
    var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _address: String = String()
    var _votingPower: UInt64 = 0
    var _totalTxs: UInt64 = 0
    var _version: String = String()
    var _forgeAppsVersion: Dictionary<String,String> = [:]
    var _supportedTxs: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _network = source._network
      _moniker = source._moniker
      _consensusVersion = source._consensusVersion
      _synced = source._synced
      _appHash = source._appHash
      _blockHash = source._blockHash
      _blockHeight = source._blockHeight
      _blockTime = source._blockTime
      _address = source._address
      _votingPower = source._votingPower
      _totalTxs = source._totalTxs
      _version = source._version
      _forgeAppsVersion = source._forgeAppsVersion
      _supportedTxs = source._supportedTxs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._network)
        case 3: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 4: try decoder.decodeSingularStringField(value: &_storage._consensusVersion)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._synced)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._appHash)
        case 7: try decoder.decodeSingularBytesField(value: &_storage._blockHash)
        case 8: try decoder.decodeSingularUInt64Field(value: &_storage._blockHeight)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._blockTime)
        case 10: try decoder.decodeSingularStringField(value: &_storage._address)
        case 11: try decoder.decodeSingularUInt64Field(value: &_storage._votingPower)
        case 12: try decoder.decodeSingularUInt64Field(value: &_storage._totalTxs)
        case 13: try decoder.decodeSingularStringField(value: &_storage._version)
        case 15: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._forgeAppsVersion)
        case 16: try decoder.decodeRepeatedStringField(value: &_storage._supportedTxs)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 2)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 3)
      }
      if !_storage._consensusVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._consensusVersion, fieldNumber: 4)
      }
      if _storage._synced != false {
        try visitor.visitSingularBoolField(value: _storage._synced, fieldNumber: 5)
      }
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 6)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._blockHash, fieldNumber: 7)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._blockHeight, fieldNumber: 8)
      }
      if let v = _storage._blockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 10)
      }
      if _storage._votingPower != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._votingPower, fieldNumber: 11)
      }
      if _storage._totalTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalTxs, fieldNumber: 12)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 13)
      }
      if !_storage._forgeAppsVersion.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._forgeAppsVersion, fieldNumber: 15)
      }
      if !_storage._supportedTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._supportedTxs, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ChainInfo, rhs: ForgeAbi_ChainInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._consensusVersion != rhs_storage._consensusVersion {return false}
        if _storage._synced != rhs_storage._synced {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockTime != rhs_storage._blockTime {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._votingPower != rhs_storage._votingPower {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._forgeAppsVersion != rhs_storage._forgeAppsVersion {return false}
        if _storage._supportedTxs != rhs_storage._supportedTxs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "network"),
    3: .same(proto: "moniker"),
    4: .standard(proto: "consensus_version"),
    5: .same(proto: "synced"),
    6: .standard(proto: "app_hash"),
    7: .standard(proto: "block_hash"),
    8: .standard(proto: "block_height"),
    9: .standard(proto: "block_time"),
    10: .same(proto: "address"),
    11: .standard(proto: "voting_power"),
    12: .standard(proto: "total_txs"),
    13: .same(proto: "version"),
    15: .standard(proto: "forge_apps_version"),
    16: .standard(proto: "supported_txs"),
    17: .same(proto: "ip"),
    18: .standard(proto: "geo_info"),
    19: .standard(proto: "p2p_address"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _network: String = String()
    var _moniker: String = String()
    var _consensusVersion: String = String()
    var _synced: Bool = false
    var _appHash: Data = SwiftProtobuf.Internal.emptyData
    var _blockHash: Data = SwiftProtobuf.Internal.emptyData
    var _blockHeight: UInt64 = 0
    var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _address: String = String()
    var _votingPower: UInt64 = 0
    var _totalTxs: UInt64 = 0
    var _version: String = String()
    var _forgeAppsVersion: Dictionary<String,String> = [:]
    var _supportedTxs: [String] = []
    var _ip: String = String()
    var _geoInfo: ForgeAbi_GeoInfo? = nil
    var _p2PAddress: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _network = source._network
      _moniker = source._moniker
      _consensusVersion = source._consensusVersion
      _synced = source._synced
      _appHash = source._appHash
      _blockHash = source._blockHash
      _blockHeight = source._blockHeight
      _blockTime = source._blockTime
      _address = source._address
      _votingPower = source._votingPower
      _totalTxs = source._totalTxs
      _version = source._version
      _forgeAppsVersion = source._forgeAppsVersion
      _supportedTxs = source._supportedTxs
      _ip = source._ip
      _geoInfo = source._geoInfo
      _p2PAddress = source._p2PAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._network)
        case 3: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 4: try decoder.decodeSingularStringField(value: &_storage._consensusVersion)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._synced)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._appHash)
        case 7: try decoder.decodeSingularBytesField(value: &_storage._blockHash)
        case 8: try decoder.decodeSingularUInt64Field(value: &_storage._blockHeight)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._blockTime)
        case 10: try decoder.decodeSingularStringField(value: &_storage._address)
        case 11: try decoder.decodeSingularUInt64Field(value: &_storage._votingPower)
        case 12: try decoder.decodeSingularUInt64Field(value: &_storage._totalTxs)
        case 13: try decoder.decodeSingularStringField(value: &_storage._version)
        case 15: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._forgeAppsVersion)
        case 16: try decoder.decodeRepeatedStringField(value: &_storage._supportedTxs)
        case 17: try decoder.decodeSingularStringField(value: &_storage._ip)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._geoInfo)
        case 19: try decoder.decodeSingularStringField(value: &_storage._p2PAddress)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 2)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 3)
      }
      if !_storage._consensusVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._consensusVersion, fieldNumber: 4)
      }
      if _storage._synced != false {
        try visitor.visitSingularBoolField(value: _storage._synced, fieldNumber: 5)
      }
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 6)
      }
      if !_storage._blockHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._blockHash, fieldNumber: 7)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._blockHeight, fieldNumber: 8)
      }
      if let v = _storage._blockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 10)
      }
      if _storage._votingPower != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._votingPower, fieldNumber: 11)
      }
      if _storage._totalTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalTxs, fieldNumber: 12)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 13)
      }
      if !_storage._forgeAppsVersion.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._forgeAppsVersion, fieldNumber: 15)
      }
      if !_storage._supportedTxs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._supportedTxs, fieldNumber: 16)
      }
      if !_storage._ip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ip, fieldNumber: 17)
      }
      if let v = _storage._geoInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if !_storage._p2PAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._p2PAddress, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_NodeInfo, rhs: ForgeAbi_NodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._consensusVersion != rhs_storage._consensusVersion {return false}
        if _storage._synced != rhs_storage._synced {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._blockHash != rhs_storage._blockHash {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockTime != rhs_storage._blockTime {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._votingPower != rhs_storage._votingPower {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._forgeAppsVersion != rhs_storage._forgeAppsVersion {return false}
        if _storage._supportedTxs != rhs_storage._supportedTxs {return false}
        if _storage._ip != rhs_storage._ip {return false}
        if _storage._geoInfo != rhs_storage._geoInfo {return false}
        if _storage._p2PAddress != rhs_storage._p2PAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Validator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "power"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.power)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.power != 0 {
      try visitor.visitSingularUInt64Field(value: self.power, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_Validator, rhs: ForgeAbi_Validator) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ConsensusParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsensusParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_bytes"),
    2: .standard(proto: "max_gas"),
    3: .standard(proto: "max_validators"),
    4: .standard(proto: "max_candidates"),
    5: .standard(proto: "pub_key_types"),
    6: .same(proto: "validators"),
    7: .standard(proto: "validator_changed"),
    8: .standard(proto: "param_changed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.maxBytes)
      case 2: try decoder.decodeSingularSInt64Field(value: &self.maxGas)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.maxValidators)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.maxCandidates)
      case 5: try decoder.decodeRepeatedStringField(value: &self.pubKeyTypes)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.validators)
      case 7: try decoder.decodeSingularBoolField(value: &self.validatorChanged)
      case 8: try decoder.decodeSingularBoolField(value: &self.paramChanged)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxBytes, fieldNumber: 1)
    }
    if self.maxGas != 0 {
      try visitor.visitSingularSInt64Field(value: self.maxGas, fieldNumber: 2)
    }
    if self.maxValidators != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxValidators, fieldNumber: 3)
    }
    if self.maxCandidates != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxCandidates, fieldNumber: 4)
    }
    if !self.pubKeyTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pubKeyTypes, fieldNumber: 5)
    }
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 6)
    }
    if self.validatorChanged != false {
      try visitor.visitSingularBoolField(value: self.validatorChanged, fieldNumber: 7)
    }
    if self.paramChanged != false {
      try visitor.visitSingularBoolField(value: self.paramChanged, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ConsensusParams, rhs: ForgeAbi_ConsensusParams) -> Bool {
    if lhs.maxBytes != rhs.maxBytes {return false}
    if lhs.maxGas != rhs.maxGas {return false}
    if lhs.maxValidators != rhs.maxValidators {return false}
    if lhs.maxCandidates != rhs.maxCandidates {return false}
    if lhs.pubKeyTypes != rhs.pubKeyTypes {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.validatorChanged != rhs.validatorChanged {return false}
    if lhs.paramChanged != rhs.paramChanged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_UpgradeTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "data_hash"),
    4: .same(proto: "actions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.dataHash)
      case 4: try decoder.decodeRepeatedEnumField(value: &self.actions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .configApp {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.dataHash.isEmpty {
      try visitor.visitSingularStringField(value: self.dataHash, fieldNumber: 2)
    }
    if !self.actions.isEmpty {
      try visitor.visitPackedEnumField(value: self.actions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_UpgradeTask, rhs: ForgeAbi_UpgradeTask) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.dataHash != rhs.dataHash {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_UpgradeTasks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeTasks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.item)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_UpgradeTasks, rhs: ForgeAbi_UpgradeTasks) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_AbciContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AbciContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hash"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "block_time"),
    4: .standard(proto: "total_txs"),
    5: .standard(proto: "tx_statistics"),
    6: .standard(proto: "tx_index"),
    7: .standard(proto: "last_block_time"),
  ]

  fileprivate class _StorageClass {
    var _txHash: String = String()
    var _blockHeight: UInt64 = 0
    var _blockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _totalTxs: UInt64 = 0
    var _txStatistics: ForgeAbi_TxStatistics? = nil
    var _txIndex: UInt32 = 0
    var _lastBlockTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _txHash = source._txHash
      _blockHeight = source._blockHeight
      _blockTime = source._blockTime
      _totalTxs = source._totalTxs
      _txStatistics = source._txStatistics
      _txIndex = source._txIndex
      _lastBlockTime = source._lastBlockTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._txHash)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._blockHeight)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._blockTime)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._totalTxs)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._txStatistics)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._txIndex)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._lastBlockTime)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._txHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._txHash, fieldNumber: 1)
      }
      if _storage._blockHeight != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._blockHeight, fieldNumber: 2)
      }
      if let v = _storage._blockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._totalTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalTxs, fieldNumber: 4)
      }
      if let v = _storage._txStatistics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._txIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._txIndex, fieldNumber: 6)
      }
      if let v = _storage._lastBlockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_AbciContext, rhs: ForgeAbi_AbciContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._txHash != rhs_storage._txHash {return false}
        if _storage._blockHeight != rhs_storage._blockHeight {return false}
        if _storage._blockTime != rhs_storage._blockTime {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._txStatistics != rhs_storage._txStatistics {return false}
        if _storage._txIndex != rhs_storage._txIndex {return false}
        if _storage._lastBlockTime != rhs_storage._lastBlockTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_Multisig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Multisig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signer"),
    2: .same(proto: "pk"),
    3: .same(proto: "signature"),
    4: .same(proto: "delegator"),
    15: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _signer: String = String()
    var _pk: Data = SwiftProtobuf.Internal.emptyData
    var _signature: Data = SwiftProtobuf.Internal.emptyData
    var _delegator: String = String()
    var _data: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signer = source._signer
      _pk = source._pk
      _signature = source._signature
      _delegator = source._delegator
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._signer)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._pk)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._signature)
        case 4: try decoder.decodeSingularStringField(value: &_storage._delegator)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._signer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._signer, fieldNumber: 1)
      }
      if !_storage._pk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pk, fieldNumber: 2)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 3)
      }
      if !_storage._delegator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._delegator, fieldNumber: 4)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_Multisig, rhs: ForgeAbi_Multisig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signer != rhs_storage._signer {return false}
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._delegator != rhs_storage._delegator {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "chain_id"),
    4: .same(proto: "pk"),
    5: .same(proto: "gas"),
    6: .same(proto: "delegator"),
    13: .same(proto: "signature"),
    14: .same(proto: "signatures"),
    15: .same(proto: "itx"),
  ]

  fileprivate class _StorageClass {
    var _from: String = String()
    var _nonce: UInt64 = 0
    var _chainID: String = String()
    var _pk: Data = SwiftProtobuf.Internal.emptyData
    var _gas: UInt32 = 0
    var _delegator: String = String()
    var _signature: Data = SwiftProtobuf.Internal.emptyData
    var _signatures: [ForgeAbi_Multisig] = []
    var _itx: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _from = source._from
      _nonce = source._nonce
      _chainID = source._chainID
      _pk = source._pk
      _gas = source._gas
      _delegator = source._delegator
      _signature = source._signature
      _signatures = source._signatures
      _itx = source._itx
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._from)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._nonce)
        case 3: try decoder.decodeSingularStringField(value: &_storage._chainID)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._pk)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._gas)
        case 6: try decoder.decodeSingularStringField(value: &_storage._delegator)
        case 13: try decoder.decodeSingularBytesField(value: &_storage._signature)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._signatures)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._itx)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._from.isEmpty {
        try visitor.visitSingularStringField(value: _storage._from, fieldNumber: 1)
      }
      if _storage._nonce != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._nonce, fieldNumber: 2)
      }
      if !_storage._chainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 3)
      }
      if !_storage._pk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pk, fieldNumber: 4)
      }
      if _storage._gas != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gas, fieldNumber: 5)
      }
      if !_storage._delegator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._delegator, fieldNumber: 6)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 13)
      }
      if !_storage._signatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signatures, fieldNumber: 14)
      }
      if let v = _storage._itx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_Transaction, rhs: ForgeAbi_Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._from != rhs_storage._from {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._gas != rhs_storage._gas {return false}
        if _storage._delegator != rhs_storage._delegator {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._signatures != rhs_storage._signatures {return false}
        if _storage._itx != rhs_storage._itx {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "height"),
    3: .same(proto: "index"),
    4: .same(proto: "hash"),
    5: .same(proto: "tags"),
    6: .same(proto: "code"),
    7: .same(proto: "time"),
  ]

  fileprivate class _StorageClass {
    var _tx: ForgeAbi_Transaction? = nil
    var _height: UInt64 = 0
    var _index: UInt32 = 0
    var _hash: String = String()
    var _tags: [AbciVendor_KVPair] = []
    var _code: ForgeAbi_StatusCode = .ok
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tx = source._tx
      _height = source._height
      _index = source._index
      _hash = source._hash
      _tags = source._tags
      _code = source._code
      _time = source._time
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._tx)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._index)
        case 4: try decoder.decodeSingularStringField(value: &_storage._hash)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._tags)
        case 6: try decoder.decodeSingularEnumField(value: &_storage._code)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._time)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tx {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 2)
      }
      if _storage._index != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._index, fieldNumber: 3)
      }
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 4)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 5)
      }
      if _storage._code != .ok {
        try visitor.visitSingularEnumField(value: _storage._code, fieldNumber: 6)
      }
      if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_TransactionInfo, rhs: ForgeAbi_TransactionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tx != rhs_storage._tx {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._time != rhs_storage._time {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_DeclareConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeclareConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "restricted"),
    2: .same(proto: "hierarchy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.restricted)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.hierarchy)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.restricted != false {
      try visitor.visitSingularBoolField(value: self.restricted, fieldNumber: 1)
    }
    if self.hierarchy != 0 {
      try visitor.visitSingularUInt32Field(value: self.hierarchy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_DeclareConfig, rhs: ForgeAbi_DeclareConfig) -> Bool {
    if lhs.restricted != rhs.restricted {return false}
    if lhs.hierarchy != rhs.hierarchy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_DelegateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegateConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delta_interval"),
    2: .standard(proto: "type_urls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.deltaInterval)
      case 2: try decoder.decodeRepeatedStringField(value: &self.typeUrls)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deltaInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.deltaInterval, fieldNumber: 1)
    }
    if !self.typeUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeUrls, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_DelegateConfig, rhs: ForgeAbi_DelegateConfig) -> Bool {
    if lhs.deltaInterval != rhs.deltaInterval {return false}
    if lhs.typeUrls != rhs.typeUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_TransactionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_asset_size"),
    2: .standard(proto: "max_list_size"),
    3: .standard(proto: "max_multisig"),
    4: .standard(proto: "minimum_stake"),
    5: .same(proto: "declare"),
    6: .same(proto: "delegate"),
    7: .same(proto: "poke"),
    8: .same(proto: "stake"),
  ]

  fileprivate class _StorageClass {
    var _maxAssetSize: UInt32 = 0
    var _maxListSize: UInt32 = 0
    var _maxMultisig: UInt32 = 0
    var _minimumStake: UInt64 = 0
    var _declare: ForgeAbi_DeclareConfig? = nil
    var _delegate: ForgeAbi_DelegateConfig? = nil
    var _poke: ForgeAbi_PokeConfig? = nil
    var _stake: ForgeAbi_StakeConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _maxAssetSize = source._maxAssetSize
      _maxListSize = source._maxListSize
      _maxMultisig = source._maxMultisig
      _minimumStake = source._minimumStake
      _declare = source._declare
      _delegate = source._delegate
      _poke = source._poke
      _stake = source._stake
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._maxAssetSize)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._maxListSize)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._maxMultisig)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._minimumStake)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._declare)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._delegate)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._poke)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._stake)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._maxAssetSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxAssetSize, fieldNumber: 1)
      }
      if _storage._maxListSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxListSize, fieldNumber: 2)
      }
      if _storage._maxMultisig != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxMultisig, fieldNumber: 3)
      }
      if _storage._minimumStake != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._minimumStake, fieldNumber: 4)
      }
      if let v = _storage._declare {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._delegate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._poke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._stake {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_TransactionConfig, rhs: ForgeAbi_TransactionConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._maxAssetSize != rhs_storage._maxAssetSize {return false}
        if _storage._maxListSize != rhs_storage._maxListSize {return false}
        if _storage._maxMultisig != rhs_storage._maxMultisig {return false}
        if _storage._minimumStake != rhs_storage._minimumStake {return false}
        if _storage._declare != rhs_storage._declare {return false}
        if _storage._delegate != rhs_storage._delegate {return false}
        if _storage._poke != rhs_storage._poke {return false}
        if _storage._stake != rhs_storage._stake {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_BlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "num_txs"),
    3: .same(proto: "time"),
    4: .standard(proto: "app_hash"),
    5: .same(proto: "proposer"),
    6: .same(proto: "txs"),
    7: .standard(proto: "total_txs"),
    8: .standard(proto: "invalid_txs"),
    9: .standard(proto: "txs_hashes"),
    10: .standard(proto: "invalid_txs_hashes"),
    11: .standard(proto: "consensus_hash"),
    12: .standard(proto: "data_hash"),
    13: .standard(proto: "evidence_hash"),
    14: .standard(proto: "last_commit_hash"),
    15: .standard(proto: "last_results_hash"),
    16: .standard(proto: "next_validators_hash"),
    17: .standard(proto: "validators_hash"),
    18: .same(proto: "version"),
    19: .standard(proto: "last_block_id"),
  ]

  fileprivate class _StorageClass {
    var _height: UInt64 = 0
    var _numTxs: UInt32 = 0
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _appHash: Data = SwiftProtobuf.Internal.emptyData
    var _proposer: Data = SwiftProtobuf.Internal.emptyData
    var _txs: [ForgeAbi_TransactionInfo] = []
    var _totalTxs: UInt64 = 0
    var _invalidTxs: [ForgeAbi_TransactionInfo] = []
    var _txsHashes: [String] = []
    var _invalidTxsHashes: [String] = []
    var _consensusHash: Data = SwiftProtobuf.Internal.emptyData
    var _dataHash: Data = SwiftProtobuf.Internal.emptyData
    var _evidenceHash: Data = SwiftProtobuf.Internal.emptyData
    var _lastCommitHash: Data = SwiftProtobuf.Internal.emptyData
    var _lastResultsHash: Data = SwiftProtobuf.Internal.emptyData
    var _nextValidatorsHash: Data = SwiftProtobuf.Internal.emptyData
    var _validatorsHash: Data = SwiftProtobuf.Internal.emptyData
    var _version: AbciVendor_Version? = nil
    var _lastBlockID: AbciVendor_BlockID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _numTxs = source._numTxs
      _time = source._time
      _appHash = source._appHash
      _proposer = source._proposer
      _txs = source._txs
      _totalTxs = source._totalTxs
      _invalidTxs = source._invalidTxs
      _txsHashes = source._txsHashes
      _invalidTxsHashes = source._invalidTxsHashes
      _consensusHash = source._consensusHash
      _dataHash = source._dataHash
      _evidenceHash = source._evidenceHash
      _lastCommitHash = source._lastCommitHash
      _lastResultsHash = source._lastResultsHash
      _nextValidatorsHash = source._nextValidatorsHash
      _validatorsHash = source._validatorsHash
      _version = source._version
      _lastBlockID = source._lastBlockID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._numTxs)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._time)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._appHash)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._proposer)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._txs)
        case 7: try decoder.decodeSingularUInt64Field(value: &_storage._totalTxs)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._invalidTxs)
        case 9: try decoder.decodeRepeatedStringField(value: &_storage._txsHashes)
        case 10: try decoder.decodeRepeatedStringField(value: &_storage._invalidTxsHashes)
        case 11: try decoder.decodeSingularBytesField(value: &_storage._consensusHash)
        case 12: try decoder.decodeSingularBytesField(value: &_storage._dataHash)
        case 13: try decoder.decodeSingularBytesField(value: &_storage._evidenceHash)
        case 14: try decoder.decodeSingularBytesField(value: &_storage._lastCommitHash)
        case 15: try decoder.decodeSingularBytesField(value: &_storage._lastResultsHash)
        case 16: try decoder.decodeSingularBytesField(value: &_storage._nextValidatorsHash)
        case 17: try decoder.decodeSingularBytesField(value: &_storage._validatorsHash)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._version)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._lastBlockID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 1)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numTxs, fieldNumber: 2)
      }
      if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 4)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proposer, fieldNumber: 5)
      }
      if !_storage._txs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._txs, fieldNumber: 6)
      }
      if _storage._totalTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalTxs, fieldNumber: 7)
      }
      if !_storage._invalidTxs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._invalidTxs, fieldNumber: 8)
      }
      if !_storage._txsHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._txsHashes, fieldNumber: 9)
      }
      if !_storage._invalidTxsHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._invalidTxsHashes, fieldNumber: 10)
      }
      if !_storage._consensusHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._consensusHash, fieldNumber: 11)
      }
      if !_storage._dataHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._dataHash, fieldNumber: 12)
      }
      if !_storage._evidenceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._evidenceHash, fieldNumber: 13)
      }
      if !_storage._lastCommitHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastCommitHash, fieldNumber: 14)
      }
      if !_storage._lastResultsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastResultsHash, fieldNumber: 15)
      }
      if !_storage._nextValidatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nextValidatorsHash, fieldNumber: 16)
      }
      if !_storage._validatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._validatorsHash, fieldNumber: 17)
      }
      if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._lastBlockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_BlockInfo, rhs: ForgeAbi_BlockInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._txs != rhs_storage._txs {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._invalidTxs != rhs_storage._invalidTxs {return false}
        if _storage._txsHashes != rhs_storage._txsHashes {return false}
        if _storage._invalidTxsHashes != rhs_storage._invalidTxsHashes {return false}
        if _storage._consensusHash != rhs_storage._consensusHash {return false}
        if _storage._dataHash != rhs_storage._dataHash {return false}
        if _storage._evidenceHash != rhs_storage._evidenceHash {return false}
        if _storage._lastCommitHash != rhs_storage._lastCommitHash {return false}
        if _storage._lastResultsHash != rhs_storage._lastResultsHash {return false}
        if _storage._nextValidatorsHash != rhs_storage._nextValidatorsHash {return false}
        if _storage._validatorsHash != rhs_storage._validatorsHash {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._lastBlockID != rhs_storage._lastBlockID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_BlockInfoSimple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockInfoSimple"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .standard(proto: "num_txs"),
    3: .same(proto: "time"),
    4: .standard(proto: "app_hash"),
    5: .same(proto: "proposer"),
    6: .standard(proto: "total_txs"),
    7: .standard(proto: "txs_hashes"),
    8: .standard(proto: "invalid_txs_hashes"),
    9: .standard(proto: "consensus_hash"),
    10: .standard(proto: "data_hash"),
    11: .standard(proto: "evidence_hash"),
    12: .standard(proto: "last_commit_hash"),
    13: .standard(proto: "last_results_hash"),
    14: .standard(proto: "next_validators_hash"),
    15: .standard(proto: "validators_hash"),
    16: .same(proto: "version"),
    17: .standard(proto: "last_block_id"),
  ]

  fileprivate class _StorageClass {
    var _height: UInt64 = 0
    var _numTxs: UInt32 = 0
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _appHash: Data = SwiftProtobuf.Internal.emptyData
    var _proposer: Data = SwiftProtobuf.Internal.emptyData
    var _totalTxs: UInt64 = 0
    var _txsHashes: [String] = []
    var _invalidTxsHashes: [String] = []
    var _consensusHash: Data = SwiftProtobuf.Internal.emptyData
    var _dataHash: Data = SwiftProtobuf.Internal.emptyData
    var _evidenceHash: Data = SwiftProtobuf.Internal.emptyData
    var _lastCommitHash: Data = SwiftProtobuf.Internal.emptyData
    var _lastResultsHash: Data = SwiftProtobuf.Internal.emptyData
    var _nextValidatorsHash: Data = SwiftProtobuf.Internal.emptyData
    var _validatorsHash: Data = SwiftProtobuf.Internal.emptyData
    var _version: AbciVendor_Version? = nil
    var _lastBlockID: AbciVendor_BlockID? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _height = source._height
      _numTxs = source._numTxs
      _time = source._time
      _appHash = source._appHash
      _proposer = source._proposer
      _totalTxs = source._totalTxs
      _txsHashes = source._txsHashes
      _invalidTxsHashes = source._invalidTxsHashes
      _consensusHash = source._consensusHash
      _dataHash = source._dataHash
      _evidenceHash = source._evidenceHash
      _lastCommitHash = source._lastCommitHash
      _lastResultsHash = source._lastResultsHash
      _nextValidatorsHash = source._nextValidatorsHash
      _validatorsHash = source._validatorsHash
      _version = source._version
      _lastBlockID = source._lastBlockID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._height)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._numTxs)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._time)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._appHash)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._proposer)
        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._totalTxs)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._txsHashes)
        case 8: try decoder.decodeRepeatedStringField(value: &_storage._invalidTxsHashes)
        case 9: try decoder.decodeSingularBytesField(value: &_storage._consensusHash)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._dataHash)
        case 11: try decoder.decodeSingularBytesField(value: &_storage._evidenceHash)
        case 12: try decoder.decodeSingularBytesField(value: &_storage._lastCommitHash)
        case 13: try decoder.decodeSingularBytesField(value: &_storage._lastResultsHash)
        case 14: try decoder.decodeSingularBytesField(value: &_storage._nextValidatorsHash)
        case 15: try decoder.decodeSingularBytesField(value: &_storage._validatorsHash)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._version)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._lastBlockID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._height != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._height, fieldNumber: 1)
      }
      if _storage._numTxs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numTxs, fieldNumber: 2)
      }
      if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._appHash, fieldNumber: 4)
      }
      if !_storage._proposer.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._proposer, fieldNumber: 5)
      }
      if _storage._totalTxs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalTxs, fieldNumber: 6)
      }
      if !_storage._txsHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._txsHashes, fieldNumber: 7)
      }
      if !_storage._invalidTxsHashes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._invalidTxsHashes, fieldNumber: 8)
      }
      if !_storage._consensusHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._consensusHash, fieldNumber: 9)
      }
      if !_storage._dataHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._dataHash, fieldNumber: 10)
      }
      if !_storage._evidenceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._evidenceHash, fieldNumber: 11)
      }
      if !_storage._lastCommitHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastCommitHash, fieldNumber: 12)
      }
      if !_storage._lastResultsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastResultsHash, fieldNumber: 13)
      }
      if !_storage._nextValidatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nextValidatorsHash, fieldNumber: 14)
      }
      if !_storage._validatorsHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._validatorsHash, fieldNumber: 15)
      }
      if let v = _storage._version {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._lastBlockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_BlockInfoSimple, rhs: ForgeAbi_BlockInfoSimple) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._height != rhs_storage._height {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        if _storage._proposer != rhs_storage._proposer {return false}
        if _storage._totalTxs != rhs_storage._totalTxs {return false}
        if _storage._txsHashes != rhs_storage._txsHashes {return false}
        if _storage._invalidTxsHashes != rhs_storage._invalidTxsHashes {return false}
        if _storage._consensusHash != rhs_storage._consensusHash {return false}
        if _storage._dataHash != rhs_storage._dataHash {return false}
        if _storage._evidenceHash != rhs_storage._evidenceHash {return false}
        if _storage._lastCommitHash != rhs_storage._lastCommitHash {return false}
        if _storage._lastResultsHash != rhs_storage._lastResultsHash {return false}
        if _storage._nextValidatorsHash != rhs_storage._nextValidatorsHash {return false}
        if _storage._validatorsHash != rhs_storage._validatorsHash {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._lastBlockID != rhs_storage._lastBlockID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_TxStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_TxStatus, rhs: ForgeAbi_TxStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_CircularQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CircularQueue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
    2: .standard(proto: "type_url"),
    3: .standard(proto: "max_items"),
    4: .same(proto: "circular"),
    5: .same(proto: "fifo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.items)
      case 2: try decoder.decodeSingularStringField(value: &self.typeURL)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.maxItems)
      case 4: try decoder.decodeSingularBoolField(value: &self.circular)
      case 5: try decoder.decodeSingularBoolField(value: &self.fifo)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.items, fieldNumber: 1)
    }
    if !self.typeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.typeURL, fieldNumber: 2)
    }
    if self.maxItems != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxItems, fieldNumber: 3)
    }
    if self.circular != false {
      try visitor.visitSingularBoolField(value: self.circular, fieldNumber: 4)
    }
    if self.fifo != false {
      try visitor.visitSingularBoolField(value: self.fifo, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_CircularQueue, rhs: ForgeAbi_CircularQueue) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.typeURL != rhs.typeURL {return false}
    if lhs.maxItems != rhs.maxItems {return false}
    if lhs.circular != rhs.circular {return false}
    if lhs.fifo != rhs.fifo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_StateContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "genesis_tx"),
    2: .standard(proto: "renaissance_tx"),
    3: .standard(proto: "genesis_time"),
    4: .standard(proto: "renaissance_time"),
  ]

  fileprivate class _StorageClass {
    var _genesisTx: String = String()
    var _renaissanceTx: String = String()
    var _genesisTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _renaissanceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _genesisTx = source._genesisTx
      _renaissanceTx = source._renaissanceTx
      _genesisTime = source._genesisTime
      _renaissanceTime = source._renaissanceTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._genesisTx)
        case 2: try decoder.decodeSingularStringField(value: &_storage._renaissanceTx)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._genesisTime)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._renaissanceTime)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._genesisTx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTx, fieldNumber: 1)
      }
      if !_storage._renaissanceTx.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renaissanceTx, fieldNumber: 2)
      }
      if let v = _storage._genesisTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._renaissanceTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_StateContext, rhs: ForgeAbi_StateContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._genesisTx != rhs_storage._genesisTx {return false}
        if _storage._renaissanceTx != rhs_storage._renaissanceTx {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._renaissanceTime != rhs_storage._renaissanceTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_StakeContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_stakes"),
    2: .standard(proto: "total_unstakes"),
    3: .standard(proto: "total_received_stakes"),
    4: .standard(proto: "recent_stakes"),
    15: .standard(proto: "recent_received_stakes"),
  ]

  fileprivate class _StorageClass {
    var _totalStakes: ForgeAbi_BigUint? = nil
    var _totalUnstakes: ForgeAbi_BigUint? = nil
    var _totalReceivedStakes: ForgeAbi_BigUint? = nil
    var _recentStakes: ForgeAbi_CircularQueue? = nil
    var _recentReceivedStakes: ForgeAbi_CircularQueue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalStakes = source._totalStakes
      _totalUnstakes = source._totalUnstakes
      _totalReceivedStakes = source._totalReceivedStakes
      _recentStakes = source._recentStakes
      _recentReceivedStakes = source._recentReceivedStakes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._totalStakes)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._totalUnstakes)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._totalReceivedStakes)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._recentStakes)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._recentReceivedStakes)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._totalStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._totalUnstakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._totalReceivedStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._recentStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._recentReceivedStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_StakeContext, rhs: ForgeAbi_StakeContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalStakes != rhs_storage._totalStakes {return false}
        if _storage._totalUnstakes != rhs_storage._totalUnstakes {return false}
        if _storage._totalReceivedStakes != rhs_storage._totalReceivedStakes {return false}
        if _storage._recentStakes != rhs_storage._recentStakes {return false}
        if _storage._recentReceivedStakes != rhs_storage._recentReceivedStakes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_StakeSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_stakes"),
    2: .standard(proto: "total_unstakes"),
    3: .same(proto: "context"),
  ]

  fileprivate class _StorageClass {
    var _totalStakes: ForgeAbi_BigUint? = nil
    var _totalUnstakes: ForgeAbi_BigUint? = nil
    var _context: ForgeAbi_StateContext? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalStakes = source._totalStakes
      _totalUnstakes = source._totalUnstakes
      _context = source._context
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._totalStakes)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._totalUnstakes)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._context)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._totalStakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._totalUnstakes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_StakeSummary, rhs: ForgeAbi_StakeSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalStakes != rhs_storage._totalStakes {return false}
        if _storage._totalUnstakes != rhs_storage._totalUnstakes {return false}
        if _storage._context != rhs_storage._context {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_StakeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StakeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeout_general"),
    2: .standard(proto: "timeout_stake_for_node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.timeoutGeneral)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.timeoutStakeForNode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeoutGeneral != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeoutGeneral, fieldNumber: 1)
    }
    if self.timeoutStakeForNode != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeoutStakeForNode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_StakeConfig, rhs: ForgeAbi_StakeConfig) -> Bool {
    if lhs.timeoutGeneral != rhs.timeoutGeneral {return false}
    if lhs.timeoutStakeForNode != rhs.timeoutStakeForNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_UnconfirmedTxs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnconfirmedTxs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "n_txs"),
    2: .same(proto: "txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.nTxs)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.txs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nTxs != 0 {
      try visitor.visitSingularUInt32Field(value: self.nTxs, fieldNumber: 1)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_UnconfirmedTxs, rhs: ForgeAbi_UnconfirmedTxs) -> Bool {
    if lhs.nTxs != rhs.nTxs {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_NetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listening"),
    2: .same(proto: "listeners"),
    3: .standard(proto: "n_peers"),
    4: .same(proto: "peers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.listening)
      case 2: try decoder.decodeRepeatedStringField(value: &self.listeners)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.nPeers)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.peers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.listening != false {
      try visitor.visitSingularBoolField(value: self.listening, fieldNumber: 1)
    }
    if !self.listeners.isEmpty {
      try visitor.visitRepeatedStringField(value: self.listeners, fieldNumber: 2)
    }
    if self.nPeers != 0 {
      try visitor.visitSingularUInt32Field(value: self.nPeers, fieldNumber: 3)
    }
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_NetInfo, rhs: ForgeAbi_NetInfo) -> Bool {
    if lhs.listening != rhs.listening {return false}
    if lhs.listeners != rhs.listeners {return false}
    if lhs.nPeers != rhs.nPeers {return false}
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_GeoInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "city"),
    2: .same(proto: "country"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.city)
      case 2: try decoder.decodeSingularStringField(value: &self.country)
      case 3: try decoder.decodeSingularFloatField(value: &self.latitude)
      case 4: try decoder.decodeSingularFloatField(value: &self.longitude)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 1)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 2)
    }
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 3)
    }
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_GeoInfo, rhs: ForgeAbi_GeoInfo) -> Bool {
    if lhs.city != rhs.city {return false}
    if lhs.country != rhs.country {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_PeerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "network"),
    3: .standard(proto: "consensus_version"),
    4: .same(proto: "moniker"),
    5: .same(proto: "ip"),
    6: .standard(proto: "geo_info"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _network: String = String()
    var _consensusVersion: String = String()
    var _moniker: String = String()
    var _ip: String = String()
    var _geoInfo: ForgeAbi_GeoInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _network = source._network
      _consensusVersion = source._consensusVersion
      _moniker = source._moniker
      _ip = source._ip
      _geoInfo = source._geoInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._network)
        case 3: try decoder.decodeSingularStringField(value: &_storage._consensusVersion)
        case 4: try decoder.decodeSingularStringField(value: &_storage._moniker)
        case 5: try decoder.decodeSingularStringField(value: &_storage._ip)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._geoInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 2)
      }
      if !_storage._consensusVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._consensusVersion, fieldNumber: 3)
      }
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 4)
      }
      if !_storage._ip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ip, fieldNumber: 5)
      }
      if let v = _storage._geoInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_PeerInfo, rhs: ForgeAbi_PeerInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._consensusVersion != rhs_storage._consensusVersion {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        if _storage._ip != rhs_storage._ip {return false}
        if _storage._geoInfo != rhs_storage._geoInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ValidatorsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorsInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_height"),
    2: .same(proto: "validators"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.blockHeight)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.validators)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 1)
    }
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ValidatorsInfo, rhs: ForgeAbi_ValidatorsInfo) -> Bool {
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ValidatorInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidatorInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "pub_key"),
    3: .standard(proto: "voting_power"),
    4: .standard(proto: "proposer_priority"),
    5: .same(proto: "name"),
    6: .standard(proto: "geo_info"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _pubKey: AbciVendor_PubKey? = nil
    var _votingPower: UInt64 = 0
    var _proposerPriority: String = String()
    var _name: String = String()
    var _geoInfo: ForgeAbi_GeoInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _pubKey = source._pubKey
      _votingPower = source._votingPower
      _proposerPriority = source._proposerPriority
      _name = source._name
      _geoInfo = source._geoInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pubKey)
        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._votingPower)
        case 4: try decoder.decodeSingularStringField(value: &_storage._proposerPriority)
        case 5: try decoder.decodeSingularStringField(value: &_storage._name)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._geoInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._pubKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._votingPower != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._votingPower, fieldNumber: 3)
      }
      if !_storage._proposerPriority.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proposerPriority, fieldNumber: 4)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 5)
      }
      if let v = _storage._geoInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ValidatorInfo, rhs: ForgeAbi_ValidatorInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._pubKey != rhs_storage._pubKey {return false}
        if _storage._votingPower != rhs_storage._votingPower {return false}
        if _storage._proposerPriority != rhs_storage._proposerPriority {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._geoInfo != rhs_storage._geoInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_GenesisInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenesisInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "genesis_time"),
    2: .standard(proto: "chain_id"),
    3: .standard(proto: "consensus_params"),
    4: .same(proto: "validators"),
    5: .standard(proto: "app_hash"),
  ]

  fileprivate class _StorageClass {
    var _genesisTime: String = String()
    var _chainID: String = String()
    var _consensusParams: AbciVendor_ConsensusParams? = nil
    var _validators: [ForgeAbi_ValidatorInfo] = []
    var _appHash: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _genesisTime = source._genesisTime
      _chainID = source._chainID
      _consensusParams = source._consensusParams
      _validators = source._validators
      _appHash = source._appHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._genesisTime)
        case 2: try decoder.decodeSingularStringField(value: &_storage._chainID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._consensusParams)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._validators)
        case 5: try decoder.decodeSingularStringField(value: &_storage._appHash)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._genesisTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genesisTime, fieldNumber: 1)
      }
      if !_storage._chainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainID, fieldNumber: 2)
      }
      if let v = _storage._consensusParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._validators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._validators, fieldNumber: 4)
      }
      if !_storage._appHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appHash, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_GenesisInfo, rhs: ForgeAbi_GenesisInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._chainID != rhs_storage._chainID {return false}
        if _storage._consensusParams != rhs_storage._consensusParams {return false}
        if _storage._validators != rhs_storage._validators {return false}
        if _storage._appHash != rhs_storage._appHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ForgeStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgeStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_blocks"),
    2: .standard(proto: "num_txs"),
    3: .standard(proto: "num_stakes"),
    4: .standard(proto: "num_validators"),
    5: .standard(proto: "num_account_migrate_txs"),
    6: .standard(proto: "num_create_asset_txs"),
    7: .standard(proto: "num_consensus_upgrade_txs"),
    8: .standard(proto: "num_declare_txs"),
    9: .standard(proto: "num_declare_file_txs"),
    10: .standard(proto: "num_exchange_txs"),
    11: .standard(proto: "num_stake_txs"),
    12: .standard(proto: "num_sys_upgrade_txs"),
    13: .standard(proto: "num_transfer_txs"),
    14: .standard(proto: "num_update_asset_txs"),
    15: .standard(proto: "num_consume_asset_txs"),
    16: .standard(proto: "num_poke_txs"),
    17: .same(proto: "tps"),
    18: .standard(proto: "max_tps"),
    19: .standard(proto: "avg_tps"),
    20: .standard(proto: "avg_block_time"),
  ]

  fileprivate class _StorageClass {
    var _numBlocks: [UInt64] = []
    var _numTxs: [UInt64] = []
    var _numStakes: [ForgeAbi_BigUint] = []
    var _numValidators: [UInt32] = []
    var _numAccountMigrateTxs: [UInt64] = []
    var _numCreateAssetTxs: [UInt64] = []
    var _numConsensusUpgradeTxs: [UInt32] = []
    var _numDeclareTxs: [UInt64] = []
    var _numDeclareFileTxs: [UInt64] = []
    var _numExchangeTxs: [UInt64] = []
    var _numStakeTxs: [UInt64] = []
    var _numSysUpgradeTxs: [UInt32] = []
    var _numTransferTxs: [UInt64] = []
    var _numUpdateAssetTxs: [UInt64] = []
    var _numConsumeAssetTxs: [UInt64] = []
    var _numPokeTxs: [UInt64] = []
    var _tps: [UInt32] = []
    var _maxTps: UInt32 = 0
    var _avgTps: UInt32 = 0
    var _avgBlockTime: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _numBlocks = source._numBlocks
      _numTxs = source._numTxs
      _numStakes = source._numStakes
      _numValidators = source._numValidators
      _numAccountMigrateTxs = source._numAccountMigrateTxs
      _numCreateAssetTxs = source._numCreateAssetTxs
      _numConsensusUpgradeTxs = source._numConsensusUpgradeTxs
      _numDeclareTxs = source._numDeclareTxs
      _numDeclareFileTxs = source._numDeclareFileTxs
      _numExchangeTxs = source._numExchangeTxs
      _numStakeTxs = source._numStakeTxs
      _numSysUpgradeTxs = source._numSysUpgradeTxs
      _numTransferTxs = source._numTransferTxs
      _numUpdateAssetTxs = source._numUpdateAssetTxs
      _numConsumeAssetTxs = source._numConsumeAssetTxs
      _numPokeTxs = source._numPokeTxs
      _tps = source._tps
      _maxTps = source._maxTps
      _avgTps = source._avgTps
      _avgBlockTime = source._avgBlockTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedUInt64Field(value: &_storage._numBlocks)
        case 2: try decoder.decodeRepeatedUInt64Field(value: &_storage._numTxs)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._numStakes)
        case 4: try decoder.decodeRepeatedUInt32Field(value: &_storage._numValidators)
        case 5: try decoder.decodeRepeatedUInt64Field(value: &_storage._numAccountMigrateTxs)
        case 6: try decoder.decodeRepeatedUInt64Field(value: &_storage._numCreateAssetTxs)
        case 7: try decoder.decodeRepeatedUInt32Field(value: &_storage._numConsensusUpgradeTxs)
        case 8: try decoder.decodeRepeatedUInt64Field(value: &_storage._numDeclareTxs)
        case 9: try decoder.decodeRepeatedUInt64Field(value: &_storage._numDeclareFileTxs)
        case 10: try decoder.decodeRepeatedUInt64Field(value: &_storage._numExchangeTxs)
        case 11: try decoder.decodeRepeatedUInt64Field(value: &_storage._numStakeTxs)
        case 12: try decoder.decodeRepeatedUInt32Field(value: &_storage._numSysUpgradeTxs)
        case 13: try decoder.decodeRepeatedUInt64Field(value: &_storage._numTransferTxs)
        case 14: try decoder.decodeRepeatedUInt64Field(value: &_storage._numUpdateAssetTxs)
        case 15: try decoder.decodeRepeatedUInt64Field(value: &_storage._numConsumeAssetTxs)
        case 16: try decoder.decodeRepeatedUInt64Field(value: &_storage._numPokeTxs)
        case 17: try decoder.decodeRepeatedUInt32Field(value: &_storage._tps)
        case 18: try decoder.decodeSingularUInt32Field(value: &_storage._maxTps)
        case 19: try decoder.decodeSingularUInt32Field(value: &_storage._avgTps)
        case 20: try decoder.decodeSingularFloatField(value: &_storage._avgBlockTime)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._numBlocks.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numBlocks, fieldNumber: 1)
      }
      if !_storage._numTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numTxs, fieldNumber: 2)
      }
      if !_storage._numStakes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._numStakes, fieldNumber: 3)
      }
      if !_storage._numValidators.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._numValidators, fieldNumber: 4)
      }
      if !_storage._numAccountMigrateTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numAccountMigrateTxs, fieldNumber: 5)
      }
      if !_storage._numCreateAssetTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numCreateAssetTxs, fieldNumber: 6)
      }
      if !_storage._numConsensusUpgradeTxs.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._numConsensusUpgradeTxs, fieldNumber: 7)
      }
      if !_storage._numDeclareTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numDeclareTxs, fieldNumber: 8)
      }
      if !_storage._numDeclareFileTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numDeclareFileTxs, fieldNumber: 9)
      }
      if !_storage._numExchangeTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numExchangeTxs, fieldNumber: 10)
      }
      if !_storage._numStakeTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numStakeTxs, fieldNumber: 11)
      }
      if !_storage._numSysUpgradeTxs.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._numSysUpgradeTxs, fieldNumber: 12)
      }
      if !_storage._numTransferTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numTransferTxs, fieldNumber: 13)
      }
      if !_storage._numUpdateAssetTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numUpdateAssetTxs, fieldNumber: 14)
      }
      if !_storage._numConsumeAssetTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numConsumeAssetTxs, fieldNumber: 15)
      }
      if !_storage._numPokeTxs.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._numPokeTxs, fieldNumber: 16)
      }
      if !_storage._tps.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._tps, fieldNumber: 17)
      }
      if _storage._maxTps != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxTps, fieldNumber: 18)
      }
      if _storage._avgTps != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._avgTps, fieldNumber: 19)
      }
      if _storage._avgBlockTime != 0 {
        try visitor.visitSingularFloatField(value: _storage._avgBlockTime, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ForgeStats, rhs: ForgeAbi_ForgeStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._numBlocks != rhs_storage._numBlocks {return false}
        if _storage._numTxs != rhs_storage._numTxs {return false}
        if _storage._numStakes != rhs_storage._numStakes {return false}
        if _storage._numValidators != rhs_storage._numValidators {return false}
        if _storage._numAccountMigrateTxs != rhs_storage._numAccountMigrateTxs {return false}
        if _storage._numCreateAssetTxs != rhs_storage._numCreateAssetTxs {return false}
        if _storage._numConsensusUpgradeTxs != rhs_storage._numConsensusUpgradeTxs {return false}
        if _storage._numDeclareTxs != rhs_storage._numDeclareTxs {return false}
        if _storage._numDeclareFileTxs != rhs_storage._numDeclareFileTxs {return false}
        if _storage._numExchangeTxs != rhs_storage._numExchangeTxs {return false}
        if _storage._numStakeTxs != rhs_storage._numStakeTxs {return false}
        if _storage._numSysUpgradeTxs != rhs_storage._numSysUpgradeTxs {return false}
        if _storage._numTransferTxs != rhs_storage._numTransferTxs {return false}
        if _storage._numUpdateAssetTxs != rhs_storage._numUpdateAssetTxs {return false}
        if _storage._numConsumeAssetTxs != rhs_storage._numConsumeAssetTxs {return false}
        if _storage._numPokeTxs != rhs_storage._numPokeTxs {return false}
        if _storage._tps != rhs_storage._tps {return false}
        if _storage._maxTps != rhs_storage._maxTps {return false}
        if _storage._avgTps != rhs_storage._avgTps {return false}
        if _storage._avgBlockTime != rhs_storage._avgBlockTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_TxStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_account_migrate_txs"),
    2: .standard(proto: "num_create_asset_txs"),
    3: .standard(proto: "num_consensus_upgrade_txs"),
    4: .standard(proto: "num_declare_txs"),
    5: .standard(proto: "num_declare_file_txs"),
    6: .standard(proto: "num_exchange_txs"),
    7: .standard(proto: "num_stake_txs"),
    8: .standard(proto: "num_sys_upgrade_txs"),
    9: .standard(proto: "num_transfer_txs"),
    10: .standard(proto: "num_update_asset_txs"),
    11: .standard(proto: "num_consume_asset_txs"),
    12: .standard(proto: "num_poke_txs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.numAccountMigrateTxs)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.numCreateAssetTxs)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.numConsensusUpgradeTxs)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.numDeclareTxs)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.numDeclareFileTxs)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.numExchangeTxs)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.numStakeTxs)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.numSysUpgradeTxs)
      case 9: try decoder.decodeSingularUInt64Field(value: &self.numTransferTxs)
      case 10: try decoder.decodeSingularUInt64Field(value: &self.numUpdateAssetTxs)
      case 11: try decoder.decodeSingularUInt64Field(value: &self.numConsumeAssetTxs)
      case 12: try decoder.decodeSingularUInt64Field(value: &self.numPokeTxs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numAccountMigrateTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numAccountMigrateTxs, fieldNumber: 1)
    }
    if self.numCreateAssetTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numCreateAssetTxs, fieldNumber: 2)
    }
    if self.numConsensusUpgradeTxs != 0 {
      try visitor.visitSingularUInt32Field(value: self.numConsensusUpgradeTxs, fieldNumber: 3)
    }
    if self.numDeclareTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numDeclareTxs, fieldNumber: 4)
    }
    if self.numDeclareFileTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numDeclareFileTxs, fieldNumber: 5)
    }
    if self.numExchangeTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numExchangeTxs, fieldNumber: 6)
    }
    if self.numStakeTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numStakeTxs, fieldNumber: 7)
    }
    if self.numSysUpgradeTxs != 0 {
      try visitor.visitSingularUInt32Field(value: self.numSysUpgradeTxs, fieldNumber: 8)
    }
    if self.numTransferTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numTransferTxs, fieldNumber: 9)
    }
    if self.numUpdateAssetTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numUpdateAssetTxs, fieldNumber: 10)
    }
    if self.numConsumeAssetTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numConsumeAssetTxs, fieldNumber: 11)
    }
    if self.numPokeTxs != 0 {
      try visitor.visitSingularUInt64Field(value: self.numPokeTxs, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_TxStatistics, rhs: ForgeAbi_TxStatistics) -> Bool {
    if lhs.numAccountMigrateTxs != rhs.numAccountMigrateTxs {return false}
    if lhs.numCreateAssetTxs != rhs.numCreateAssetTxs {return false}
    if lhs.numConsensusUpgradeTxs != rhs.numConsensusUpgradeTxs {return false}
    if lhs.numDeclareTxs != rhs.numDeclareTxs {return false}
    if lhs.numDeclareFileTxs != rhs.numDeclareFileTxs {return false}
    if lhs.numExchangeTxs != rhs.numExchangeTxs {return false}
    if lhs.numStakeTxs != rhs.numStakeTxs {return false}
    if lhs.numSysUpgradeTxs != rhs.numSysUpgradeTxs {return false}
    if lhs.numTransferTxs != rhs.numTransferTxs {return false}
    if lhs.numUpdateAssetTxs != rhs.numUpdateAssetTxs {return false}
    if lhs.numConsumeAssetTxs != rhs.numConsumeAssetTxs {return false}
    if lhs.numPokeTxs != rhs.numPokeTxs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_ForgeToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgeToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .same(proto: "unit"),
    4: .same(proto: "description"),
    5: .same(proto: "icon"),
    6: .same(proto: "decimal"),
    7: .standard(proto: "initial_supply"),
    8: .standard(proto: "total_supply"),
    9: .standard(proto: "inflation_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularStringField(value: &self.unit)
      case 4: try decoder.decodeSingularStringField(value: &self.description_p)
      case 5: try decoder.decodeSingularBytesField(value: &self.icon)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.decimal)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.initialSupply)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.totalSupply)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.inflationRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularBytesField(value: self.icon, fieldNumber: 5)
    }
    if self.decimal != 0 {
      try visitor.visitSingularUInt32Field(value: self.decimal, fieldNumber: 6)
    }
    if self.initialSupply != 0 {
      try visitor.visitSingularUInt64Field(value: self.initialSupply, fieldNumber: 7)
    }
    if self.totalSupply != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalSupply, fieldNumber: 8)
    }
    if self.inflationRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.inflationRate, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_ForgeToken, rhs: ForgeAbi_ForgeToken) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.decimal != rhs.decimal {return false}
    if lhs.initialSupply != rhs.initialSupply {return false}
    if lhs.totalSupply != rhs.totalSupply {return false}
    if lhs.inflationRate != rhs.inflationRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_PokeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PokeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "daily_limit"),
    2: .same(proto: "leftover"),
    3: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _dailyLimit: ForgeAbi_BigUint? = nil
    var _leftover: ForgeAbi_BigUint? = nil
    var _amount: ForgeAbi_BigUint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dailyLimit = source._dailyLimit
      _leftover = source._leftover
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._dailyLimit)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._leftover)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._amount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._dailyLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._leftover {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_PokeInfo, rhs: ForgeAbi_PokeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dailyLimit != rhs_storage._dailyLimit {return false}
        if _storage._leftover != rhs_storage._leftover {return false}
        if _storage._amount != rhs_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_PokeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PokeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "daily_limit"),
    4: .same(proto: "amount"),
    5: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularUInt64Field(value: &self.dailyLimit)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.amount)
      case 5: try decoder.decodeSingularBoolField(value: &self.enabled)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dailyLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.dailyLimit, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_PokeConfig, rhs: ForgeAbi_PokeConfig) -> Bool {
    if lhs.dailyLimit != rhs.dailyLimit {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_UpgradeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpgradeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.height)
      case 2: try decoder.decodeSingularStringField(value: &self.version)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_UpgradeInfo, rhs: ForgeAbi_UpgradeInfo) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_WithdrawItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithdrawItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _hash: String = String()
    var _value: ForgeAbi_BigUint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._hash)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._hash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hash, fieldNumber: 1)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_WithdrawItem, rhs: ForgeAbi_WithdrawItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_AccountConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "pk"),
    3: .same(proto: "balance"),
  ]

  fileprivate class _StorageClass {
    var _address: String = String()
    var _pk: Data = SwiftProtobuf.Internal.emptyData
    var _balance: ForgeAbi_BigUint? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _pk = source._pk
      _balance = source._balance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._address)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._pk)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._balance)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 1)
      }
      if !_storage._pk.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._pk, fieldNumber: 2)
      }
      if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_AccountConfig, rhs: ForgeAbi_AccountConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._pk != rhs_storage._pk {return false}
        if _storage._balance != rhs_storage._balance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_TokenSwapConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenSwapConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commission_holder_address"),
    2: .standard(proto: "withdraw_interval"),
    3: .same(proto: "commission"),
    4: .standard(proto: "commission_rate"),
    5: .standard(proto: "revoke_commission"),
  ]

  fileprivate class _StorageClass {
    var _commissionHolderAddress: String = String()
    var _withdrawInterval: UInt32 = 0
    var _commission: ForgeAbi_BigUint? = nil
    var _commissionRate: UInt32 = 0
    var _revokeCommission: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _commissionHolderAddress = source._commissionHolderAddress
      _withdrawInterval = source._withdrawInterval
      _commission = source._commission
      _commissionRate = source._commissionRate
      _revokeCommission = source._revokeCommission
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._commissionHolderAddress)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._withdrawInterval)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._commission)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._commissionRate)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._revokeCommission)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._commissionHolderAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._commissionHolderAddress, fieldNumber: 1)
      }
      if _storage._withdrawInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._withdrawInterval, fieldNumber: 2)
      }
      if let v = _storage._commission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._commissionRate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._commissionRate, fieldNumber: 4)
      }
      if _storage._revokeCommission != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._revokeCommission, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_TokenSwapConfig, rhs: ForgeAbi_TokenSwapConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._commissionHolderAddress != rhs_storage._commissionHolderAddress {return false}
        if _storage._withdrawInterval != rhs_storage._withdrawInterval {return false}
        if _storage._commission != rhs_storage._commission {return false}
        if _storage._commissionRate != rhs_storage._commissionRate {return false}
        if _storage._revokeCommission != rhs_storage._revokeCommission {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ForgeAbi_Evidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Evidence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "chain_type"),
    3: .standard(proto: "chain_id"),
    4: .standard(proto: "original_tx"),
    5: .standard(proto: "receiver_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hash)
      case 2: try decoder.decodeSingularStringField(value: &self.chainType)
      case 3: try decoder.decodeSingularStringField(value: &self.chainID)
      case 4: try decoder.decodeSingularBytesField(value: &self.originalTx)
      case 5: try decoder.decodeSingularStringField(value: &self.receiverAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if !self.chainType.isEmpty {
      try visitor.visitSingularStringField(value: self.chainType, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    if !self.originalTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.originalTx, fieldNumber: 4)
    }
    if !self.receiverAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ForgeAbi_Evidence, rhs: ForgeAbi_Evidence) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.chainType != rhs.chainType {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.originalTx != rhs.originalTx {return false}
    if lhs.receiverAddress != rhs.receiverAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
